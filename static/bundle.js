(function(){var require = function (file, cwd) {
    var resolved = require.resolve(file, cwd || '/');
    var mod = require.modules[resolved];
    if (!mod) throw new Error(
        'Failed to resolve module ' + file + ', tried ' + resolved
    );
    var cached = require.cache[resolved];
    var res = cached? cached.exports : mod();
    return res;
};

require.paths = [];
require.modules = {};
require.cache = {};
require.extensions = [".js",".coffee",".json",".html",".svg"];

require._core = {
    'assert': true,
    'events': true,
    'fs': true,
    'path': true,
    'vm': true
};

require.resolve = (function () {
    return function (x, cwd) {
        if (!cwd) cwd = '/';

        if (require._core[x]) return x;
        var path = require.modules.path();
        cwd = path.resolve('/', cwd);
        var y = cwd || '/';

        if (x.match(/^(?:\.\.?\/|\/)/)) {
            var m = loadAsFileSync(path.resolve(y, x))
                || loadAsDirectorySync(path.resolve(y, x));
            if (m) return m;
        }

        var n = loadNodeModulesSync(x, y);
        if (n) return n;

        throw new Error("Cannot find module '" + x + "'");

        function loadAsFileSync (x) {
            x = path.normalize(x);
            if (require.modules[x]) {
                return x;
            }

            for (var i = 0; i < require.extensions.length; i++) {
                var ext = require.extensions[i];
                if (require.modules[x + ext]) return x + ext;
            }
        }

        function loadAsDirectorySync (x) {
            x = x.replace(/\/+$/, '');
            var pkgfile = path.normalize(x + '/package.json');
            if (require.modules[pkgfile]) {
                var pkg = require.modules[pkgfile]();
                var b = pkg.browserify;
                if (typeof b === 'object' && b.main) {
                    var m = loadAsFileSync(path.resolve(x, b.main));
                    if (m) return m;
                }
                else if (typeof b === 'string') {
                    var m = loadAsFileSync(path.resolve(x, b));
                    if (m) return m;
                }
                else if (pkg.main) {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                }
            }

            return loadAsFileSync(x + '/index');
        }

        function loadNodeModulesSync (x, start) {
            var dirs = nodeModulesPathsSync(start);
            for (var i = 0; i < dirs.length; i++) {
                var dir = dirs[i];
                var m = loadAsFileSync(dir + '/' + x);
                if (m) return m;
                var n = loadAsDirectorySync(dir + '/' + x);
                if (n) return n;
            }

            var m = loadAsFileSync(x);
            if (m) return m;
        }

        function nodeModulesPathsSync (start) {
            var parts;
            if (start === '/') parts = [ '' ];
            else parts = path.normalize(start).split('/');

            var dirs = [];
            for (var i = parts.length - 1; i >= 0; i--) {
                if (parts[i] === 'node_modules') continue;
                var dir = parts.slice(0, i + 1).join('/') + '/node_modules';
                dirs.push(dir);
            }

            return dirs;
        }
    };
})();

require.alias = function (from, to) {
    var path = require.modules.path();
    var res = null;
    try {
        res = require.resolve(from + '/package.json', '/');
    }
    catch (err) {
        res = require.resolve(from, '/');
    }
    var basedir = path.dirname(res);

    var keys = (Object.keys || function (obj) {
        var res = [];
        for (var key in obj) res.push(key);
        return res;
    })(require.modules);

    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key.slice(0, basedir.length + 1) === basedir + '/') {
            var f = key.slice(basedir.length);
            require.modules[to + f] = require.modules[basedir + f];
        }
        else if (key === basedir) {
            require.modules[to] = require.modules[basedir];
        }
    }
};

(function () {
    var process = {};
    var global = typeof window !== 'undefined' ? window : {};
    var definedProcess = false;

    require.define = function (filename, fn) {
        if (!definedProcess && require.modules.__browserify_process) {
            process = require.modules.__browserify_process();
            definedProcess = true;
        }

        var dirname = require._core[filename]
            ? ''
            : require.modules.path().dirname(filename)
        ;

        var require_ = function (file) {
            var requiredModule = require(file, dirname);
            var cached = require.cache[require.resolve(file, dirname)];

            if (cached && cached.parent === null) {
                cached.parent = module_;
            }

            return requiredModule;
        };
        require_.resolve = function (name) {
            return require.resolve(name, dirname);
        };
        require_.modules = require.modules;
        require_.define = require.define;
        require_.cache = require.cache;
        var module_ = {
            id : filename,
            filename: filename,
            exports : {},
            loaded : false,
            parent: null
        };

        require.modules[filename] = function () {
            require.cache[filename] = module_;
            fn.call(
                module_.exports,
                require_,
                module_,
                module_.exports,
                dirname,
                filename,
                process,
                global
            );
            module_.loaded = true;
            return module_.exports;
        };
    };
})();


require.define("path",Function(['require','module','exports','__dirname','__filename','process','global'],"function filter (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (fn(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length; i >= 0; i--) {\n    var last = parts[i];\n    if (last == '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Regex to split a filename into [*, dir, basename, ext]\n// posix version\nvar splitPathRe = /^(.+\\/(?!$)|\\/)?((?:.+?)?(\\.[^.]*)?)$/;\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\nvar resolvedPath = '',\n    resolvedAbsolute = false;\n\nfor (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {\n  var path = (i >= 0)\n      ? arguments[i]\n      : process.cwd();\n\n  // Skip empty and invalid entries\n  if (typeof path !== 'string' || !path) {\n    continue;\n  }\n\n  resolvedPath = path + '/' + resolvedPath;\n  resolvedAbsolute = path.charAt(0) === '/';\n}\n\n// At this point the path should be resolved to a full absolute path, but\n// handle relative paths to be safe (might happen when process.cwd() fails)\n\n// Normalize the path\nresolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\nvar isAbsolute = path.charAt(0) === '/',\n    trailingSlash = path.slice(-1) === '/';\n\n// Normalize the path\npath = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n  \n  return (isAbsolute ? '/' : '') + path;\n};\n\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    return p && typeof p === 'string';\n  }).join('/'));\n};\n\n\nexports.dirname = function(path) {\n  var dir = splitPathRe.exec(path)[1] || '';\n  var isWindows = false;\n  if (!dir) {\n    // No dirname\n    return '.';\n  } else if (dir.length === 1 ||\n      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {\n    // It is just a slash or a drive letter with a slash\n    return dir;\n  } else {\n    // It is a full dirname, strip trailing slash\n    return dir.substring(0, dir.length - 1);\n  }\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPathRe.exec(path)[2] || '';\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPathRe.exec(path)[3] || '';\n};\n\n//@ sourceURL=path"
));

require.define("__browserify_process",Function(['require','module','exports','__dirname','__filename','process','global'],"var process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n        && window.setImmediate;\n    var canPost = typeof window !== 'undefined'\n        && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return window.setImmediate;\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener('message', function (ev) {\n            if (ev.source === window && ev.data === 'browserify-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('browserify-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nprocess.binding = function (name) {\n    if (name === 'evals') return (require)('vm')\n    else throw new Error('No such module. (Possibly not yet loaded)')\n};\n\n(function () {\n    var cwd = '/';\n    var path;\n    process.cwd = function () { return cwd };\n    process.chdir = function (dir) {\n        if (!path) path = require('path');\n        cwd = path.resolve(dir, cwd);\n    };\n})();\n\n//@ sourceURL=__browserify_process"
));

require.define("/node_modules/insert/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index\"}\n//@ sourceURL=/node_modules/insert/package.json"
));

require.define("/node_modules/insert/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var slice = Array.prototype.slice\n    , toArray = slice.call.bind(slice)\n\nmodule.exports = {\n    prepend: prepend\n    , append: append\n    , after: after\n    , before: before\n    , remove: remove\n    , replace: replace\n    , mutation: mutation\n}\n\nfunction prepend(parent) {\n    var node = mutation(toArray(arguments, 1))\n    parent.insertBefore(node, parent.firstChild)\n}\n\nfunction append(parent) {\n    var node = mutation(toArray(arguments, 1))\n    parent.appendChild(node)\n}\n\nfunction before(sibling) {\n    var node = mutation(toArray(arguments, 1))\n        , parent = sibling.parentNode\n\n    parent.insertBefore(node, sibling)\n}\n\nfunction after(sibling) {\n    var node = mutation(toArray(arguments, 1))\n        , parent = sibling.parentNode\n        , child = sibling.nextSibling\n\n    parent.insertBefore(node, child)\n}\n\nfunction replace(target) {\n    var node = mutation(toArray(arguments, 1))\n        , parent = target.parentNode\n\n    parent.replaceChild(node, target)\n}\n\nfunction remove() {\n    var list = toArray(arguments)\n    list.forEach(removeFromParent)\n}\n\nfunction removeFromParent(elem) {\n    elem.parentNode.removeChild(elem)\n}\n\nfunction mutation(list) {\n    list = list.map(replaceStringWithTextNode)\n\n    if (list.length === 1) {\n        return list[0]\n    }\n\n    var frag = document.createDocumentFragment()\n    list.forEach(appendToFragment, frag)\n    return frag\n}\n\nfunction replaceStringWithTextNode(string) {\n    if (typeof string === \"string\") {\n        return document.createTextNode(string)\n    }\n\n    return string\n}\n\nfunction appendToFragment(elem) {\n    this.appendChild(elem)\n}\n//@ sourceURL=/node_modules/insert/index.js"
));

require.define("/node_modules/ap/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"./index.js\"}\n//@ sourceURL=/node_modules/ap/package.json"
));

require.define("/node_modules/ap/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"exports = module.exports = ap;\nfunction ap (args, fn) {\n    return function () {\n        return fn.apply(this, args.concat.apply(args, arguments));\n    };\n}\n\nexports.pa = pa;\nfunction pa (args, fn) {\n    return function () {\n        return fn.apply(this, [].slice.call(arguments).concat(args));\n    };\n}\n\nexports.apa = apa;\nfunction apa (left, right, fn) {\n    return function () {\n        return fn.apply(this,\n            left.concat.apply(left, arguments).concat(right)\n        );\n    };\n}\n\nexports.partial = partial;\nfunction partial (fn) {\n    var args = [].slice.call(arguments, 1);\n    return ap(args, fn);\n}\n\nexports.partialRight = partialRight;\nfunction partialRight (fn) {\n    var args = [].slice.call(arguments, 1);\n    return pa(args, fn);\n}\n\nexports.curry = curry;\nfunction curry (fn) {\n    return partial(partial, fn);\n}\n\nexports.curryRight = function curryRight (fn) {\n    return partial(partialRight, fn);\n}\n\n//@ sourceURL=/node_modules/ap/index.js"
));

require.define("/node_modules/reducers/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/reducers/package.json"
));

require.define("/node_modules/reducers/channel.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar hub = require(\"./hub\")\nvar signal = require(\"./signal\")\n\nfunction channel() {\n  /**\n  Return a channel -- a sequence of events over time that may be reduced by\n  one or more consumer functions.\n\n  Channels are `signals` that have been transformed by `hub`, allowing them\n  to be reduced more than once.\n  **/\n  return hub(signal())\n}\n\nmodule.exports = channel\n\n//@ sourceURL=/node_modules/reducers/channel.js"
));

require.define("/node_modules/reducers/hub.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar accumulate = require(\"./accumulate\")\nvar convert = require(\"./convert\")\nvar accumulated = require(\"./accumulated\")\nvar end = require(\"./end\")\n\nvar input = \"input@\" + module.id\nvar consumers = \"consumers@\" + module.id\n\nfunction close(consumers, end) {\n  while (consumers.length) {\n    var count = consumers.length\n    var index = 0\n    while (index < count) {\n      var consumer = consumers[index]\n      consumer.next(end, consumer.state)\n      index = index + 1\n    }\n    consumers.splice(0, count)\n  }\n}\n\nfunction dispatch(consumers, value) {\n  var count = consumers.length\n  var index = 0\n  while (index < count) {\n    var consumer = consumers[index]\n    var state = consumer.next(value, consumer.state)\n    // If consumer has finished accumulation remove it from the consumers\n    // list. And dispatch end of stream on it (maybe that should not be\n    // necessary).\n    if (state && state.is === accumulated) {\n      consumers.splice(index, 1)\n      consumer.next(end(), state.value)\n      // If consumer is removed than we decrease count as consumers array\n      // will contain less elements (unless of course more elements were\n      // added but we would like to ignore those).\n      count = count - 1\n    } else {\n      consumer.state = state\n      index = index + 1\n    }\n  }\n}\n\nfunction open(hub) {\n  var source = hub[input]\n  var reducers = hub[consumers]\n  hub[input] = null         // mark hub as open\n  accumulate(source, function distribute(value) {\n    // If it's end of the source we close all the reducers including\n    // ones that subscribe as side effect.\n    if (value && value.is === end) close(reducers, value)\n    // otherwise we dispatch value to all the registered reducers.\n    else dispatch(reducers, value)\n\n    // reducers will be empty if either source is drained or if all the\n    // reducers finished reductions. Either way we reset input back to\n    // source and return `accumulated` marker to stop the reduction of\n    // source.\n    if (reducers.length === 0) {\n      hub[input] = source\n      return accumulated()\n    }\n  })\n}\n\nfunction isHub(value) {\n  return !value || (input in value && consumers in value)\n}\n\nfunction isOpen(hub) {\n  return hub[input] === null\n}\n\nfunction hub(source) {\n  /**\n  Take a reducible `source`, such as a `signal` and return a reducible that can\n  be consumed by many reducers.\n  **/\n\n  // If source is already a hub avoid just return.\n  if (isHub(source)) return source\n  var value = convert(source, hub.accumulate)\n  value[input] = source\n  value[consumers] = []\n  return value\n}\nhub.isHub = isHub\nhub.isOpen = isOpen\nhub.accumulate = function accumulate(hub, next, initial) {\n  // Enqueue new consumer into consumers array so that new\n  // values will be delegated to it.\n  hub[consumers].push({ next: next, state: initial })\n  // If source is not in the process of consumption than\n  // start it up.\n  if (!isOpen(hub)) open(hub)\n}\nmodule.exports = hub\n\n//@ sourceURL=/node_modules/reducers/hub.js"
));

require.define("/node_modules/reducers/accumulate.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar Method = require(\"method\")\nvar end = require(\"./end\")\nvar accumulated = require(\"./accumulated\")\nvar Eventual = require(\"eventual/type\")\nvar when = require(\"eventual/when\")\nvar error = require(\"./error\")\n\nvar accumulate = Method()\n\n// Implementation of accumulate for the empty sequences, that immediately\n// signals end of sequence.\naccumulate.empty = function accumulateEmpty(empty, next, start) {\n  next(end(), start)\n}\n// Implementation of accumulate for the singular values which are treated\n// as sequences with single element. Yields the given value and signals\n// the end of sequence.\naccumulate.singular = function accumulateSingular(value, next, start) {\n  next(end(), next(value, start))\n}\n// Implementation accumulate for the array (and alike) values, such that it\n// will call accumulator function `next` each time with next item and\n// accumulated state until it's exhausted or `next` returns marked value\n// indicating that it's done accumulating. Either way signals end to\n// an accumulator.\naccumulate.indexed = function accumulateIndexed(indexed, next, initial) {\n  var state = initial, index = 0, count = indexed.length\n  while (index < count) {\n    state = next(indexed[index++], state)\n    if (state && state.is === accumulated) break\n  }\n  next(end(), state)\n}\n\n// Both `undefined` and `null` implement accumulate for empty sequences.\naccumulate.define(void(0), accumulate.empty)\naccumulate.define(null, accumulate.empty)\n\n// Array and arguments implement accumulate for indexed sequences.\naccumulate.define(Array, accumulate.indexed)\naccumulate.define((function() { return arguments })(), accumulate.indexed)\n\n// All other built-in data structures are treated as single value sequences\n// by default. Of course individual types may choose to override that.\naccumulate.define(accumulate.singular)\n\n// All eventual values are treated as a single value of sequences, of\n// the value they realize to.\naccumulate.define(Eventual, function(eventual, next, initial) {\n  return when(eventual, function delivered(value) {\n    return accumulate(value, next, initial)\n  }, function failed(failure) {\n    next(end(), next(error(failure), initial))\n  })\n})\n\nmodule.exports = accumulate\n\n//@ sourceURL=/node_modules/reducers/accumulate.js"
));

require.define("/node_modules/reducers/node_modules/method/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"./core.js\"}\n//@ sourceURL=/node_modules/reducers/node_modules/method/package.json"
));

require.define("/node_modules/reducers/node_modules/method/core.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/* vim:set ts=2 sw=2 sts=2 expandtab */\n/*jshint asi: true undef: true es5: true node: true browser: true devel: true\n         forin: true latedef: false globalstrict: true */\n'use strict';\n\n// Shortcuts for ES5 reflection functions.\nvar make = Object.create || (function() {\n  var Type = function Type() {}\n  return function make(prototype) {\n    Type.prototype = prototype\n    return new Type()\n  }\n})\nvar defineProperty = Object.defineProperty || function(object, name, property) {\n  object[name] = property.value\n  return object\n}\nvar typefy = Object.prototype.toString\n\nfunction Method(base) {\n  /**\n  Private Method is a callable private name that dispatches on the first\n  arguments same named Method: Method(...rest) => rest[0][Method](...rest)\n  Default implementation may be passed in as an argument.\n  **/\n\n  // Create an internal unique name if default implementation is passed,\n  // use it's name as a name hint.\n  var name = (base && base.name || \"\") + Math.random().toString(32).substr(2)\n\n  function dispatch() {\n    // Method dispatches on type of the first argument.\n    var target = arguments[0]\n    var builtin = null\n    // If first argument is `null` or `undefined` use associated property\n    // maps for implementation lookups, otherwise attempt to use implementation\n    // for built-in falling back for implementation on the first argument.\n    // Finally use default implementation if no other one is found.\n    var method = target === null ? Null[name] :\n                 target === undefined ? Undefined[name] :\n                 target[name] ||\n                 ((builtin = Builtins[typefy.call(target)]) && builtin[name]) ||\n                 Builtins.Object[name] ||\n                 Default[name]\n\n    // If implementation not found there's not much we can do about it,\n    // throw error with a descriptive message.\n    if (!method) throw Error('Type does not implements method')\n\n    // If implementation is found delegate to it.\n    return method.apply(method, arguments)\n  }\n\n  // Define default implementation.\n  Default[name] = base\n\n  // Define `Method.toString` returning private name, this hack will enable\n  // Method definition like follows:\n  // var foo = Method()\n  // object[foo] = function() { /***/ }\n  dispatch.toString = function toString() { return name }\n\n  // Copy utility Methods for convenient API.\n  dispatch.implement = implementMethod\n  dispatch.define = defineMethod\n\n  return dispatch\n}\n\n// Define objects where Methods implementations for `null`, `undefined` and\n// defaults will be stored.\nvar Default = {}\nvar Null = make(Default)\nvar Undefined = make(Default)\n// Implementation for built-in types are stored in the hash, this avoids\n// mutations on built-ins and allows cross frame extensions. Primitive types\n// are predefined so that `Object` extensions won't be inherited.\nvar Builtins = {\n  Object: make(Default),\n  Number: make(Default),\n  String: make(Default),\n  Boolean: make(Default)\n}\n// Define aliases for predefined built-in maps to a forms that values will\n// be serialized on dispatch.\nBuiltins[typefy.call(Object.prototype)] = Builtins.Object\nBuiltins[typefy.call(Number.prototype)] = Builtins.Number\nBuiltins[typefy.call(String.prototype)] = Builtins.String\n\n\n\nvar implement = Method(\nfunction implement(method, object, lambda) {\n  /**\n  Implements `Method` for the given `object` with a provided `implementation`.\n  Calling `Method` with `object` as a first argument will dispatch on provided\n  implementation.\n  **/\n  var target = object === null ? Null :\n               object === undefined ? Undefined :\n               object\n\n  return defineProperty(target, method.toString(), {\n    enumerable: false,\n    configurable: false,\n    writable: false,\n    value: lambda\n  })\n})\n\nvar define = Method(function define(method, Type, lambda) {\n  /**\n  Defines `Method` for the given `Type` with a provided `implementation`.\n  Calling `Method` with a first argument of this `Type` will dispatch on\n  provided `implementation`. If `Type` is a `Method` default implementation\n  is defined. If `Type` is a `null` or `undefined` `Method` is implemented\n  for that value type.\n  **/\n  if (!lambda) return implement(method, Default, Type)\n  if (!Type) return implement(method, Type, lambda)\n  var type = typefy.call(Type.prototype)\n  return type !== \"[object Object]\" ? implement(method,\n      Builtins[type] || (Builtins[type] = make(Builtins.Object)), lambda) :\n    // This should be `Type === Object` but since it will be `false` for\n    // `Object` from different JS context / compartment / frame we assume that\n    // if it's name is `Object` it is Object.\n    Type.name === \"Object\" ? implement(method, Builtins.Object, lambda) :\n    implement(method, Type.prototype, lambda)\n})\n\nvar defineMethod = function defineMethod(Type, lambda) {\n  return define(this, Type, lambda)\n}\nvar implementMethod = function implementMethod(object, lambda) {\n  return implement(this, object, lambda)\n}\n\n\n// Define exports on `Method` as it's only thing we export.\nMethod.implement = implement\nMethod.define = define\nMethod.Method = Method\nMethod.Null = Null\nMethod.Undefined = Undefined\nMethod.Default = Default\nMethod.Builtins = Builtins\n\nmodule.exports = Method\n\n//@ sourceURL=/node_modules/reducers/node_modules/method/core.js"
));

require.define("/node_modules/reducers/end.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar Box = require(\"./box\")\n\n// Exported function can be used for boxing values. This boxing is used by\n// `accumulate` function to message end of the sequence.\nmodule.exports = Box(\"End of the sequence\")\n\n//@ sourceURL=/node_modules/reducers/end.js"
));

require.define("/node_modules/reducers/box.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nmodule.exports = function Box(description) {\n  /**\n  Create a \"boxed\" value.\n  Boxed values may be used as flags to signify a mode or value.\n  This is similar to the way some languages use magic constants to trigger\n  a specific behavior or mode.\n\n  Boxed values may have a description that explains how they are to be used.\n  \n  Returns a box object.\n  **/\n  description = description || \"Boxed value\"\n  return function box(value) {\n    return {\n      isBoxed: true,\n      is: box,\n      value: value,\n      description: description\n    }\n  }\n}\n\n//@ sourceURL=/node_modules/reducers/box.js"
));

require.define("/node_modules/reducers/accumulated.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar Box = require(\"./box\")\n\n// Exported function can be used for boxing values. This boxing indicates\n// that consumer of sequence has finished consuming it, there for new values\n// should not be no longer pushed.\nvar accumulated = Box(\"Indicator that source has being accumulateed\")\n\nmodule.exports = accumulated\n\n//@ sourceURL=/node_modules/reducers/accumulated.js"
));

require.define("/node_modules/reducers/node_modules/eventual/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/reducers/node_modules/eventual/package.json"
));

require.define("/node_modules/reducers/node_modules/eventual/type.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar watchers = require(\"watchables/watchers\")\nvar watch = require(\"watchables/watch\")\nvar await = require(\"pending/await\")\nvar isPending = require(\"pending/is\")\nvar deliver = require(\"./deliver\")\nvar when = require(\"./when\")\n\n// Internal utility function returns true if given value is of error type,\n// otherwise returns false.\nvar isError = (function() {\n  var stringy = Object.prototype.toString\n  var error = stringy.call(Error.prototype)\n  return function isError(value) {\n    return stringy.call(value) === error\n  }\n})()\n\n// Internal utility, identity function. Returns whatever is given to it.\nfunction identity(value) { return value }\n\n// Internal utility, decorator function that wraps given function into\n// try / catch and returns thrown exception in case when exception is\n// thrown.\nfunction attempt(f) {\n  return function effort(value) {\n    try { return f(value) }\n    catch (error) { return error }\n  }\n}\n\n\n// Define property names used by an `Eventual` type. Names are prefixed via\n// `module.id` to avoid name conflicts.\nvar observers = \"observers@\" + module.id\nvar result = \"value@\" + module.id\nvar pending = \"pending@\" + module.id\n\n\nfunction Eventual() {\n  /**\n  Data type representing eventual value, that can be observed and delivered.\n  Type implements `watchable`, `pending` and `eventual` abstractions, where\n  first two are defined in an external libraries.\n  **/\n  this[observers] = []\n  this[result] = this\n  this[pending] = true\n}\n// Expose property names via type static properties so that it's easier\n// to refer to them while debugging.\nEventual.observers = observers\nEventual.result = result\nEventual.pending = pending\n\nwatchers.define(Eventual, function(value) {\n  return value[observers]\n})\n// Eventual values considered to be pending until the are deliver by calling\n// `deliver`. Internal `pending` property is used to identify weather value\n// is being watched or not.\nisPending.define(Eventual, function(value) {\n  return value[pending]\n})\n// Eventual type implements await function of pending abstraction, to enable\n// observation of value delivery.\nawait.define(Eventual, function(value, observer) {\n  if (isPending(value)) watch(value, observer)\n  else observer(value[result])\n})\n\n// Eventual implements `deliver` function of pending abstraction, to enable\n// fulfillment of eventual values. Eventual value can be delivered only once,\n// which will transition it from pending state to non-pending state. All\n// further deliveries are ignored. It's also guaranteed that all the registered\n// observers will be invoked in FIFO order.\ndeliver.define(Eventual, function(value, data) {\n  // Ignore delivery if value is no longer pending, or if it's in a process of\n  // delivery (in this case eventual[result] is set to value other than\n  // eventual itself). Also ignore if data deliver is value itself.\n  if (value !== data && isPending(value) && value[result] === value) {\n    var count = 0\n    var index = 0\n    var delivering = true\n    var observers = void(0)\n    // Set eventual value result to passed data value that also marks value\n    // as delivery in progress. This way all the `deliver` calls is side\n    // effect to this will be ignored. Note: value should still remain pending\n    // so that new observers could be registered instead of being called\n    // immediately, otherwise it breaks FIFO order.\n    value[result] = data\n    while (delivering) {\n      // If current batch of observers is exhausted, splice a new batch\n      // and continue delivery. New batch is created only if new observers\n      // are registered in side effect to this call of deliver.\n      if (index === count) {\n        observers = watchers(value).splice(0)\n        count = observers.length\n        index = 0\n        // If new observers have not being registered mark value as no longer\n        // pending and finish delivering.\n        if (count === index) {\n          value[pending] = false\n          delivering = false\n        }\n      }\n      // Register await handlers on given result, is it may be eventual /\n      // pending itself. Delivering eventual will cause delivery of the\n      // delivered eventual's delivery value, whenever that would be.\n      else {\n        await(data, observers[index])\n        index = index + 1\n      }\n    }\n  }\n})\n\n// Eventual implements `when` polymorphic function that is part of it's own\n// abstraction. It takes `value` `onFulfill` & `onError` handlers. In return\n// when returns eventual value, that is delivered return value of the handler\n// that is invoked depending on the given values delivery. If deliver value\n// is of error type error handler is invoked. If value is delivered with other\n// non-pending value that is not of error type `onFulfill` handlers is invoked\n// with it. If pending value is delivered then it's value will be delivered\n// it's result whenever that would be. This will cause both value and error\n// propagation.\nwhen.define(Eventual, function(value, onRealize, onError) {\n  // Create eventual value for a return value.\n  var delivered = false\n  var eventual = void(0)\n  var result = void(0)\n  // Wrap handlers into attempt decorator function, so that in case of\n  // exception thrown error is returned causing error propagation. If handler\n  // is missing identity function is used instead to propagate value / error.\n  var realize = onRealize ? attempt(onRealize) : identity\n  var error = onError ? attempt(onError) : identity\n  // Wait for pending value to be delivered.\n  await(value, function onDeliver(data) {\n    // Once value is delivered invoke appropriate handler, and deliver it\n    // to a resulting eventual value.\n    result = isError(data) ? error(data)\n                           : realize(data)\n\n    // If outer function is already returned and has created eventual\n    // for it's result deliver it. Otherwise (if await called observer\n    // in same synchronously) mark result delivered.\n    if (eventual) deliver(eventual, result)\n    else delivered = true\n  })\n\n  // If result is delivered already return it, otherwise create eventual\n  // value for the result and return that.\n  return delivered ? result : (eventual = new Eventual())\n})\n\nmodule.exports = Eventual\n\n//@ sourceURL=/node_modules/reducers/node_modules/eventual/type.js"
));

require.define("/node_modules/reducers/node_modules/eventual/node_modules/watchables/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/reducers/node_modules/eventual/node_modules/watchables/package.json"
));

require.define("/node_modules/reducers/node_modules/eventual/node_modules/watchables/watchers.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*jshint asi: true undef: true es5: true node: true devel: true\n         globalstrict: true forin: true latedef: false supernew: true */\n/*global define: true */\n\n\"use strict\";\n\nvar Method = require('method')\n\n// Method is supposed to return array of watchers for the given\n// value.\nmodule.exports = Method()\n\n//@ sourceURL=/node_modules/reducers/node_modules/eventual/node_modules/watchables/watchers.js"
));

require.define("/node_modules/reducers/node_modules/eventual/node_modules/watchables/watch.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*jshint asi: true undef: true es5: true node: true devel: true\n         globalstrict: true forin: true latedef: false supernew: true */\n/*global define: true */\n\n\"use strict\";\n\nvar Method = require('method')\nvar watchers = require('./watchers')\n\nmodule.exports = Method(function(value, watcher) {\n  // Registers a `value` `watcher`, unless it's already registered.\n  var registered = watchers(value)\n  if (registered && registered.indexOf(watcher) < 0)\n    registered.push(watcher)\n  return value\n})\n\n//@ sourceURL=/node_modules/reducers/node_modules/eventual/node_modules/watchables/watch.js"
));

require.define("/node_modules/reducers/node_modules/eventual/node_modules/pending/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/reducers/node_modules/eventual/node_modules/pending/package.json"
));

require.define("/node_modules/reducers/node_modules/eventual/node_modules/pending/await.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*jshint asi: true undef: true es5: true node: true devel: true\n         globalstrict: true forin: true latedef: false supernew: true */\n/*global define: true */\n\n\"use strict\";\n\nvar Method = require('method')\n\n// Set's up a callback to be called once pending\n// value is realized. All object by default are realized.\nmodule.exports = Method(function(value, callback) {\n  callback(value)\n})\n\n//@ sourceURL=/node_modules/reducers/node_modules/eventual/node_modules/pending/await.js"
));

require.define("/node_modules/reducers/node_modules/eventual/node_modules/pending/is.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*jshint asi: true undef: true es5: true node: true devel: true\n         globalstrict: true forin: true latedef: false supernew: true */\n/*global define: true */\n\n\"use strict\";\n\nvar Method = require('method')\n\n// Returns `true` if given `value` is pending, otherwise returns\n// `false`. All types will return false unless type specific\n// implementation is provided to do it otherwise.\nmodule.exports = Method(function() {\n  return false\n})\n\n//@ sourceURL=/node_modules/reducers/node_modules/eventual/node_modules/pending/is.js"
));

require.define("/node_modules/reducers/node_modules/eventual/deliver.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\n// Anyone crating an eventual will likely need to realize it, requiring\n// dependency on other package is complicated, not to mention that one\n// can easily wind up with several copies that does not necessary play\n// well with each other. Exposing this solves the issues.\nmodule.exports = require(\"pending/deliver\")\n\n//@ sourceURL=/node_modules/reducers/node_modules/eventual/deliver.js"
));

require.define("/node_modules/reducers/node_modules/eventual/node_modules/pending/deliver.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*jshint asi: true undef: true es5: true node: true devel: true\n         globalstrict: true forin: true latedef: false supernew: true */\n/*global define: true */\n\n\"use strict\";\n\nvar Method = require('method')\n// Method delivers pending value.\nmodule.exports = Method()\n\n//@ sourceURL=/node_modules/reducers/node_modules/eventual/node_modules/pending/deliver.js"
));

require.define("/node_modules/reducers/node_modules/eventual/when.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar Method = require(\"method\")\nvar when = Method(function(value, onRealize) {\n  return typeof(onRealize) === \"function\" ? onRealize(value) : value\n})\nwhen.define(Error, function(error, onRealize, onError) {\n  return typeof(onError) === \"function\" ? onError(error) : error\n})\n\nmodule.exports = when\n\n//@ sourceURL=/node_modules/reducers/node_modules/eventual/when.js"
));

require.define("/node_modules/reducers/error.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar Box = require(\"./box\")\n\n// Exported function can be used for boxing values. This boxing can be used\n// to identify errors.\nmodule.exports = Box(\"Error in the sequence\")\n\n//@ sourceURL=/node_modules/reducers/error.js"
));

require.define("/node_modules/reducers/convert.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar accumulate = require(\"./accumulate\")\nvar make = Object.create || (function() {\n  function Type() {}\n  return function make(prototype) {\n    Type.prototype = prototype\n    return new Type()\n  }\n})()\n\n\nfunction convert(source, method) {\n  /**\n  Function takes `source` sequence and returns new `sequence` such\n  that calling `accumulate` on it will delegate to given `method`.\n  This is to make sequence conversions lazy.\n\n  // Code will produce sequence that is just like `source` but with\n  // each element being incremented.\n  function increment(source) {\n    return convert(source, function(sequence, f, start) {\n      return accumulate(source, function(value, result) {\n        return f(value + 1, result)\n      }, start)\n    })\n  }\n  into(increment([ 1, 2, 3 ])) => [ 2, 3, 4 ]\n  **/\n  var base = typeof(source) === \"object\" ? make(source) : {}\n  return accumulate.implement(base, method)\n}\n\nmodule.exports = convert\n\n//@ sourceURL=/node_modules/reducers/convert.js"
));

require.define("/node_modules/reducers/signal.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar Method = require(\"method\")\nvar accumulate = require(\"./accumulate\")\nvar end = require(\"./end\")\nvar accumulated = require(\"./accumulated\")\nvar emit = require(\"./emit\")\nvar close = require(\"./close\")\n\nvar accumulator = \"accumulator@\" + module.id\nvar state = \"state@\" + module.id\nvar closed = \"closed@\" + module.id\n\n// Define a `Signal` data-type. A signal is a sequence of \"events over time\".\n// \n// Signals are a building block for creating Reactive event-driven programs.\n// \n// If you're familiar with libraries like Node EventEmitter, you might have\n// an easy time thinking of Signal as a single event channel. The key difference\n// is that signal represents events-over-time as a reducible value. This means\n// the events-over-time can be transformed, filtered forked and joined just like\n// an array.\nfunction Signal() {}\n\n// Signals can be either open or closed. An open signal may `emit` new values.\n// A signal that is not open may not emit.\n// \n// Define helper that allow you to test the state of a signal.\nfunction isClosed(signal) {\n  return !!signal[closed]\n}\nfunction isOpen(signal) {\n  return !!signal[accumulator]\n}\n\n// Implement accumulate protocol on signals, making them reducible.\naccumulate.define(Signal, function(signal, next, initial) {\n  // Signals may only be reduced by one consumer function.\n  // Other data types built on top of signal may allow for more consumers.\n  if (isOpen(signal)) throw Error(\"Signal is being consumed\")\n  if (isClosed(signal)) return next(end(), initial)\n  signal[accumulator] = next\n  signal[state] = initial\n  return signal\n})\n\nemit.define(Signal, function(signal, value) {\n  /**\n  Emit a new value for signal.\n  Throws an exception if the signal is not open for emitting.\n  **/\n  if (isClosed(signal)) throw Error(\"Signal is already closed\")\n  if (!isOpen(signal)) throw Error(\"Signal is not open\")\n  var result = signal[accumulator](value, signal[state])\n  if (result && result.is === accumulated) {\n    close(signal)\n  } else {\n    signal[state] = result\n  }\n  return signal\n})\n\nclose.define(Signal, function(signal, value) {\n  /**\n  Close a signal, preventing new values from being emitted.\n  Throws an exception if the signal is already closed.\n  **/\n  if (isClosed(signal)) throw Error(\"Signal is already closed\")\n  if (value !== undefined) emit(signal, value)\n  var result = signal[state]\n  var next = signal[accumulator]\n  signal[closed] = true\n  signal[accumulator] = null\n  signal[state] = null\n  next(end(), result)\n\n  return signal\n})\n\n// Define a factory function for the `Signal` constructor.\n// Assign other signal functions to the factory function object and export\n// the result.\nfunction signal() { return new Signal() }\nsignal.type = Signal\nsignal.isOpen = isOpen\nsignal.isClosed = isClosed\nsignal.emit = emit\nsignal.close = close\n\nmodule.exports = signal\n\n//@ sourceURL=/node_modules/reducers/signal.js"
));

require.define("/node_modules/reducers/emit.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar Method = require(\"method\")\n\nvar emit = Method()\n\nmodule.exports = emit\n\n//@ sourceURL=/node_modules/reducers/emit.js"
));

require.define("/node_modules/reducers/close.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar Method = require(\"method\")\n\n\nvar close = Method()\nmodule.exports = close\n\n//@ sourceURL=/node_modules/reducers/close.js"
));

require.define("/lib/pipe.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var reduce = require(\"reducers/reduce\")\nvar emit = require(\"reducers/emit\")\n\nmodule.exports = pipe\n\nfunction pipe(input, output) {\n    reduce(input, function(_, x) {\n        emit(output, x)\n    })\n}\n\n//@ sourceURL=/lib/pipe.js"
));

require.define("/node_modules/reducers/reduce.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar deliver = require(\"eventual/deliver\")\nvar defer = require(\"eventual/defer\")\nvar when = require(\"eventual/when\")\nvar accumulate = require(\"./accumulate\")\nvar end = require(\"./end\")\nvar error = require(\"./error\")\n\nfunction reduce(source, f, state) {\n  var promise = defer()\n  accumulate(source, function(value) {\n    if (value && value.isBoxed) {\n      if (value.is === end) deliver(promise, state)\n      if (value.is === error) deliver(promise, value.value)\n      return value\n    } else {\n      state = f(state, value)\n      return state\n    }\n  }, state)\n  return when(promise)\n}\n\nmodule.exports = reduce\n\n//@ sourceURL=/node_modules/reducers/reduce.js"
));

require.define("/node_modules/reducers/node_modules/eventual/defer.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar Eventual = require(\"./type\")\nmodule.exports = function defer() { return new Eventual() }\n\n//@ sourceURL=/node_modules/reducers/node_modules/eventual/defer.js"
));

require.define("/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index\"}\n//@ sourceURL=/package.json"
));

require.define("/persist.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Store = require(\"local-store\")\n    , reductions = require(\"reducers/reductions\")\n    , patch = require(\"diffpatcher/patch\")\n    , compound = require(\"compound\")\n\n    , state = require(\"./reflex/state\")\n    , Writer = require(\"./reflex/writer\")\n\n/*\n    The persistance is a composition of a\n\n        - fork (fork the changes into states)\n        - writer. Open the store & write to it for each new\n            state\n        - reader. Return the initial state\n*/\nmodule.exports = (compound)\n    (states)\n    (Writer(swap, open))\n    (read)\n\nfunction read(store) {\n    return store.get(\"state\")\n}\n\nfunction swap(store, current) {\n    delete current.operation\n    // console.log(\"persisting\", current)\n    store.set(\"state\", current)\n}\n\nfunction open() {\n    return Store(\"reflex-todo\")\n}\n\nfunction states(changes) {\n    return reductions(changes, patch, state())\n}\n\n//@ sourceURL=/persist.js"
));

require.define("/node_modules/local-store/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index\"}\n//@ sourceURL=/node_modules/local-store/package.json"
));

require.define("/node_modules/local-store/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var LocalStorage = typeof window !== \"undefined\" && window.localStorage\n    , prefixes = {}\n    , store\n\nif (LocalStorage) {\n    store = createLocalStore\n} else {\n    store = createMemoryStore\n}\n\nstore.createMemoryStore = createMemoryStore\nstore.createLocalStore = createLocalStore\n\nmodule.exports = store\n\nfunction createLocalStore(prefix) {\n    prefix = prefix || \"\"\n\n    return {\n        set: storeSet\n        , get: storeGet\n        , delete: storeDelete\n    }\n\n    function storeSet(key, value) {\n        LocalStorage.setItem(prefix + \".\" + key, JSON.stringify(value))\n    }\n\n    function storeGet(key) {\n        var str = LocalStorage.getItem(prefix + \".\" + key)\n        if (str === null) {\n            return null\n        }\n        return JSON.parse(str)\n    }\n\n    function storeDelete(key) {\n        return LocalStorage.removeItem(prefix + \".\" + key)\n    }\n}\n\nfunction createMemoryStore(prefix) {\n    var store = {}\n    if (prefix) {\n        store = prefixes[prefix]\n\n        if (!store) {\n            store = prefixes[prefix] = {}\n        }\n    }\n\n    return {\n        set: storeSet\n        , get: storeGet\n        , delete: storeDelete\n    }\n\n    function storeSet(key, value) {\n        store[key] = value\n    }\n\n    function storeGet(key) {\n        if (!(key in store)) {\n            return null\n        }\n\n        return store[key]\n    }\n\n    function storeDelete(key) {\n        return delete store[key]\n    }\n}\n//@ sourceURL=/node_modules/local-store/index.js"
));

require.define("/node_modules/reducers/reductions.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar convert = require(\"./convert\")\nvar accumulate = require(\"./accumulate\")\n\nfunction reductions(source, f, initial) {\n  /**\n  Returns `reducible` collection of the intermediate values of the reduction\n  (as per reduce) of `source` by `f`, starting with `initial` value.\n\n  ## Example\n\n  var numbers = reductions([1, 1, 1, 1], function(accumulated, value) {\n    return accumulated + value\n  }, 0)\n  print(numbers) // => <stream 1 2 3 4 />\n  **/\n  return convert(source, function(self, next, result) {\n    var state = initial\n    accumulate(source, function(value, result) {\n      state = value && value.isBoxed ? next(value, result) : f(state, value)\n      return next(state, result)\n    }, result)\n  })\n}\n\nmodule.exports = reductions\n\n//@ sourceURL=/node_modules/reducers/reductions.js"
));

require.define("/node_modules/diffpatcher/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"./diffpatcher.js\"}\n//@ sourceURL=/node_modules/diffpatcher/package.json"
));

require.define("/node_modules/diffpatcher/patch.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/* vim:set ts=2 sw=2 sts=2 expandtab */\n/*jshint asi: true undef: true es5: true node: true browser: true devel: true\n         forin: true latedef: false globalstrict: true*/\n\n\"use strict\";\n\nvar method = require(\"method\")\nvar rebase = require(\"./rebase\")\n\n// Method is designed to work with data structures representing application\n// state. Calling it with a state and delta should return object representing\n// new state, with changes in `delta` being applied to previous.\n//\n// ## Example\n//\n// patch(state, {\n//   \"item-id-1\": { completed: false }, // update\n//   \"item-id-2\": null                  // delete\n// })\nvar patch = method()\npatch.define(Object, function patch(hash, delta) {\n  return rebase({}, hash, delta)\n})\n\nmodule.exports = patch\n\n//@ sourceURL=/node_modules/diffpatcher/patch.js"
));

require.define("/node_modules/diffpatcher/node_modules/method/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"./core.js\"}\n//@ sourceURL=/node_modules/diffpatcher/node_modules/method/package.json"
));

require.define("/node_modules/diffpatcher/node_modules/method/core.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/* vim:set ts=2 sw=2 sts=2 expandtab */\n/*jshint asi: true undef: true es5: true node: true browser: true devel: true\n         forin: true latedef: false globalstrict: true */\n'use strict';\n\n// Shortcuts for ES5 reflection functions.\nvar make = Object.create || (function() {\n  var Type = function Type() {}\n  return function make(prototype) {\n    Type.prototype = prototype\n    return new Type()\n  }\n})\nvar defineProperty = Object.defineProperty || function(object, name, property) {\n  object[name] = property.value\n  return object\n}\nvar typefy = Object.prototype.toString\n\nfunction Method(base) {\n  /**\n  Private Method is a callable private name that dispatches on the first\n  arguments same named Method: Method(...rest) => rest[0][Method](...rest)\n  Default implementation may be passed in as an argument.\n  **/\n\n  // Create an internal unique name if default implementation is passed,\n  // use it's name as a name hint.\n  var name = (base && base.name || \"\") + Math.random().toString(32).substr(2)\n\n  function dispatch() {\n    // Method dispatches on type of the first argument.\n    var target = arguments[0]\n    var builtin = null\n    // If first argument is `null` or `undefined` use associated property\n    // maps for implementation lookups, otherwise attempt to use implementation\n    // for built-in falling back for implementation on the first argument.\n    // Finally use default implementation if no other one is found.\n    var method = target === null ? Null[name] :\n                 target === undefined ? Undefined[name] :\n                 target[name] ||\n                 ((builtin = Builtins[typefy.call(target)]) && builtin[name]) ||\n                 Builtins.Object[name] ||\n                 Default[name]\n\n    // If implementation not found there's not much we can do about it,\n    // throw error with a descriptive message.\n    if (!method) throw Error('Type does not implements method')\n\n    // If implementation is found delegate to it.\n    return method.apply(method, arguments)\n  }\n\n  // Define default implementation.\n  Default[name] = base\n\n  // Define `Method.toString` returning private name, this hack will enable\n  // Method definition like follows:\n  // var foo = Method()\n  // object[foo] = function() { /***/ }\n  dispatch.toString = function toString() { return name }\n\n  // Copy utility Methods for convenient API.\n  dispatch.implement = implementMethod\n  dispatch.define = defineMethod\n\n  return dispatch\n}\n\n// Define objects where Methods implementations for `null`, `undefined` and\n// defaults will be stored.\nvar Default = {}\nvar Null = make(Default)\nvar Undefined = make(Default)\n// Implementation for built-in types are stored in the hash, this avoids\n// mutations on built-ins and allows cross frame extensions. Primitive types\n// are predefined so that `Object` extensions won't be inherited.\nvar Builtins = {\n  Object: make(Default),\n  Number: make(Default),\n  String: make(Default),\n  Boolean: make(Default)\n}\n// Define aliases for predefined built-in maps to a forms that values will\n// be serialized on dispatch.\nBuiltins[typefy.call(Object.prototype)] = Builtins.Object\nBuiltins[typefy.call(Number.prototype)] = Builtins.Number\nBuiltins[typefy.call(String.prototype)] = Builtins.String\n\n\n\nvar implement = Method(\nfunction implement(method, object, lambda) {\n  /**\n  Implements `Method` for the given `object` with a provided `implementation`.\n  Calling `Method` with `object` as a first argument will dispatch on provided\n  implementation.\n  **/\n  var target = object === null ? Null :\n               object === undefined ? Undefined :\n               object\n\n  return defineProperty(target, method.toString(), {\n    enumerable: false,\n    configurable: false,\n    writable: false,\n    value: lambda\n  })\n})\n\nvar define = Method(function define(method, Type, lambda) {\n  /**\n  Defines `Method` for the given `Type` with a provided `implementation`.\n  Calling `Method` with a first argument of this `Type` will dispatch on\n  provided `implementation`. If `Type` is a `Method` default implementation\n  is defined. If `Type` is a `null` or `undefined` `Method` is implemented\n  for that value type.\n  **/\n  if (!lambda) return implement(method, Default, Type)\n  if (!Type) return implement(method, Type, lambda)\n  var type = typefy.call(Type.prototype)\n  return type !== \"[object Object]\" ? implement(method,\n      Builtins[type] || (Builtins[type] = make(Builtins.Object)), lambda) :\n    // This should be `Type === Object` but since it will be `false` for\n    // `Object` from different JS context / compartment / frame we assume that\n    // if it's name is `Object` it is Object.\n    Type.name === \"Object\" ? implement(method, Builtins.Object, lambda) :\n    implement(method, Type.prototype, lambda)\n})\n\nvar defineMethod = function defineMethod(Type, lambda) {\n  return define(this, Type, lambda)\n}\nvar implementMethod = function implementMethod(object, lambda) {\n  return implement(this, object, lambda)\n}\n\n\n// Define exports on `Method` as it's only thing we export.\nMethod.implement = implement\nMethod.define = define\nMethod.Method = Method\nMethod.Null = Null\nMethod.Undefined = Undefined\nMethod.Default = Default\nMethod.Builtins = Builtins\n\nmodule.exports = Method\n\n//@ sourceURL=/node_modules/diffpatcher/node_modules/method/core.js"
));

require.define("/node_modules/diffpatcher/rebase.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/* vim:set ts=2 sw=2 sts=2 expandtab */\n/*jshint asi: true undef: true es5: true node: true browser: true devel: true\n         eqnull: true forin: true latedef: false globalstrict: true*/\n\n\"use strict\";\n\nfunction rebase(result, parent, delta) {\n  Object.keys(parent).forEach(function(key) {\n    // If `parent[key]` is `null` it means attribute was deleted in previous\n    // update. We skip such properties as there is no use in keeping them\n    // around. If `delta[key]` is `null` we skip these properties too as\n    // the have being deleted.\n    if (!(parent[key] == null || (key in delta && delta[key] == null)))\n      result[key] = parent[key]\n  }, result)\n  Object.keys(delta).forEach(function(key) {\n    if (key in parent) {\n      var current = delta[key]\n      var previous = parent[key]\n      if (current === previous) current = current\n      // If `delta[key]` is `null` it's delete so we just skip property.\n      else if (current == null) current = current\n      // If value is of primitive type (function or regexps should not\n      // even be here) we just update in place.\n      else if (typeof(current) !== \"object\") result[key] = current\n      // If previous value associated with this key was primitive\n      // and it's mapped to non primitive\n      else if (typeof(previous) !== \"object\") result[key] = current\n      else result[key] = rebase({}, previous, current)\n    } else {\n      result[key] = delta[key]\n    }\n  })\n  return result\n}\n\nmodule.exports = rebase\n\n//@ sourceURL=/node_modules/diffpatcher/rebase.js"
));

require.define("/node_modules/compound/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"./compound.js\"}\n//@ sourceURL=/node_modules/compound/package.json"
));

require.define("/node_modules/compound/compound.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/* vim:set ts=2 sw=2 sts=2 expandtab */\n/*jshint asi: true undef: true es5: true node: true browser: true devel: true\n         forin: true latedef: false globalstrict: true*/\n\n\"use strict\";\n\n// Utility function is used internally in order to ignore first argument\n// on data bound compound functions.\nfunction second(_, value) { return value }\n\nfunction compile(tasks) {\n  /**\n  Function takes set of tasks and compiles them into compound function, that\n  executes each task and passes result to the next one as a first argument.\n  **/\n  return function compute(result) {\n    /**\n    Computes result by running each task and passing it's result along\n    with curried arguments to a next one, until queue of tasks is exhausted.\n    accumulated result is returned back.\n    **/\n    var count = tasks.length\n    var index = 0\n\n    // compute result by accumulating result of intermediate state and\n    // passing it as first argument to a next task.\n    while (index < count) {\n      var lambda = tasks[index++]\n      var params = tasks[index++]\n      params[0] = result\n      result = lambda.apply(lambda, params)\n    }\n    return result\n  }\n}\n\nfunction compound(lambda) {\n  /**\n  Chains operations into compound function by queueing tasks and curring\n  provided arguments, until invoked with a non-function first argument. In\n  that case queued tasks are compiled to a compound function that can be\n  used to perform chained operations. Note that compilation will prevent\n  any further chaining, although compound results can be used in a different\n  compositions.\n  **/\n\n  // This is a placeholder for compiled compound function.\n  var composite = void(0)\n  // Tasks are queued into `tasks` array. Every odd element is a function\n  // followed by even element of curried arguments for it. If first argument\n  // is not a function, then we create compound function with bound initial\n  // value. Utility function `second` is used so that bound value will be\n  // returned regardless of the passed arguments to a compiled function.\n  var tasks = typeof(lambda) === \"function\" ? [lambda, arguments]\n                                            : [second, [second, lambda]]\n\n  return function chain(lambda/*, ...params*/) {\n    // If composite function has being compiled, execute it.\n    if (composite) {\n      return composite(lambda)\n    }\n    // If first argument is a function, then queue it into tasks.\n    else if (typeof(lambda) === \"function\") {\n      tasks.push(lambda, arguments)\n      return chain\n    }\n    // If first argument is not a function then compile tasks into function.\n    else {\n      composite = compile(tasks)\n      return composite(lambda)\n    }\n  }\n}\n\nmodule.exports = compound\n\n//@ sourceURL=/node_modules/compound/compound.js"
));

require.define("/reflex/state.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/* vim:set ts=2 sw=2 sts=2 expandtab */\n/*jshint asi: true undef: true es5: true node: true devel: true\n         forin: true latedef: false globalstrict: true*/\n/*global parent:true */\n\n\"use strict\";\n\nvar diff = require(\"diffpatcher/diff\")\nvar patch = require(\"diffpatcher/patch\")\nvar rebase = require(\"diffpatcher/rebase\")\nvar channel = require(\"reducers/channel\")\nvar timestamp = require(\"monotonic-timestamp\")\n\nvar make = Object.create || (function() {\n    function Type() {}\n    return function make(prototype) {\n        Type.prototype = prototype\n        return new Type()\n    }\n})()\n\n// Generated unique name is used to store `delta` on the state object\n// which is object containing changes from previous state to current.\nvar delta = \"delta@\" + module.id\nvar id = \"uuid@\" + module.id\nvar parent = \"parent@\" + module.id\n\n// State is a type used for representing application states. Primarily\n// reason to have a type is to have an ability implement polymorphic\n// methods for it.\nfunction State() {}\n\n// Returns diff that has being applied to a previous state to get to a\n// current one.\ndiff.define(State, function diff(from, to) {\n    // If state does not contains delta property then it's initial,\n    // so diff to get to the current state should be a diff itself.\n    if (to[parent] === from[id]) {\n        return to[delta]\n    }\n\n    return diff.calculate(from, to)\n})\n\n// Patches given `state` with a given `diff` creating a new state that is\n// returned back.\npatch.define(State, function patch(state, id, value) {\n    var diff = id\n    if (arguments.length === 3) {\n        diff = {}\n        diff[id] = value\n    }\n\n    var value = new State()\n    // Store `diff` is stored so that it can be retrieved without calculations.\n    value[delta] = diff\n    value[parent] = state[id]\n\n    return rebase(make(value), state, diff)\n})\n\n\nfunction state() {\n    /**\n    Creates an object representing a state snapshot.\n    **/\n    var value = new State()\n    value[id] = timestamp()\n    value[parent] = null\n    return make(value)\n}\nstate.type = State\nstate.delta = delta\n\nmodule.exports = state\n\n//@ sourceURL=/reflex/state.js"
));

require.define("/node_modules/diffpatcher/diff.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/* vim:set ts=2 sw=2 sts=2 expandtab */\n/*jshint asi: true undef: true es5: true node: true browser: true devel: true\n         eqnull: true forin: true latedef: false globalstrict: true*/\n\n\"use strict\";\n\nvar method = require(\"method\")\n\n// Method is designed to work with data structures representing application\n// state. Calling it with a state should return object representing `delta`\n// that has being applied to a previous state to get to a current state.\n//\n// Example\n//\n// diff(state) // => { \"item-id-1\": { title: \"some title\" } \"item-id-2\": null }\nvar diff = method()\n\n// diff between `null` / `undefined` to any hash is a hash itself.\ndiff.define(null, function(from, to) { return to })\ndiff.define(undefined, function(from, to) { return to })\ndiff.define(Object, function(from, to) {\n  return calculate(from, to || {}) || {}\n})\n\nfunction calculate(from, to) {\n  var diff = {}\n  var changes = 0\n  Object.keys(from).forEach(function(key) {\n    changes = changes + 1\n    if (!(key in to) && from[key] != null) diff[key] = null\n    else changes = changes - 1\n  })\n  Object.keys(to).forEach(function(key) {\n    changes = changes + 1\n    var previous = from[key]\n    var current = to[key]\n    if (previous === current) return (changes = changes - 1)\n    if (typeof(current) !== \"object\") return diff[key] = current\n    if (typeof(previous) !== \"object\") return diff[key] = current\n    var delta = calculate(previous, current)\n    if (delta) diff[key] = delta\n    else changes = changes - 1\n  })\n  return changes ? diff : null\n}\n\ndiff.calculate = calculate\n\nmodule.exports = diff\n\n//@ sourceURL=/node_modules/diffpatcher/diff.js"
));

require.define("/node_modules/monotonic-timestamp/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/monotonic-timestamp/package.json"
));

require.define("/node_modules/monotonic-timestamp/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var _last = 0\nvar _count = 1\n\nmodule.exports = \nfunction () {\n  var t = Date.now()\n  var _t = t\n  if(_last == t) {\n    _t += ((_count++)/1000) \n  } \n  else _count = 1 \n\n  _last = t\n\n  return _t\n}\n\n\n//@ sourceURL=/node_modules/monotonic-timestamp/index.js"
));

require.define("/reflex/writer.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var reduce = require(\"reducers/reduce\")\n\nmodule.exports = Writer\n\nfunction Writer(update, open, close) {\n    return function write(changes, options) {\n        var readable = open(options)\n\n        reduce(changes, function (_, change) {\n            if (change === null) {\n                close(readable, options)\n            } else {\n                update(readable, change)\n            }\n        })\n\n        return readable\n    }\n}\n\n//@ sourceURL=/reflex/writer.js"
));

require.define("/todo/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var partial = require(\"ap\").partial\n    , insert = require(\"insert\")\n    , append = insert.append\n    , map = require(\"reducers/map\")\n    , filter = require(\"reducers/filter\")\n    , flatten = require(\"reducers/flatten\")\n    , events = require(\"dom-reduce/event\")\n    , compound = require(\"compound\")\n    , uuid = require(\"node-uuid\")\n\n    , TodoItem = require(\"./item\")\n    , Unit = require(\"../reflex/unit\")\n    , html = require(\"../lib/html\")\n    , equal = require(\"../lib/equal\")\n    , method = require(\"../lib/method\")\n    , todoListHtml = require(\"./html/todoList\")\n\n    , ENTER = 13\n\nmodule.exports = TodoList\n\n/*\n    TodoList takes a parent function to pass the view onto\n        so the parent can handle the view.\n\n    TodoList is a Unit composed of\n        todo -> TodoItem.\n\n    For each todoItem created it's appended to component.list\n*/\nfunction TodoList(parent) {\n    return function reactor(changes) {\n        var component = html(todoListHtml)\n            , unit = Unit({\n                \"todo\": TodoItem(partial(append, component.list))\n            })\n\n        parent(component.root)\n\n        return flatten([unit(changes), read(component)])\n    }\n}\n\nfunction read(component) {\n    return compound\n        (filter, function (ev) {\n            return equal(\"keyCode\", ENTER)(ev)\n        })\n        (map, getFieldValue)\n        (filter, Boolean)\n        (map, method(\"trim\"))\n        (map, function (title) {\n            var changes = {}\n\n            changes[uuid()] = {\n                title: title\n                , complted: false\n            }\n\n            return {\n                todo: changes\n            }\n        })\n        (events(component.input, \"keypress\"))\n}\n\nfunction getFieldValue(event) {\n    var input = event.target\n        , value = input.value\n\n    input.value = \"\"\n\n    return value\n}\n\n//@ sourceURL=/todo/index.js"
));

require.define("/node_modules/reducers/map.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar transform = require(\"./transform\")\n\nfunction map(source, f) {\n  /**\n  Returns transformed version of given `source` where each item of it\n  is mapped using `f`.\n\n  ## Example\n\n  var data = [{ name: \"foo\" }, { name: \"bar\" }]\n  var names = map(data, function(value) { return value.name })\n  print(names) // => <stream \"foo\" \"bar\" />\n  **/\n  return transform(source, function(next, value, accumulated) {\n    return next(f(value), accumulated)\n  })\n}\n\nmodule.exports = map\n\n\n//@ sourceURL=/node_modules/reducers/map.js"
));

require.define("/node_modules/reducers/transform.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar convert = require(\"./convert\")\nvar accumulate = require(\"./accumulate\")\n\nfunction transform(source, f) {\n  /**\n  Function takes `source` sequence and an `f` function, which is used to\n  intercept each non-boxed item of the sequence. It is invoked with `next`\n  continuation function, sequence `value` being yielded and accumulated\n  `result`. `f` is supposed to call `next` with a intercepted `value` and\n  `result`.\n\n  This enables writing transformation functions that don't deal with\n  back-channel in form of boxed values. In other words transformation\n  functions like `filter` and `map` just intercept values but they don't\n  change size of sequence or handle errors there for they want to bypass\n  back-channel by using transform`.\n\n  For examples of use see `map`, `filter` etc... Some functions that want\n  to change size of sequence should use `transformer` instead, for examples\n  of those see `take`, `takeWhile`.\n  **/\n  return convert(source, function(self, next, initial) {\n    accumulate(source, function(value, result) {\n      return value && value.isBoxed ? next(value, result)\n                                    : f(next, value, result)\n    }, initial)\n  })\n}\n\nmodule.exports = transform\n\n//@ sourceURL=/node_modules/reducers/transform.js"
));

require.define("/node_modules/reducers/filter.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar transform = require(\"./transform\")\n\nfunction filter(source, predicate) {\n  /**\n  Composes filtered version of given `source`, such that only items contained\n  will be once on which `f(item)` was `true`.\n\n  ## Example\n\n  var digits = filter([ 10, 23, 2, 7, 17 ], function(value) {\n    return value >= 0 && value <= 9\n  })\n  print(digits) // => <stream 2 7 />\n  **/\n  return transform(source, function(next, value, accumulated) {\n    return predicate(value) ? next(value, accumulated) : accumulated\n  })\n}\n\nmodule.exports = filter\n\n//@ sourceURL=/node_modules/reducers/filter.js"
));

require.define("/node_modules/reducers/flatten.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar reduce = require(\"./reduce\")\nvar reducible = require(\"./reducible\")\nvar eventual = require(\"eventual/decorate\")\n\nvar group = eventual(Array)\n\nfunction flatten(source) {\n  /**\n  Flattens given sequence of sequences to a sequence with items of\n  all nested sequences. Note that items in the resulting sequence\n  are ordered by the time rather then index, in other words if\n  item from the second sub-sequence is deliver earlier then the item\n  from first sub-sequence it will in appear earlier in the resulting\n  sequence too. If you need to keep order by index you should enforce\n  sequential ordering by wrapping `source` into `sequential` before\n  passing it to flatten.\n\n  print(flatten([ [1, 2], [ 3, 4 ] ]))  // => <stream 1 2 3 4 />\n  **/\n  return reducible(source, function(_, next, initial) {\n    return reduce(source, function(result, nested) {\n      // we group results to make sure flattened stream won't finish until\n      // all the streams are finished.\n      return group(result, reduce(nested, function(result, value) {\n        return next(result, value)\n      }, result))\n    }, initial)\n  })\n}\n\nmodule.exports = flatten\n\n//@ sourceURL=/node_modules/reducers/flatten.js"
));

require.define("/node_modules/reducers/reducible.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar convert = require(\"./convert\")\nvar when = require(\"eventual/when\")\nvar end = require(\"./end\")\nvar error = require(\"./error\")\n\nfunction reducible(source, f) {\n  return convert(source, function(source, next, initial) {\n    var result = f(source, function forward(result, value) {\n      return next(value, result)\n    }, initial)\n    when(result, function(value) {\n      next(end(), value)\n    }, function(e) {\n      next(error(e))\n    })\n  })\n}\n\nmodule.exports = reducible\n\n//@ sourceURL=/node_modules/reducers/reducible.js"
));

require.define("/node_modules/reducers/node_modules/eventual/decorate.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar apply = require(\"./apply\")\n\n// Define a shortcut for `Array.prototype.slice.call`.\nvar unbind = Function.call.bind(Function.bind, Function.call)\nvar slice = Array.slice || unbind(Array.prototype.slice)\n\n// Decorator function composes function which can take eventual values as\n// arguments, in which case it returns eventual result that is delivered\n// result of applying results of eventuals to a decorated `f`. If result is\n// delivered in sync delivery value is returned instead.\nmodule.exports = function eventual(f) {\n  return function eventually() {\n    return apply(f, slice(arguments))\n  }\n}\n\n//@ sourceURL=/node_modules/reducers/node_modules/eventual/decorate.js"
));

require.define("/node_modules/reducers/node_modules/eventual/apply.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar when = require(\"./when\")\nvar group = require(\"./group\")\n\n// Function can be use with eventual values, it treats each of it's arguments\n// as eventual value and returns a fresh one in return. Once all of the\n// arguments are delivered first one is invoked with rest and return value\n// is delivered to the resulting eventual. If everything happens synchronously\n// actual value is returned.\nmodule.exports = function invoke(f, params) {\n  var eventuals = params.slice(0)\n  eventuals.unshift(f)\n  return when(group(eventuals), function(values) {\n    var f = values.shift()\n    return f.apply(f, values)\n  })\n}\n\n//@ sourceURL=/node_modules/reducers/node_modules/eventual/apply.js"
));

require.define("/node_modules/reducers/node_modules/eventual/group.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar when = require(\"./when\")\nvar unbind = Function.call.bind(Function.bind, Function.call)\nvar slice = Array.slice || unbind(Array.prototype.slice)\n\n// Utility function takes array of eventual values and return single\n// eventual value that is delivered an array of delivery values for\n// those eventuals. If any of the eventuals is delivered error that\n// error is delivered instead.\nmodule.exports = function group(eventuals) {\n  return slice(eventuals).reduce(function(eventuals, eventual) {\n    return when(eventual, function(value) {\n      return when(eventuals, function(values) {\n        values.push(value)\n        return values\n      })\n    })\n  }, [])\n}\n\n//@ sourceURL=/node_modules/reducers/node_modules/eventual/group.js"
));

require.define("/node_modules/dom-reduce/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/dom-reduce/package.json"
));

require.define("/node_modules/dom-reduce/event.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/* vim:set ts=2 sw=2 sts=2 expandtab */\n/*jshint asi: true undef: true es5: true node: true browser: true devel: true\n         forin: true latedef: false globalstrict: true */\n\n\"use strict\";\n\nvar channel = require(\"reducers/channel\")\nvar emit = require(\"reducers/emit\")\nvar convert = require(\"reducers/convert\")\nvar accumulated = require(\"reducers/accumulated\")\nvar end = require(\"reducers/end\")\n\nfunction open(target, type, options) {\n  /**\n  Capture events on a DOM element, converting them to a reducible channel.\n  Returns a reducible channel.\n\n  ## Example\n\n      var allClicks = open(document.documentElement, 'click')\n      var clicksOnMyTarget = filter(allClicks, function (click) {\n        return click.target === myTarget\n      })\n  **/\n  var capture = options && options.capture || false\n  return convert({}, function(self, next, state) {\n    function handler(event) {\n      state = next(event, state)\n      //  When channel is marked as accumulated, remove event listener.\n      if (state && state.is === accumulated) {\n        if (target.removeEventListener)\n          target.removeEventListener(type, handler, capture)\n        else\n          target.detachEvent(type, handler, capture)\n        next(end(), state.value)\n      }\n    }\n    if (target.addEventListener) target.addEventListener(type, handler, capture)\n    else target.attachEvent(\"on\" + type, handler)\n  })\n}\n\nmodule.exports = open\n\n//@ sourceURL=/node_modules/dom-reduce/event.js"
));

require.define("/node_modules/node-uuid/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"./uuid.js\"}\n//@ sourceURL=/node_modules/node-uuid/package.json"
));

require.define("/node_modules/node-uuid/uuid.js",Function(['require','module','exports','__dirname','__filename','process','global'],"//     uuid.js\n//\n//     (c) 2010-2012 Robert Kieffer\n//     MIT License\n//     https://github.com/broofa/node-uuid\n(function() {\n  var _global = this;\n\n  // Unique ID creation requires a high quality random # generator.  We feature\n  // detect to determine the best RNG source, normalizing to a function that\n  // returns 128-bits of randomness, since that's what's usually required\n  var _rng;\n\n  // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html\n  //\n  // Moderately fast, high quality\n  if (typeof(require) == 'function') {\n    try {\n      var _rb = require('crypto').randomBytes;\n      _rng = _rb && function() {return _rb(16);};\n    } catch(e) {}\n  }\n\n  if (!_rng && _global.crypto && crypto.getRandomValues) {\n    // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto\n    //\n    // Moderately fast, high quality\n    var _rnds8 = new Uint8Array(16);\n    _rng = function whatwgRNG() {\n      crypto.getRandomValues(_rnds8);\n      return _rnds8;\n    };\n  }\n\n  if (!_rng) {\n    // Math.random()-based (RNG)\n    //\n    // If all else fails, use Math.random().  It's fast, but is of unspecified\n    // quality.\n    var  _rnds = new Array(16);\n    _rng = function() {\n      for (var i = 0, r; i < 16; i++) {\n        if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n        _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n      }\n\n      return _rnds;\n    };\n  }\n\n  // Buffer class to use\n  var BufferClass = typeof(Buffer) == 'function' ? Buffer : Array;\n\n  // Maps for number <-> hex string conversion\n  var _byteToHex = [];\n  var _hexToByte = {};\n  for (var i = 0; i < 256; i++) {\n    _byteToHex[i] = (i + 0x100).toString(16).substr(1);\n    _hexToByte[_byteToHex[i]] = i;\n  }\n\n  // **`parse()` - Parse a UUID into it's component bytes**\n  function parse(s, buf, offset) {\n    var i = (buf && offset) || 0, ii = 0;\n\n    buf = buf || [];\n    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {\n      if (ii < 16) { // Don't overflow!\n        buf[i + ii++] = _hexToByte[oct];\n      }\n    });\n\n    // Zero out remaining bytes if string was short\n    while (ii < 16) {\n      buf[i + ii++] = 0;\n    }\n\n    return buf;\n  }\n\n  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**\n  function unparse(buf, offset) {\n    var i = offset || 0, bth = _byteToHex;\n    return  bth[buf[i++]] + bth[buf[i++]] +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] +\n            bth[buf[i++]] + bth[buf[i++]] +\n            bth[buf[i++]] + bth[buf[i++]];\n  }\n\n  // **`v1()` - Generate time-based UUID**\n  //\n  // Inspired by https://github.com/LiosK/UUID.js\n  // and http://docs.python.org/library/uuid.html\n\n  // random #'s we need to init node and clockseq\n  var _seedBytes = _rng();\n\n  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n  var _nodeId = [\n    _seedBytes[0] | 0x01,\n    _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]\n  ];\n\n  // Per 4.2.2, randomize (14 bit) clockseq\n  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;\n\n  // Previous uuid creation time\n  var _lastMSecs = 0, _lastNSecs = 0;\n\n  // See https://github.com/broofa/node-uuid for API details\n  function v1(options, buf, offset) {\n    var i = buf && offset || 0;\n    var b = buf || [];\n\n    options = options || {};\n\n    var clockseq = options.clockseq != null ? options.clockseq : _clockseq;\n\n    // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n    var msecs = options.msecs != null ? options.msecs : new Date().getTime();\n\n    // Per 4.2.1.2, use count of uuid's generated during the current clock\n    // cycle to simulate higher resolution clock\n    var nsecs = options.nsecs != null ? options.nsecs : _lastNSecs + 1;\n\n    // Time since last uuid creation (in msecs)\n    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n    // Per 4.2.1.2, Bump clockseq on clock regression\n    if (dt < 0 && options.clockseq == null) {\n      clockseq = clockseq + 1 & 0x3fff;\n    }\n\n    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n    // time interval\n    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {\n      nsecs = 0;\n    }\n\n    // Per 4.2.1.2 Throw error if too many uuids are requested\n    if (nsecs >= 10000) {\n      throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n    }\n\n    _lastMSecs = msecs;\n    _lastNSecs = nsecs;\n    _clockseq = clockseq;\n\n    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n    msecs += 12219292800000;\n\n    // `time_low`\n    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n    b[i++] = tl >>> 24 & 0xff;\n    b[i++] = tl >>> 16 & 0xff;\n    b[i++] = tl >>> 8 & 0xff;\n    b[i++] = tl & 0xff;\n\n    // `time_mid`\n    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n    b[i++] = tmh >>> 8 & 0xff;\n    b[i++] = tmh & 0xff;\n\n    // `time_high_and_version`\n    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n    b[i++] = tmh >>> 16 & 0xff;\n\n    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n    b[i++] = clockseq >>> 8 | 0x80;\n\n    // `clock_seq_low`\n    b[i++] = clockseq & 0xff;\n\n    // `node`\n    var node = options.node || _nodeId;\n    for (var n = 0; n < 6; n++) {\n      b[i + n] = node[n];\n    }\n\n    return buf ? buf : unparse(b);\n  }\n\n  // **`v4()` - Generate random UUID**\n\n  // See https://github.com/broofa/node-uuid for API details\n  function v4(options, buf, offset) {\n    // Deprecated - 'format' argument, as supported in v1.2\n    var i = buf && offset || 0;\n\n    if (typeof(options) == 'string') {\n      buf = options == 'binary' ? new BufferClass(16) : null;\n      options = null;\n    }\n    options = options || {};\n\n    var rnds = options.random || (options.rng || _rng)();\n\n    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n    // Copy bytes to buffer, if provided\n    if (buf) {\n      for (var ii = 0; ii < 16; ii++) {\n        buf[i + ii] = rnds[ii];\n      }\n    }\n\n    return buf || unparse(rnds);\n  }\n\n  // Export public API\n  var uuid = v4;\n  uuid.v1 = v1;\n  uuid.v4 = v4;\n  uuid.parse = parse;\n  uuid.unparse = unparse;\n  uuid.BufferClass = BufferClass;\n\n  if (_global.define && define.amd) {\n    // Publish as AMD module\n    define(function() {return uuid;});\n  } else if (typeof(module) != 'undefined' && module.exports) {\n    // Publish as node.js module\n    module.exports = uuid;\n  } else {\n    // Publish as global (in browsers)\n    var _previousRoot = _global.uuid;\n\n    // **`noConflict()` - (browser only) to reset global 'uuid' var**\n    uuid.noConflict = function() {\n      _global.uuid = _previousRoot;\n      return uuid;\n    };\n\n    _global.uuid = uuid;\n  }\n}());\n\n//@ sourceURL=/node_modules/node-uuid/uuid.js"
));

require.define("crypto",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = require(\"crypto-browserify\")\n//@ sourceURL=crypto"
));

require.define("/node_modules/crypto-browserify/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/crypto-browserify/package.json"
));

require.define("/node_modules/crypto-browserify/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var sha = require('./sha')\nvar rng = require('./rng')\n\nvar algorithms = {\n  sha1: {\n    hex: sha.hex_sha1,\n    binary: sha.b64_sha1,\n    ascii: sha.str_sha1\n  }\n}\n\nfunction error () {\n  var m = [].slice.call(arguments).join(' ')\n  throw new Error([\n    m,\n    'we accept pull requests',\n    'http://github.com/dominictarr/crypto-browserify'\n    ].join('\\n'))\n}\n\nexports.createHash = function (alg) {\n  alg = alg || 'sha1'\n  if(!algorithms[alg])\n    error('algorithm:', alg, 'is not yet supported')\n  var s = ''\n  var _alg = algorithms[alg]\n  return {\n    update: function (data) {\n      s += data\n      return this\n    },\n    digest: function (enc) {\n      enc = enc || 'binary'\n      var fn\n      if(!(fn = _alg[enc]))\n        error('encoding:', enc , 'is not yet supported for algorithm', alg)\n      var r = fn(s)\n      s = null //not meant to use the hash after you've called digest.\n      return r\n    }\n  }\n}\n\nexports.randomBytes = function(size, callback) {\n  if (callback && callback.call) {\n    try {\n      callback.call(this, undefined, rng(size));\n    } catch (err) { callback(err); }\n  } else {\n    return rng(size);\n  }\n}\n\n// the least I can do is make error messages for the rest of the node.js/crypto api.\n;['createCredentials'\n, 'createHmac'\n, 'createCypher'\n, 'createCypheriv'\n, 'createDecipher'\n, 'createDecipheriv'\n, 'createSign'\n, 'createVerify'\n, 'createDeffieHellman'\n, 'pbkdf2'].forEach(function (name) {\n  exports[name] = function () {\n    error('sorry,', name, 'is not implemented yet')\n  }\n})\n\n//@ sourceURL=/node_modules/crypto-browserify/index.js"
));

require.define("/node_modules/crypto-browserify/sha.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined\n * in FIPS PUB 180-1\n * Version 2.1a Copyright Paul Johnston 2000 - 2002.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for details.\n */\n\nexports.hex_sha1 = hex_sha1;\nexports.b64_sha1 = b64_sha1;\nexports.str_sha1 = str_sha1;\nexports.hex_hmac_sha1 = hex_hmac_sha1;\nexports.b64_hmac_sha1 = b64_hmac_sha1;\nexports.str_hmac_sha1 = str_hmac_sha1;\n\n/*\n * Configurable variables. You may need to tweak these to be compatible with\n * the server-side, but the defaults work in most cases.\n */\nvar hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */\nvar b64pad  = \"\"; /* base-64 pad character. \"=\" for strict RFC compliance   */\nvar chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */\n\n/*\n * These are the functions you'll usually want to call\n * They take string arguments and return either hex or base-64 encoded strings\n */\nfunction hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));}\nfunction b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));}\nfunction str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));}\nfunction hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));}\nfunction b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));}\nfunction str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}\n\n/*\n * Perform a simple self-test to see if the VM is working\n */\nfunction sha1_vm_test()\n{\n  return hex_sha1(\"abc\") == \"a9993e364706816aba3e25717850c26c9cd0d89d\";\n}\n\n/*\n * Calculate the SHA-1 of an array of big-endian words, and a bit length\n */\nfunction core_sha1(x, len)\n{\n  /* append padding */\n  x[len >> 5] |= 0x80 << (24 - len % 32);\n  x[((len + 64 >> 9) << 4) + 15] = len;\n\n  var w = Array(80);\n  var a =  1732584193;\n  var b = -271733879;\n  var c = -1732584194;\n  var d =  271733878;\n  var e = -1009589776;\n\n  for(var i = 0; i < x.length; i += 16)\n  {\n    var olda = a;\n    var oldb = b;\n    var oldc = c;\n    var oldd = d;\n    var olde = e;\n\n    for(var j = 0; j < 80; j++)\n    {\n      if(j < 16) w[j] = x[i + j];\n      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);\n      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),\n                       safe_add(safe_add(e, w[j]), sha1_kt(j)));\n      e = d;\n      d = c;\n      c = rol(b, 30);\n      b = a;\n      a = t;\n    }\n\n    a = safe_add(a, olda);\n    b = safe_add(b, oldb);\n    c = safe_add(c, oldc);\n    d = safe_add(d, oldd);\n    e = safe_add(e, olde);\n  }\n  return Array(a, b, c, d, e);\n\n}\n\n/*\n * Perform the appropriate triplet combination function for the current\n * iteration\n */\nfunction sha1_ft(t, b, c, d)\n{\n  if(t < 20) return (b & c) | ((~b) & d);\n  if(t < 40) return b ^ c ^ d;\n  if(t < 60) return (b & c) | (b & d) | (c & d);\n  return b ^ c ^ d;\n}\n\n/*\n * Determine the appropriate additive constant for the current iteration\n */\nfunction sha1_kt(t)\n{\n  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :\n         (t < 60) ? -1894007588 : -899497514;\n}\n\n/*\n * Calculate the HMAC-SHA1 of a key and some data\n */\nfunction core_hmac_sha1(key, data)\n{\n  var bkey = str2binb(key);\n  if(bkey.length > 16) bkey = core_sha1(bkey, key.length * chrsz);\n\n  var ipad = Array(16), opad = Array(16);\n  for(var i = 0; i < 16; i++)\n  {\n    ipad[i] = bkey[i] ^ 0x36363636;\n    opad[i] = bkey[i] ^ 0x5C5C5C5C;\n  }\n\n  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);\n  return core_sha1(opad.concat(hash), 512 + 160);\n}\n\n/*\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n * to work around bugs in some JS interpreters.\n */\nfunction safe_add(x, y)\n{\n  var lsw = (x & 0xFFFF) + (y & 0xFFFF);\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return (msw << 16) | (lsw & 0xFFFF);\n}\n\n/*\n * Bitwise rotate a 32-bit number to the left.\n */\nfunction rol(num, cnt)\n{\n  return (num << cnt) | (num >>> (32 - cnt));\n}\n\n/*\n * Convert an 8-bit or 16-bit string to an array of big-endian words\n * In 8-bit function, characters >255 have their hi-byte silently ignored.\n */\nfunction str2binb(str)\n{\n  var bin = Array();\n  var mask = (1 << chrsz) - 1;\n  for(var i = 0; i < str.length * chrsz; i += chrsz)\n    bin[i>>5] |= (str.charCodeAt(i / chrsz) & mask) << (32 - chrsz - i%32);\n  return bin;\n}\n\n/*\n * Convert an array of big-endian words to a string\n */\nfunction binb2str(bin)\n{\n  var str = \"\";\n  var mask = (1 << chrsz) - 1;\n  for(var i = 0; i < bin.length * 32; i += chrsz)\n    str += String.fromCharCode((bin[i>>5] >>> (32 - chrsz - i%32)) & mask);\n  return str;\n}\n\n/*\n * Convert an array of big-endian words to a hex string.\n */\nfunction binb2hex(binarray)\n{\n  var hex_tab = hexcase ? \"0123456789ABCDEF\" : \"0123456789abcdef\";\n  var str = \"\";\n  for(var i = 0; i < binarray.length * 4; i++)\n  {\n    str += hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8+4)) & 0xF) +\n           hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8  )) & 0xF);\n  }\n  return str;\n}\n\n/*\n * Convert an array of big-endian words to a base-64 string\n */\nfunction binb2b64(binarray)\n{\n  var tab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n  var str = \"\";\n  for(var i = 0; i < binarray.length * 4; i += 3)\n  {\n    var triplet = (((binarray[i   >> 2] >> 8 * (3 -  i   %4)) & 0xFF) << 16)\n                | (((binarray[i+1 >> 2] >> 8 * (3 - (i+1)%4)) & 0xFF) << 8 )\n                |  ((binarray[i+2 >> 2] >> 8 * (3 - (i+2)%4)) & 0xFF);\n    for(var j = 0; j < 4; j++)\n    {\n      if(i * 8 + j * 6 > binarray.length * 32) str += b64pad;\n      else str += tab.charAt((triplet >> 6*(3-j)) & 0x3F);\n    }\n  }\n  return str;\n}\n\n\n//@ sourceURL=/node_modules/crypto-browserify/sha.js"
));

require.define("/node_modules/crypto-browserify/rng.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Original code adapted from Robert Kieffer.\n// details at https://github.com/broofa/node-uuid\n(function() {\n  var _global = this;\n\n  var mathRNG, whatwgRNG;\n\n  // NOTE: Math.random() does not guarantee \"cryptographic quality\"\n  mathRNG = function(size) {\n    var bytes = new Array(size);\n    var r;\n\n    for (var i = 0, r; i < size; i++) {\n      if ((i & 0x03) == 0) r = Math.random() * 0x100000000;\n      bytes[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return bytes;\n  }\n\n  // currently only available in webkit-based browsers.\n  if (_global.crypto && crypto.getRandomValues) {\n    var _rnds = new Uint32Array(4);\n    whatwgRNG = function(size) {\n      var bytes = new Array(size);\n      crypto.getRandomValues(_rnds);\n\n      for (var c = 0 ; c < size; c++) {\n        bytes[c] = _rnds[c >> 2] >>> ((c & 0x03) * 8) & 0xff;\n      }\n      return bytes;\n    }\n  }\n\n  module.exports = whatwgRNG || mathRNG;\n\n}())\n//@ sourceURL=/node_modules/crypto-browserify/rng.js"
));

require.define("/todo/item.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var ClassList = require(\"class-list\")\n    , remove = require(\"insert\").remove\n    , reduce = require(\"reducers/reduce\")\n    , map = require(\"reducers/map\")\n    , flatten = require(\"reducers/flatten\")\n    , filter = require(\"reducers/filter\")\n    , events = require(\"dom-reduce/event\")\n    , compound = require(\"compound\")\n    , prop = require(\"prop\")\n    , not = require(\"not\")\n\n    , Writer = require(\"../reflex/writer\")\n    , Component = require(\"../reflex/component\")\n    , html = require(\"../lib/html\")\n    , method = require(\"../lib/method\")\n    , equal = require(\"../lib/equal\")\n    , todoHtml = require(\"./html/todo\")\n\n    , ENTER = 13\n\nmodule.exports = TodoItem\n\n/*\n    TodoItem is a Component of a write / read part.\n\n    The write part has swap, open and close.\n        when a new todo item is found we open a DOM element for it.\n        When a todo item is updated we swap the contents\n        When a todo item is removed we close the DOM element\n\n    When a new todo item is created (open is called on the writer)\n        we pass the component upto the parent to have it injected\n        into the DOM for us.\n*/\nfunction TodoItem(parent) {\n    var write = Writer(swap, open, close)\n\n    return Component(read, write)\n\n    function open() {\n        var component = html(todoHtml)\n\n        parent(component.root)\n\n        return component\n    }\n}\n\nfunction swap(component, value) {\n    if (\"title\" in value) {\n        component.text.textContent = value.title\n        component.input.value = value.title\n    }\n\n    if (\"completed\" in value) {\n        var completed = value.completed\n\n        component.toggle.checked = value.completed\n\n        if (completed) {\n            ClassList(component.root).add(\"completed\")\n        } else {\n            ClassList(component.root).remove(\"completed\")\n        }\n    }\n}\n\nfunction close(component) {\n    remove(component.root)\n}\n\nfunction read(component) {\n    var root = component.root\n        , input = component.input\n\n    compound\n        (reduce, function () {\n            ClassList(root).add(\"editing\")\n            input.focus()\n        })\n        (events(component.text, \"dblclick\"))\n\n    var completions = compound\n        (map, prop(\"target.checked\"))\n        (map, function (completed) {\n            return {\n                completed: completed\n            }\n        })\n        (events(component.toggle, \"change\"))\n\n    var destructions = compound\n        (map, nil)\n        (events(component.destroy, \"click\"))\n\n    compound\n        (filter, equal(\"keyCode\", ENTER))\n        (reduce, function (_, event) {\n            event.target.blur()\n        })\n        (events(input, \"keypress\"))\n\n    var values = compound\n        (map, prop(\"target.value\"))\n        (map, method(\"trim\"))\n        (events(input, \"blur\"))\n\n    reduce(values, function(_, value) {\n        ClassList(root).remove(\"editing\")\n    })\n\n    var deletions = compound\n        (filter, not(Boolean))\n        (map, nil)\n        (values)\n\n    var changes = compound\n        (filter, Boolean)\n        (map, function (text) {\n            return {\n                title: text\n            }\n        })\n        (values)\n\n    return flatten([ destructions, completions\n        , changes, deletions ])\n}\n\nfunction nil() {\n    return null\n}\n\n//@ sourceURL=/todo/item.js"
));

require.define("/node_modules/class-list/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index\"}\n//@ sourceURL=/node_modules/class-list/package.json"
));

require.define("/node_modules/class-list/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// contains, add, remove, toggle\n\nmodule.exports = ClassList\n\nfunction ClassList(elem) {\n    var cl = elem.classList\n\n    if (cl) {\n        return cl\n    }\n\n    var classList = {\n        add: add\n        , remove: remove\n        , contains: contains\n        , toggle: toggle\n        , toString: $toString\n        , length: 0\n        , item: item\n    }\n\n    return classList\n\n    function add(token) {\n        var list = getTokens()\n        if (list.indexOf(token) > -1) {\n            return\n        }\n        list.push(token)\n        setTokens(list)\n    }\n\n    function remove(token) {\n        var list = getTokens()\n            , index = list.indexOf(token)\n\n        if (index === -1) {\n            return\n        }\n\n        list.splice(index, 1)\n        setTokens(list)\n    }\n\n    function contains(token) {\n        return getTokens().indexOf(token) > -1\n    }\n\n    function toggle(token) {\n        if (contains(token)) {\n            remove(token)\n            return false\n        } else {\n            add(token)\n            return true\n        }\n    }\n\n    function $toString() {\n        return elem.className\n    }\n\n    function item(index) {\n        var tokens = getTokens()\n        return tokens[index] || null\n    }\n\n    function getTokens() {\n        var className = elem.className\n\n        return className.split(\" \").filter(isTruthy)\n    }\n\n    function setTokens(list) {\n        var length = list.length\n\n        elem.className = list.join(\" \")\n        classList.length = length\n\n        for (var i = 0; i < list.length; i++) {\n            classList[i] = list[i]\n        }\n\n        delete list[length]\n    }\n}\n\nfunction isTruthy(value) {\n    return !!value\n}\n//@ sourceURL=/node_modules/class-list/index.js"
));

require.define("/node_modules/prop/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/prop/package.json"
));

require.define("/node_modules/prop/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var dotty = require(\"dotty\").get\n\n// prop\n//\n// functional routine to get a property from an object\n//\n// var obj = {foo: 'bar'}\n// var result = prop('foo')(obj)\n//\nmodule.exports = function(name) {\n  return function(object) {\n    return dotty(object, name)\n  }\n}\n\n\n//@ sourceURL=/node_modules/prop/index.js"
));

require.define("/node_modules/prop/node_modules/dotty/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"lib/index.js\"}\n//@ sourceURL=/node_modules/prop/node_modules/dotty/package.json"
));

require.define("/node_modules/prop/node_modules/dotty/lib/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"//\n// Dotty makes it easy to programmatically access arbitrarily nested objects and\n// their properties.\n//\n\n//\n// `object` is an object, `path` is the path to the property you want to check\n// for existence of.\n//\n// `path` can be provided as either a `\"string.separated.with.dots\"` or as\n// `[\"an\", \"array\"]`.\n//\n// Returns `true` if the path can be completely resolved, `false` otherwise.\n//\n\nvar exists = module.exports.exists = function exists(object, path) {\n  if (typeof path === \"string\") {\n    path = path.split(\".\");\n  }\n\n  if (!(path instanceof Array) || path.length === 0) {\n    return false;\n  }\n\n  path = path.slice();\n\n  var key = path.shift();\n\n  if (typeof object !== \"object\" || object === null) {\n    return false;\n  }\n\n  if (path.length === 0) {\n    return Object.hasOwnProperty.apply(object, [key]);\n  } else {\n    return exists(object[key], path);\n  }\n};\n\n//\n// These arguments are the same as those for `exists`.\n//\n// The return value, however, is the property you're trying to access, or\n// `undefined` if it can't be found. This means you won't be able to tell\n// the difference between an unresolved path and an undefined property, so you \n// should not use `get` to check for the existence of a property. Use `exists`\n// instead.\n//\n\nvar get = module.exports.get = function get(object, path) {\n  if (typeof path === \"string\") {\n    path = path.split(\".\");\n  }\n\n  if (!(path instanceof Array) || path.length === 0) {\n    return;\n  }\n\n  path = path.slice();\n\n  var key = path.shift();\n\n  if (typeof object !== \"object\" || object === null) {\n    return;\n  }\n\n  if (path.length === 0) {\n    return object[key];\n  }\n\n  if (path.length) {\n    return get(object[key], path);\n  }\n};\n\n//\n// Arguments are similar to `exists` and `get`, with the exception that path\n// components are regexes with some special cases. If a path component is `\"*\"`\n// on its own, it'll be converted to `/.*/`.\n//\n// The return value is an array of values where the key path matches the\n// specified criterion. If none match, an empty array will be returned.\n//\n\nvar search = module.exports.search = function search(object, path) {\n  if (typeof path === \"string\") {\n    path = path.split(\".\");\n  }\n\n  if (!(path instanceof Array) || path.length === 0) {\n    return;\n  }\n\n  path = path.slice();\n\n  var key = path.shift();\n\n  if (typeof object !== \"object\" || object === null) {\n    return;\n  }\n\n  if (key === \"*\") {\n    key = \".*\";\n  }\n\n  if (typeof key === \"string\") {\n    key = new RegExp(key);\n  }\n\n  if (path.length === 0) {\n    return Object.keys(object).filter(key.test.bind(key)).map(function(k) { return object[k]; });\n  } else {\n    return Array.prototype.concat.apply([], Object.keys(object).filter(key.test.bind(key)).map(function(k) { return search(object[k], path); }));\n  }\n};\n\n//\n// The first two arguments for `put` are the same as `exists` and `get`.\n//\n// The third argument is a value to `put` at the `path` of the `object`.\n// Objects in the middle will be created if they don't exist, or added to if\n// they do. If a value is encountered in the middle of the path that is *not*\n// an object, it will not be overwritten.\n//\n// The return value is `true` in the case that the value was `put`\n// successfully, or `false` otherwise.\n//\n\nvar put = module.exports.put = function put(object, path, value) {\n  if (typeof path === \"string\") {\n    path = path.split(\".\");\n  }\n\n  if (!(path instanceof Array) || path.length === 0) {\n    return false;\n  }\n  \n  path = path.slice();\n\n  var key = path.shift();\n\n  if (typeof object !== \"object\" || object === null) {\n    return false;\n  }\n\n  if (path.length === 0) {\n    object[key] = value;\n  } else {\n    if (typeof object[key] === \"undefined\") {\n      object[key] = {};\n    }\n\n    if (typeof object[key] !== \"object\" || object[key] === null) {\n      return false;\n    }\n\n    return put(object[key], path, value);\n  }\n};\n\n//@ sourceURL=/node_modules/prop/node_modules/dotty/lib/index.js"
));

require.define("/node_modules/not/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index\"}\n//@ sourceURL=/node_modules/not/package.json"
));

require.define("/node_modules/not/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = not\n\nfunction not(f) {\n    return negation\n\n    function negation() {\n        return !f.apply(this, arguments)\n    }\n}\n\n//@ sourceURL=/node_modules/not/index.js"
));

require.define("/reflex/component.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var reduce = require(\"reducers/reduce\")\nvar filter = require(\"reducers/filter\")\nvar map = require(\"reducers/map\")\nvar channel = require(\"reducers/channel\")\nvar flatten = require(\"reducers/flatten\")\nvar emit = require(\"reducers/emit\")\nvar concat = require(\"reducers/concat\")\n\nmodule.exports = Component\n\nfunction Component(read, write) {\n    return function reactor(changes, options) {\n        var inputs = channel()\n        var hash = {}\n\n        reduce(changes, function (_, change) {\n            Object.keys(change).forEach(function (id) {\n                if (id in hash) {\n                    if (change[id] === null) {\n                        delete hash[id]\n                    }\n\n                    return\n                }\n\n                hash[id] = true\n\n                var items = concat(change, changes)\n                var fork =  filter(items, exists)\n                var updates = map(fork, attribute)\n                var readable = write(updates, options)\n                var input = read(readable)\n                var deltas = map(input, expand)\n\n                emit(inputs, deltas)\n\n                function exists(data) {\n                    return id in data\n                }\n\n                function attribute(data) {\n                    return data[id]\n                }\n\n                function expand(change) {\n                    var changes = {}\n                    changes[id] = change\n                    return changes\n                }\n            })\n        })\n\n        return flatten(inputs)\n    }\n}\n\n//@ sourceURL=/reflex/component.js"
));

require.define("/node_modules/reducers/concat.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar convert = require(\"./convert\")\nvar accumulate = require(\"./accumulate\")\nvar end = require(\"./end\")\n\nvar slicer = Array.prototype.slice\n\nfunction append(left, right) {\n  /**\n  Returns sequences of items in the `left` sequence followed by the\n  items in the `right` sequence.\n  **/\n  return convert({}, function(self, next, initial) {\n    accumulate(left, function(value, result) {\n      return value && value.is === end ? accumulate(right, next, result) :\n                                         next(value, result)\n    }, initial)\n  })\n}\n\nfunction concat(left, right /*, ...rest*/) {\n  /**\n  Returns a sequence representing the concatenation of the elements in the\n  supplied arguments, in the given order.\n\n  print(concat([ 1 ], [ 2, 3 ], [ 4, 5, 6 ])) // => <stream 1 2 3 4 5 6 />\n\n  **/\n  switch (arguments.length) {\n    case 1: return left\n    case 2: return append(left, right)\n    default: return slicer.call(arguments).reduce(append)\n  }\n}\n\nmodule.exports = concat\n\n//@ sourceURL=/node_modules/reducers/concat.js"
));

require.define("/lib/html.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var unpack = require(\"unpack-element\")\n    , Element = require(\"fragment\").Element\n\nmodule.exports = html\n\nfunction html(src) {\n    return unpack(Element(src))\n}\n\n//@ sourceURL=/lib/html.js"
));

require.define("/node_modules/unpack-element/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index\"}\n//@ sourceURL=/node_modules/unpack-element/package.json"
));

require.define("/node_modules/unpack-element/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var walk = require(\"dom-walk\")\n\nmodule.exports = unpack\n\nfunction unpack(elem) {\n    var struct = {}\n    walk([elem], function (node) {\n        if (node.id) {\n            var id = node.id\n            node.removeAttribute(\"id\")\n            struct[id] = node\n        }\n    })\n    if (!struct.root) {\n        struct.root = elem\n    }\n    return struct\n}\n//@ sourceURL=/node_modules/unpack-element/index.js"
));

require.define("/node_modules/unpack-element/node_modules/dom-walk/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index\"}\n//@ sourceURL=/node_modules/unpack-element/node_modules/dom-walk/package.json"
));

require.define("/node_modules/unpack-element/node_modules/dom-walk/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var slice = Array.prototype.slice\n\nmodule.exports = iterativelyWalk\n\nfunction iterativelyWalk(nodes, cb) {\n    nodes = slice.call(nodes)\n\n    while(nodes.length) {\n        var node = nodes.shift(),\n            ret = cb(node)\n\n        if (ret) {\n            return ret\n        }\n\n        if (node.childNodes.length) {\n            nodes = slice.call(node.childNodes).concat(nodes)\n        }\n    }\n}\n//@ sourceURL=/node_modules/unpack-element/node_modules/dom-walk/index.js"
));

require.define("/node_modules/fragment/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/fragment/package.json"
));

require.define("/node_modules/fragment/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"Fragment.Element = Element\n\nmodule.exports = Fragment\n\nfunction Fragment(html, elementName) {\n    var el = document.createElement(elementName || \"div\")\n        , fragment = document.createDocumentFragment()\n\n    el.innerHTML = html\n\n    while (el.hasChildNodes()) {\n        fragment.appendChild(el.firstChild)\n    }\n\n    return fragment\n}\n\nfunction Element(html, elementName) {\n    var el = document.createElement(elementName || \"div\")\n\n    el.innerHTML = html\n\n    var child = el.firstChild\n    el.removeChild(child)\n\n    return child\n}\n//@ sourceURL=/node_modules/fragment/index.js"
));

require.define("/lib/method.js",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = method\n\nfunction method(name) {\n    return function (item) {\n        return item[name]()\n    }\n}\n\n//@ sourceURL=/lib/method.js"
));

require.define("/lib/equal.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var dotty = require(\"dotty\")\n\nmodule.exports = equal\n\nfunction equal(prop, value) {\n    return function (item) {\n        if (typeof prop === \"string\" || Array.isArray(prop)) {\n            return dotty.get(item, prop) === value\n        } else {\n            return item === value\n        }\n    }\n}\n\n//@ sourceURL=/lib/equal.js"
));

require.define("/node_modules/dotty/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"lib/index.js\"}\n//@ sourceURL=/node_modules/dotty/package.json"
));

require.define("/node_modules/dotty/lib/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"//\n// Dotty makes it easy to programmatically access arbitrarily nested objects and\n// their properties.\n//\n\n//\n// `object` is an object, `path` is the path to the property you want to check\n// for existence of.\n//\n// `path` can be provided as either a `\"string.separated.with.dots\"` or as\n// `[\"an\", \"array\"]`.\n//\n// Returns `true` if the path can be completely resolved, `false` otherwise.\n//\n\nvar exists = module.exports.exists = function exists(object, path) {\n  if (typeof path === \"string\") {\n    path = path.split(\".\");\n  }\n\n  if (!(path instanceof Array) || path.length === 0) {\n    return false;\n  }\n\n  path = path.slice();\n\n  var key = path.shift();\n\n  if (typeof object !== \"object\" || object === null) {\n    return false;\n  }\n\n  if (path.length === 0) {\n    return Object.hasOwnProperty.apply(object, [key]);\n  } else {\n    return exists(object[key], path);\n  }\n};\n\n//\n// These arguments are the same as those for `exists`.\n//\n// The return value, however, is the property you're trying to access, or\n// `undefined` if it can't be found. This means you won't be able to tell\n// the difference between an unresolved path and an undefined property, so you \n// should not use `get` to check for the existence of a property. Use `exists`\n// instead.\n//\n\nvar get = module.exports.get = function get(object, path) {\n  if (typeof path === \"string\") {\n    path = path.split(\".\");\n  }\n\n  if (!(path instanceof Array) || path.length === 0) {\n    return;\n  }\n\n  path = path.slice();\n\n  var key = path.shift();\n\n  if (typeof object !== \"object\" || object === null) {\n    return;\n  }\n\n  if (path.length === 0) {\n    return object[key];\n  }\n\n  if (path.length) {\n    return get(object[key], path);\n  }\n};\n\n//\n// Arguments are similar to `exists` and `get`, with the exception that path\n// components are regexes with some special cases. If a path component is `\"*\"`\n// on its own, it'll be converted to `/.*/`.\n//\n// The return value is an array of values where the key path matches the\n// specified criterion. If none match, an empty array will be returned.\n//\n\nvar search = module.exports.search = function search(object, path) {\n  if (typeof path === \"string\") {\n    path = path.split(\".\");\n  }\n\n  if (!(path instanceof Array) || path.length === 0) {\n    return;\n  }\n\n  path = path.slice();\n\n  var key = path.shift();\n\n  if (typeof object !== \"object\" || object === null) {\n    return;\n  }\n\n  if (key === \"*\") {\n    key = \".*\";\n  }\n\n  if (typeof key === \"string\") {\n    key = new RegExp(key);\n  }\n\n  if (path.length === 0) {\n    return Object.keys(object).filter(key.test.bind(key)).map(function(k) { return object[k]; });\n  } else {\n    return Array.prototype.concat.apply([], Object.keys(object).filter(key.test.bind(key)).map(function(k) { return search(object[k], path); }));\n  }\n};\n\n//\n// The first two arguments for `put` are the same as `exists` and `get`.\n//\n// The third argument is a value to `put` at the `path` of the `object`.\n// Objects in the middle will be created if they don't exist, or added to if\n// they do. If a value is encountered in the middle of the path that is *not*\n// an object, it will not be overwritten.\n//\n// The return value is `true` in the case that the value was `put`\n// successfully, or `false` otherwise.\n//\n\nvar put = module.exports.put = function put(object, path, value) {\n  if (typeof path === \"string\") {\n    path = path.split(\".\");\n  }\n\n  if (!(path instanceof Array) || path.length === 0) {\n    return false;\n  }\n  \n  path = path.slice();\n\n  var key = path.shift();\n\n  if (typeof object !== \"object\" || object === null) {\n    return false;\n  }\n\n  if (path.length === 0) {\n    object[key] = value;\n  } else {\n    if (typeof object[key] === \"undefined\") {\n      object[key] = {};\n    }\n\n    if (typeof object[key] !== \"object\" || object[key] === null) {\n      return false;\n    }\n\n    return put(object[key], path, value);\n  }\n};\n\n//@ sourceURL=/node_modules/dotty/lib/index.js"
));

require.define("/todo/html/todo.html",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = '<li>\\n    <div class=\"view\">\\n        <input id=\"toggle\" class=\"toggle\" type=\"checkbox\">\\n        <label id=\"text\"></label>\\n        <button id=\"destroy\" class=\"destroy\"></button>\\n    </div>\\n    <input id=\"input\" class=\"edit\">\\n</li>\\n'\n//@ sourceURL=/todo/html/todo.html"
));

require.define("/reflex/unit.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var filter = require(\"reducers/filter\")\nvar map = require(\"reducers/map\")\nvar flatten = require(\"reducers/flatten\")\nvar channel = require(\"reducers/channel\")\nvar reduce = require(\"reducers/reduce\")\nvar emit = require(\"reducers/emit\")\n\nmodule.exports = Unit\n\nfunction Unit(mapping) {\n    return function reactor(source, options) {\n        var changes = source || channel()\n\n        var inputs = Object.keys(mapping).map(function (id) {\n            var react = mapping[id]\n            var fork = filter(changes, exists)\n            var updates = map(fork, attribute)\n\n            var input = react(updates, options)\n\n            return map(input, expand)\n\n            function exists(data) {\n                return id in data\n            }\n\n            function attribute(data) {\n                return data[id]\n            }\n\n            function expand(change) {\n                var changes = {}\n                changes[id] = change\n                return changes\n            }\n        })\n\n        var input = flatten(inputs)\n\n        if (!source) {\n            pipe(input, changes)\n        }\n\n        return source ? input : changes\n    }\n}\n\nfunction pipe(input, output) {\n    reduce(input, function(_, x) {\n        emit(output, x)\n    })\n}\n\n//@ sourceURL=/reflex/unit.js"
));

require.define("/todo/html/todoList.html",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = '<section class=\"todoapp\">\\n    <header class=\"header\">\\n        <h1>todos</h1>\\n        <input id=\"input\"\\n            class=\"new-todo\"\\n            placeholder=\"What needs to be done?\"\\n            autofocus\\n        />\\n    </header>\\n    <!-- This section should be hidden by default and shown when there are todos -->\\n    <section class=\"main\" id=\"main\">\\n        <ul id=\"list\" class=\"todo-list\">\\n            <!-- These are here just to show the structure of the list items -->\\n            <!-- List items should get the class `editing` when editing and `completed` when marked as completed -->\\n            <!--\\n            <li class=\"completed\">\\n                <div class=\"view\">\\n                    <input class=\"toggle\" type=\"checkbox\" checked>\\n                    <label>Create a TodoMVC template</label>\\n                    <button class=\"destroy\"></button>\\n                </div>\\n                <input class=\"edit\" value=\"Create a TodoMVC template\">\\n            </li>\\n            <li>\\n                <div class=\"view\">\\n                    <input class=\"toggle\" type=\"checkbox\">\\n                    <label>Rule the web</label>\\n                    <button class=\"destroy\"></button>\\n                </div>\\n                <input class=\"edit\" value=\"Rule the web\">\\n            </li>\\n            -->\\n        </ul>\\n    </section>\\n    <!-- This footer should hidden by default and shown when there are todos -->\\n    <footer id=\"footer\" class=\"footer\">\\n        <!-- This should be `0 items left` by default -->\\n\\n        <!-- Remove this if you dont implement routing -->\\n        <ul id=\"filters\" class=\"filters\">\\n            <li>\\n                <a data-id=\"all\" class=\"selected\" href=\"#/\">All</a>\\n            </li>\\n            <li>\\n                <a data-id=\"active\" href=\"#/active\">Active</a>\\n            </li>\\n            <li>\\n                <a data-id=\"completed\" href=\"#/completed\">Completed</a>\\n            </li>\\n        </ul>\\n    </footer>\\n</section>\\n'\n//@ sourceURL=/todo/html/todoList.html"
));

require.define("/initial.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var emit = require(\"reducers/emit\")\n\nmodule.exports = initial\n\nfunction initial(changes) {\n    emit(changes, {\n        \"todo\": {\n            \"1\": {\n                completed: false\n                , title: \"foo\"\n            }\n        }\n    })\n\n    setTimeout(function () {\n        emit(changes, {\n            \"todo\": {\n                \"1\": {\n                    completed: true\n                    , title: \"bar\"\n                }\n            }\n        })\n    }, 1000)\n\n    setTimeout(function () {\n        emit(changes, {\n            \"todo\": {\n                \"1\": null\n            }\n        })\n    }, 2000)\n}\n\n//@ sourceURL=/initial.js"
));

require.define("/node_modules/browserify-server/other.js",Function(['require','module','exports','__dirname','__filename','process','global'],"process.env.NODE_ENV = 'undefined'\n\n//@ sourceURL=/node_modules/browserify-server/other.js"
));
require("/node_modules/browserify-server/other.js");

require.define("/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var prepend = require(\"insert\").prepend\n    , partial = require(\"ap\").partial\n    , channel = require(\"reducers/channel\")\n\n    , pipe = require(\"./lib/pipe\")\n    , persist = require(\"./persist\")\n    , TodoList = require(\"./todo\")\n    , initial = require(\"./initial\")\n\n    , body = document.body\n    /*\n        Your application needs a single stream of changes\n            for which all changes flow too\n    */\n    , changes = channel()\n    /*\n        The root part of the application is the TodoList.\n\n        Pass it a function which tells you where to put the\n            DOM element for the todoList.\n\n        In this case prepend(body, elem)\n    */\n    , todoList = TodoList(partial(prepend, body))\n    /*\n        We want to have the changes flow through the persistance\n            mechanism and the todoList\n    */\n    , app = [todoList]\n\n/*\n    For each one create the input stream by passing in the\n        changes stream and then pipe that back into the\n        changes stream to create a closed loop flow.\n*/\napp.forEach(function (reactor) {\n    pipe(reactor(changes), changes)\n})\n\n/*\n    Inject some initial input into the changes stream for\n        testing purpose\n*/\ninitial(changes)\n\n// Expose require\nwindow.require = require\n\n//@ sourceURL=/index.js"
));
require("/index.js");
})();
