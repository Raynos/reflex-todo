(function(){var require = function (file, cwd) {
    var resolved = require.resolve(file, cwd || '/');
    var mod = require.modules[resolved];
    if (!mod) throw new Error(
        'Failed to resolve module ' + file + ', tried ' + resolved
    );
    var cached = require.cache[resolved];
    var res = cached? cached.exports : mod();
    return res;
};

require.paths = [];
require.modules = {};
require.cache = {};
require.extensions = [".js",".coffee",".json",".html",".svg"];

require._core = {
    'assert': true,
    'events': true,
    'fs': true,
    'path': true,
    'vm': true
};

require.resolve = (function () {
    return function (x, cwd) {
        if (!cwd) cwd = '/';

        if (require._core[x]) return x;
        var path = require.modules.path();
        cwd = path.resolve('/', cwd);
        var y = cwd || '/';

        if (x.match(/^(?:\.\.?\/|\/)/)) {
            var m = loadAsFileSync(path.resolve(y, x))
                || loadAsDirectorySync(path.resolve(y, x));
            if (m) return m;
        }

        var n = loadNodeModulesSync(x, y);
        if (n) return n;

        throw new Error("Cannot find module '" + x + "'");

        function loadAsFileSync (x) {
            x = path.normalize(x);
            if (require.modules[x]) {
                return x;
            }

            for (var i = 0; i < require.extensions.length; i++) {
                var ext = require.extensions[i];
                if (require.modules[x + ext]) return x + ext;
            }
        }

        function loadAsDirectorySync (x) {
            x = x.replace(/\/+$/, '');
            var pkgfile = path.normalize(x + '/package.json');
            if (require.modules[pkgfile]) {
                var pkg = require.modules[pkgfile]();
                var b = pkg.browserify;
                if (typeof b === 'object' && b.main) {
                    var m = loadAsFileSync(path.resolve(x, b.main));
                    if (m) return m;
                }
                else if (typeof b === 'string') {
                    var m = loadAsFileSync(path.resolve(x, b));
                    if (m) return m;
                }
                else if (pkg.main) {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                }
            }

            return loadAsFileSync(x + '/index');
        }

        function loadNodeModulesSync (x, start) {
            var dirs = nodeModulesPathsSync(start);
            for (var i = 0; i < dirs.length; i++) {
                var dir = dirs[i];
                var m = loadAsFileSync(dir + '/' + x);
                if (m) return m;
                var n = loadAsDirectorySync(dir + '/' + x);
                if (n) return n;
            }

            var m = loadAsFileSync(x);
            if (m) return m;
        }

        function nodeModulesPathsSync (start) {
            var parts;
            if (start === '/') parts = [ '' ];
            else parts = path.normalize(start).split('/');

            var dirs = [];
            for (var i = parts.length - 1; i >= 0; i--) {
                if (parts[i] === 'node_modules') continue;
                var dir = parts.slice(0, i + 1).join('/') + '/node_modules';
                dirs.push(dir);
            }

            return dirs;
        }
    };
})();

require.alias = function (from, to) {
    var path = require.modules.path();
    var res = null;
    try {
        res = require.resolve(from + '/package.json', '/');
    }
    catch (err) {
        res = require.resolve(from, '/');
    }
    var basedir = path.dirname(res);

    var keys = (Object.keys || function (obj) {
        var res = [];
        for (var key in obj) res.push(key);
        return res;
    })(require.modules);

    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key.slice(0, basedir.length + 1) === basedir + '/') {
            var f = key.slice(basedir.length);
            require.modules[to + f] = require.modules[basedir + f];
        }
        else if (key === basedir) {
            require.modules[to] = require.modules[basedir];
        }
    }
};

(function () {
    var process = {};
    var global = typeof window !== 'undefined' ? window : {};
    var definedProcess = false;

    require.define = function (filename, fn) {
        // if (!definedProcess && require.modules.__browserify_process) {
        if (require.modules.__browserify_process) {
            process = require.modules.__browserify_process();
        }

            // definedProcess = true;
        // }

        var dirname = require._core[filename]
            ? ''
            : require.modules.path().dirname(filename)
        ;

        var require_ = function (file) {
            var requiredModule = require(file, dirname);
            var cached = require.cache[require.resolve(file, dirname)];

            if (cached && cached.parent === null) {
                cached.parent = module_;
            }

            return requiredModule;
        };
        require_.resolve = function (name) {
            return require.resolve(name, dirname);
        };
        require_.modules = require.modules;
        require_.define = require.define;
        require_.cache = require.cache;
        var module_ = {
            id : filename,
            filename: filename,
            exports : {},
            loaded : false,
            parent: null
        };

        require.modules[filename] = function () {
            require.cache[filename] = module_;
            fn.call(
                module_.exports,
                require_,
                module_,
                module_.exports,
                dirname,
                filename,
                process,
                global
            );
            module_.loaded = true;
            return module_.exports;
        };
    };
})();


require.define("path",Function(['require','module','exports','__dirname','__filename','process','global'],"function filter (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (fn(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length; i >= 0; i--) {\n    var last = parts[i];\n    if (last == '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Regex to split a filename into [*, dir, basename, ext]\n// posix version\nvar splitPathRe = /^(.+\\/(?!$)|\\/)?((?:.+?)?(\\.[^.]*)?)$/;\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\nvar resolvedPath = '',\n    resolvedAbsolute = false;\n\nfor (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {\n  var path = (i >= 0)\n      ? arguments[i]\n      : process.cwd();\n\n  // Skip empty and invalid entries\n  if (typeof path !== 'string' || !path) {\n    continue;\n  }\n\n  resolvedPath = path + '/' + resolvedPath;\n  resolvedAbsolute = path.charAt(0) === '/';\n}\n\n// At this point the path should be resolved to a full absolute path, but\n// handle relative paths to be safe (might happen when process.cwd() fails)\n\n// Normalize the path\nresolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\nvar isAbsolute = path.charAt(0) === '/',\n    trailingSlash = path.slice(-1) === '/';\n\n// Normalize the path\npath = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n  \n  return (isAbsolute ? '/' : '') + path;\n};\n\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    return p && typeof p === 'string';\n  }).join('/'));\n};\n\n\nexports.dirname = function(path) {\n  var dir = splitPathRe.exec(path)[1] || '';\n  var isWindows = false;\n  if (!dir) {\n    // No dirname\n    return '.';\n  } else if (dir.length === 1 ||\n      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {\n    // It is just a slash or a drive letter with a slash\n    return dir;\n  } else {\n    // It is a full dirname, strip trailing slash\n    return dir.substring(0, dir.length - 1);\n  }\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPathRe.exec(path)[2] || '';\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPathRe.exec(path)[3] || '';\n};\n\n//@ sourceURL=path"
));

require.define("__browserify_process",Function(['require','module','exports','__dirname','__filename','process','global'],"var process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n        && window.setImmediate;\n    var canPost = typeof window !== 'undefined'\n        && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return window.setImmediate;\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener('message', function (ev) {\n            if (ev.source === window && ev.data === 'browserify-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('browserify-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nprocess.binding = function (name) {\n    if (name === 'evals') return (require)('vm')\n    else throw new Error('No such module. (Possibly not yet loaded)')\n};\n\n(function () {\n    var cwd = '/';\n    var path;\n    process.cwd = function () { return cwd };\n    process.chdir = function (dir) {\n        if (!path) path = require('path');\n        cwd = path.resolve(dir, cwd);\n    };\n})();\n\n//@ sourceURL=__browserify_process"
));

require.define("/home/raynos/Documents/reflex-todo/node_modules/browserify-server/lib/dummy.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var process = require.modules.__browserify_process();\nprocess.env.NODE_ENV = 'undefined'\nrequire.modules.__browserify_process = function () {\n   return process\n}\n//@ sourceURL=/home/raynos/Documents/reflex-todo/node_modules/browserify-server/lib/dummy.js"
));

require.define("/node_modules/live-reload/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index\",\"browserify\":\"browser.js\"}\n//@ sourceURL=/node_modules/live-reload/package.json"
));

require.define("/node_modules/live-reload/browser.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var reconnect = require(\"reconnect/shoe\")\n\nmodule.exports = LiveReloadClient\n\nfunction LiveReloadClient(uri) {\n    if (typeof uri === \"number\") {\n        uri = \"http://localhost:\" + uri\n    }\n\n    reconnect(function (stream) {\n        stream.on(\"data\", ondata)\n    }).connect(uri + \"/shoe\")\n}\n\nfunction ondata(data) {\n    if (data === \"reload\") {\n        document.location.reload()\n    }\n}\n\n//@ sourceURL=/node_modules/live-reload/browser.js"
));

require.define("/node_modules/live-reload/node_modules/reconnect/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"browserify\":\"./shoe\"}\n//@ sourceURL=/node_modules/live-reload/node_modules/reconnect/package.json"
));

require.define("/node_modules/live-reload/node_modules/reconnect/shoe.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\nvar shoe = require('shoe')\n\nmodule.exports = require('./inject')(function (){ \n  var args = [].slice.call(arguments)\n  return shoe.apply(null, args)\n})\n\n//@ sourceURL=/node_modules/live-reload/node_modules/reconnect/shoe.js"
));

require.define("/node_modules/live-reload/node_modules/reconnect/node_modules/shoe/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index.js\",\"browserify\":\"browser.js\"}\n//@ sourceURL=/node_modules/live-reload/node_modules/reconnect/node_modules/shoe/package.json"
));

require.define("/node_modules/live-reload/node_modules/reconnect/node_modules/shoe/browser.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Stream = require('stream');\nvar sockjs = require('sockjs-client');\n\nmodule.exports = function (uri, cb) {\n    if (/^\\/\\/[^\\/]+\\//.test(uri)) {\n        uri = window.location.protocol + uri;\n    }\n    else if (!/^https?:\\/\\//.test(uri)) {\n        uri = window.location.protocol + '//'\n            + window.location.host\n            + (/^\\//.test(uri) ? uri : '/' + uri)\n        ;\n    }\n    \n    var stream = new Stream;\n    stream.readable = true;\n    stream.writable = true;\n    \n    var ready = false;\n    var buffer = [];\n    \n    var sock = sockjs(uri);\n    stream.sock = sock;\n    \n    stream.write = function (msg) {\n        if (!ready || buffer.length) buffer.push(msg)\n        else sock.send(msg)\n    };\n    stream.end = function (msg) {\n        if (msg !== undefined) stream.write(msg);\n        if (!ready) {\n            stream._ended = true;\n            return;\n        }\n        stream.writable = false;\n        sock.close();\n    };\n\n    stream.destroy = function () {\n        stream._ended = true;\n        stream.writable = stream.readable = false;\n        buffer.length = 0\n        sock.close();\n    }\n    \n    sock.onopen = function () {\n        if (typeof cb === 'function') cb();\n        ready = true;\n        buffer.forEach(function (msg) {\n            sock.send(msg);\n        });\n        buffer = [];\n        stream.emit('connect')\n        if (stream._ended) stream.end();\n    };\n    sock.onmessage = function (e) {\n        stream.emit('data', e.data);\n    };\n    sock.onclose = function () {\n        stream.emit('end');\n        stream.writable = false;\n        stream.readable = false;\n    };\n    \n    return stream;\n};\n\n//@ sourceURL=/node_modules/live-reload/node_modules/reconnect/node_modules/shoe/browser.js"
));

require.define("stream",Function(['require','module','exports','__dirname','__filename','process','global'],"var events = require('events');\nvar util = require('util');\n\nfunction Stream() {\n  events.EventEmitter.call(this);\n}\nutil.inherits(Stream, events.EventEmitter);\nmodule.exports = Stream;\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once, and\n  // only when all sources have ended.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    dest._pipeCount = dest._pipeCount || 0;\n    dest._pipeCount++;\n\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest._pipeCount--;\n\n    // remove the listeners\n    cleanup();\n\n    if (dest._pipeCount > 0) {\n      // waiting for other incoming streams to end.\n      return;\n    }\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest._pipeCount--;\n\n    // remove the listeners\n    cleanup();\n\n    if (dest._pipeCount > 0) {\n      // waiting for other incoming streams to end.\n      return;\n    }\n\n    dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (this.listeners('error').length === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('end', cleanup);\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('end', cleanup);\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\n//@ sourceURL=stream"
));

require.define("events",Function(['require','module','exports','__dirname','__filename','process','global'],"if (!process.EventEmitter) process.EventEmitter = function () {};\n\nvar EventEmitter = exports.EventEmitter = process.EventEmitter;\nvar isArray = typeof Array.isArray === 'function'\n    ? Array.isArray\n    : function (xs) {\n        return Object.prototype.toString.call(xs) === '[object Array]'\n    }\n;\n\n// By default EventEmitters will print a warning if more than\n// 10 listeners are added to it. This is a useful default which\n// helps finding memory leaks.\n//\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nvar defaultMaxListeners = 10;\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!this._events) this._events = {};\n  this._events.maxListeners = n;\n};\n\n\nEventEmitter.prototype.emit = function(type) {\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events || !this._events.error ||\n        (isArray(this._events.error) && !this._events.error.length))\n    {\n      if (arguments[1] instanceof Error) {\n        throw arguments[1]; // Unhandled 'error' event\n      } else {\n        throw new Error(\"Uncaught, unspecified 'error' event.\");\n      }\n      return false;\n    }\n  }\n\n  if (!this._events) return false;\n  var handler = this._events[type];\n  if (!handler) return false;\n\n  if (typeof handler == 'function') {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        var args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n    return true;\n\n  } else if (isArray(handler)) {\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    var listeners = handler.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n      listeners[i].apply(this, args);\n    }\n    return true;\n\n  } else {\n    return false;\n  }\n};\n\n// EventEmitter is defined in src/node_events.cc\n// EventEmitter.prototype.emit() is also defined there.\nEventEmitter.prototype.addListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('addListener only takes instances of Function');\n  }\n\n  if (!this._events) this._events = {};\n\n  // To avoid recursion in the case that type == \"newListeners\"! Before\n  // adding it to the listeners, first emit \"newListeners\".\n  this.emit('newListener', type, listener);\n\n  if (!this._events[type]) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  } else if (isArray(this._events[type])) {\n\n    // Check for listener leak\n    if (!this._events[type].warned) {\n      var m;\n      if (this._events.maxListeners !== undefined) {\n        m = this._events.maxListeners;\n      } else {\n        m = defaultMaxListeners;\n      }\n\n      if (m && m > 0 && this._events[type].length > m) {\n        this._events[type].warned = true;\n        console.error('(node) warning: possible EventEmitter memory ' +\n                      'leak detected. %d listeners added. ' +\n                      'Use emitter.setMaxListeners() to increase limit.',\n                      this._events[type].length);\n        console.trace();\n      }\n    }\n\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  } else {\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  var self = this;\n  self.on(type, function g() {\n    self.removeListener(type, g);\n    listener.apply(this, arguments);\n  });\n\n  return this;\n};\n\nEventEmitter.prototype.removeListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('removeListener only takes instances of Function');\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (!this._events || !this._events[type]) return this;\n\n  var list = this._events[type];\n\n  if (isArray(list)) {\n    var i = list.indexOf(listener);\n    if (i < 0) return this;\n    list.splice(i, 1);\n    if (list.length == 0)\n      delete this._events[type];\n  } else if (this._events[type] === listener) {\n    delete this._events[type];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (type && this._events && this._events[type]) this._events[type] = null;\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  if (!this._events) this._events = {};\n  if (!this._events[type]) this._events[type] = [];\n  if (!isArray(this._events[type])) {\n    this._events[type] = [this._events[type]];\n  }\n  return this._events[type];\n};\n\n//@ sourceURL=events"
));

require.define("util",Function(['require','module','exports','__dirname','__filename','process','global'],"var events = require('events');\n\nexports.print = function () {};\nexports.puts = function () {};\nexports.debug = function() {};\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (typeof f !== 'string') {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j': return JSON.stringify(args[i++]);\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (x === null || typeof x !== 'object') {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Boolean} showHidden Flag that shows hidden (not enumerable)\n *    properties of objects.\n * @param {Number} depth Depth in which to descend in object. Default is 2.\n * @param {Boolean} colors Flag to turn on ANSI escape codes to color the\n *    output. Default is false (no coloring).\n */\nfunction inspect(obj, showHidden, depth, colors) {\n  var ctx = {\n    showHidden: showHidden,\n    seen: [],\n    stylize: colors ? stylizeWithColor : stylizeNoColor\n  };\n  return formatValue(ctx, obj, (typeof depth === 'undefined' ? 2 : depth));\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\nvar colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\nvar styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + colors[style][0] + 'm' + str +\n           '\\u001b[' + colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (value && typeof value.inspect === 'function' &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    return String(value.inspect(recurseTimes));\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object_keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object_getOwnPropertyNames(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (typeof value === 'function') {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (typeof value === 'function') {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  switch (typeof value) {\n    case 'undefined':\n      return ctx.stylize('undefined', 'undefined');\n\n    case 'string':\n      var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                               .replace(/'/g, \"\\\\'\")\n                                               .replace(/\\\\\"/g, '\"') + '\\'';\n      return ctx.stylize(simple, 'string');\n\n    case 'number':\n      return ctx.stylize('' + value, 'number');\n\n    case 'boolean':\n      return ctx.stylize('' + value, 'boolean');\n  }\n  // For some reason typeof null is \"object\", so special case here.\n  if (value === null) {\n    return ctx.stylize('null', 'null');\n  }\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (Object.prototype.hasOwnProperty.call(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!visibleKeys.hasOwnProperty(key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (recurseTimes === null) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (typeof name === 'undefined') {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\nfunction isArray(ar) {\n  return ar instanceof Array ||\n         Array.isArray(ar) ||\n         (ar && ar !== Object.prototype && isArray(ar.__proto__));\n}\n\n\nfunction isRegExp(re) {\n  return re instanceof RegExp ||\n    (typeof re === 'object' && Object.prototype.toString.call(re) === '[object RegExp]');\n}\n\n\nfunction isDate(d) {\n  if (d instanceof Date) return true;\n  if (typeof d !== 'object') return false;\n  var properties = Date.prototype && Object_getOwnPropertyNames(Date.prototype);\n  var proto = d.__proto__ && Object_getOwnPropertyNames(d.__proto__);\n  return JSON.stringify(proto) === JSON.stringify(properties);\n}\n\nfunction isError(e) {\n  return typeof e === 'object' && objectToString(e) === '[object Error]';\n}\nexports.isError = isError;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\nexports.log = function (msg) {};\n\nexports.pump = null;\n\nvar Object_keys = Object.keys || function (obj) {\n    var res = [];\n    for (var key in obj) res.push(key);\n    return res;\n};\n\nvar Object_getOwnPropertyNames = Object.getOwnPropertyNames || function (obj) {\n    var res = [];\n    for (var key in obj) {\n        if (Object.hasOwnProperty.call(obj, key)) res.push(key);\n    }\n    return res;\n};\n\nvar Object_create = Object.create || function (prototype, properties) {\n    // from es5-shim\n    var object;\n    if (prototype === null) {\n        object = { '__proto__' : null };\n    }\n    else {\n        if (typeof prototype !== 'object') {\n            throw new TypeError(\n                'typeof prototype[' + (typeof prototype) + '] != \\'object\\''\n            );\n        }\n        var Type = function () {};\n        Type.prototype = prototype;\n        object = new Type();\n        object.__proto__ = prototype;\n    }\n    if (typeof properties !== 'undefined' && Object.defineProperties) {\n        Object.defineProperties(object, properties);\n    }\n    return object;\n};\n\nexports.inherits = function(ctor, superCtor) {\n  ctor.super_ = superCtor;\n  ctor.prototype = Object_create(superCtor.prototype, {\n    constructor: {\n      value: ctor,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n};\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (typeof f !== 'string') {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(exports.inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j': return JSON.stringify(args[i++]);\n      default:\n        return x;\n    }\n  });\n  for(var x = args[i]; i < len; x = args[++i]){\n    if (x === null || typeof x !== 'object') {\n      str += ' ' + x;\n    } else {\n      str += ' ' + exports.inspect(x);\n    }\n  }\n  return str;\n};\n\n//@ sourceURL=util"
));

require.define("/node_modules/live-reload/node_modules/reconnect/node_modules/shoe/node_modules/sockjs-client/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"sockjs.js\"}\n//@ sourceURL=/node_modules/live-reload/node_modules/reconnect/node_modules/shoe/node_modules/sockjs-client/package.json"
));

require.define("/node_modules/live-reload/node_modules/reconnect/node_modules/shoe/node_modules/sockjs-client/sockjs.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/* SockJS client, version 0.3.1.7.ga67f.dirty, http://sockjs.org, MIT License\n\nCopyright (c) 2011-2012 VMware, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n// JSON2 by Douglas Crockford (minified).\nvar JSON;JSON||(JSON={}),function(){function str(a,b){var c,d,e,f,g=gap,h,i=b[a];i&&typeof i==\"object\"&&typeof i.toJSON==\"function\"&&(i=i.toJSON(a)),typeof rep==\"function\"&&(i=rep.call(b,a,i));switch(typeof i){case\"string\":return quote(i);case\"number\":return isFinite(i)?String(i):\"null\";case\"boolean\":case\"null\":return String(i);case\"object\":if(!i)return\"null\";gap+=indent,h=[];if(Object.prototype.toString.apply(i)===\"[object Array]\"){f=i.length;for(c=0;c<f;c+=1)h[c]=str(c,i)||\"null\";e=h.length===0?\"[]\":gap?\"[\\n\"+gap+h.join(\",\\n\"+gap)+\"\\n\"+g+\"]\":\"[\"+h.join(\",\")+\"]\",gap=g;return e}if(rep&&typeof rep==\"object\"){f=rep.length;for(c=0;c<f;c+=1)typeof rep[c]==\"string\"&&(d=rep[c],e=str(d,i),e&&h.push(quote(d)+(gap?\": \":\":\")+e))}else for(d in i)Object.prototype.hasOwnProperty.call(i,d)&&(e=str(d,i),e&&h.push(quote(d)+(gap?\": \":\":\")+e));e=h.length===0?\"{}\":gap?\"{\\n\"+gap+h.join(\",\\n\"+gap)+\"\\n\"+g+\"}\":\"{\"+h.join(\",\")+\"}\",gap=g;return e}}function quote(a){escapable.lastIndex=0;return escapable.test(a)?'\"'+a.replace(escapable,function(a){var b=meta[a];return typeof b==\"string\"?b:\"\\\\u\"+(\"0000\"+a.charCodeAt(0).toString(16)).slice(-4)})+'\"':'\"'+a+'\"'}function f(a){return a<10?\"0\"+a:a}\"use strict\",typeof Date.prototype.toJSON!=\"function\"&&(Date.prototype.toJSON=function(a){return isFinite(this.valueOf())?this.getUTCFullYear()+\"-\"+f(this.getUTCMonth()+1)+\"-\"+f(this.getUTCDate())+\"T\"+f(this.getUTCHours())+\":\"+f(this.getUTCMinutes())+\":\"+f(this.getUTCSeconds())+\"Z\":null},String.prototype.toJSON=Number.prototype.toJSON=Boolean.prototype.toJSON=function(a){return this.valueOf()});var cx=/[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,escapable=/[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,gap,indent,meta={\"\\b\":\"\\\\b\",\"\\t\":\"\\\\t\",\"\\n\":\"\\\\n\",\"\\f\":\"\\\\f\",\"\\r\":\"\\\\r\",'\"':'\\\\\"',\"\\\\\":\"\\\\\\\\\"},rep;typeof JSON.stringify!=\"function\"&&(JSON.stringify=function(a,b,c){var d;gap=\"\",indent=\"\";if(typeof c==\"number\")for(d=0;d<c;d+=1)indent+=\" \";else typeof c==\"string\"&&(indent=c);rep=b;if(!b||typeof b==\"function\"||typeof b==\"object\"&&typeof b.length==\"number\")return str(\"\",{\"\":a});throw new Error(\"JSON.stringify\")}),typeof JSON.parse!=\"function\"&&(JSON.parse=function(text,reviver){function walk(a,b){var c,d,e=a[b];if(e&&typeof e==\"object\")for(c in e)Object.prototype.hasOwnProperty.call(e,c)&&(d=walk(e,c),d!==undefined?e[c]=d:delete e[c]);return reviver.call(a,b,e)}var j;text=String(text),cx.lastIndex=0,cx.test(text)&&(text=text.replace(cx,function(a){return\"\\\\u\"+(\"0000\"+a.charCodeAt(0).toString(16)).slice(-4)}));if(/^[\\],:{}\\s]*$/.test(text.replace(/\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g,\"@\").replace(/\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g,\"]\").replace(/(?:^|:|,)(?:\\s*\\[)+/g,\"\"))){j=eval(\"(\"+text+\")\");return typeof reviver==\"function\"?walk({\"\":j},\"\"):j}throw new SyntaxError(\"JSON.parse\")})}()\n\n\n//     [*] Including lib/index.js\n// Public object\nvar SockJS = (function(){\n              var _document = document;\n              var _window = window;\n              var utils = {};\n\n\n//         [*] Including lib/reventtarget.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\n/* Simplified implementation of DOM2 EventTarget.\n *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget\n */\nvar REventTarget = function() {};\nREventTarget.prototype.addEventListener = function (eventType, listener) {\n    if(!this._listeners) {\n         this._listeners = {};\n    }\n    if(!(eventType in this._listeners)) {\n        this._listeners[eventType] = [];\n    }\n    var arr = this._listeners[eventType];\n    if(utils.arrIndexOf(arr, listener) === -1) {\n        arr.push(listener);\n    }\n    return;\n};\n\nREventTarget.prototype.removeEventListener = function (eventType, listener) {\n    if(!(this._listeners && (eventType in this._listeners))) {\n        return;\n    }\n    var arr = this._listeners[eventType];\n    var idx = utils.arrIndexOf(arr, listener);\n    if (idx !== -1) {\n        if(arr.length > 1) {\n            this._listeners[eventType] = arr.slice(0, idx).concat( arr.slice(idx+1) );\n        } else {\n            delete this._listeners[eventType];\n        }\n        return;\n    }\n    return;\n};\n\nREventTarget.prototype.dispatchEvent = function (event) {\n    var t = event.type;\n    var args = Array.prototype.slice.call(arguments, 0);\n    if (this['on'+t]) {\n        this['on'+t].apply(this, args);\n    }\n    if (this._listeners && t in this._listeners) {\n        for(var i=0; i < this._listeners[t].length; i++) {\n            this._listeners[t][i].apply(this, args);\n        }\n    }\n};\n//         [*] End of lib/reventtarget.js\n\n\n//         [*] Including lib/simpleevent.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar SimpleEvent = function(type, obj) {\n    this.type = type;\n    if (typeof obj !== 'undefined') {\n        for(var k in obj) {\n            if (!obj.hasOwnProperty(k)) continue;\n            this[k] = obj[k];\n        }\n    }\n};\n\nSimpleEvent.prototype.toString = function() {\n    var r = [];\n    for(var k in this) {\n        if (!this.hasOwnProperty(k)) continue;\n        var v = this[k];\n        if (typeof v === 'function') v = '[function]';\n        r.push(k + '=' + v);\n    }\n    return 'SimpleEvent(' + r.join(', ') + ')';\n};\n//         [*] End of lib/simpleevent.js\n\n\n//         [*] Including lib/eventemitter.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar EventEmitter = function(events) {\n    this.events = events || [];\n};\nEventEmitter.prototype.emit = function(type) {\n    var that = this;\n    var args = Array.prototype.slice.call(arguments, 1);\n    if (!that.nuked && that['on'+type]) {\n        that['on'+type].apply(that, args);\n    }\n    if (utils.arrIndexOf(that.events, type) === -1) {\n        utils.log('Event ' + JSON.stringify(type) +\n                  ' not listed ' + JSON.stringify(that.events) +\n                  ' in ' + that);\n    }\n};\n\nEventEmitter.prototype.nuke = function(type) {\n    var that = this;\n    that.nuked = true;\n    for(var i=0; i<that.events.length; i++) {\n        delete that[that.events[i]];\n    }\n};\n//         [*] End of lib/eventemitter.js\n\n\n//         [*] Including lib/utils.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar random_string_chars = 'abcdefghijklmnopqrstuvwxyz0123456789_';\nutils.random_string = function(length, max) {\n    max = max || random_string_chars.length;\n    var i, ret = [];\n    for(i=0; i < length; i++) {\n        ret.push( random_string_chars.substr(Math.floor(Math.random() * max),1) );\n    }\n    return ret.join('');\n};\nutils.random_number = function(max) {\n    return Math.floor(Math.random() * max);\n};\nutils.random_number_string = function(max) {\n    var t = (''+(max - 1)).length;\n    var p = Array(t+1).join('0');\n    return (p + utils.random_number(max)).slice(-t);\n};\n\n// Assuming that url looks like: http://asdasd:111/asd\nutils.getOrigin = function(url) {\n    url += '/';\n    var parts = url.split('/').slice(0, 3);\n    return parts.join('/');\n};\n\nutils.isSameOriginUrl = function(url_a, url_b) {\n    // location.origin would do, but it's not always available.\n    if (!url_b) url_b = _window.location.href;\n\n    return (url_a.split('/').slice(0,3).join('/')\n                ===\n            url_b.split('/').slice(0,3).join('/'));\n};\n\nutils.getParentDomain = function(url) {\n    // ipv4 ip address\n    if (/^[0-9.]*$/.test(url)) return url;\n    // ipv6 ip address\n    if (/^\\[/.test(url)) return url;\n    // no dots\n    if (!(/[.]/.test(url))) return url;\n\n    var parts = url.split('.').slice(1);\n    return parts.join('.');\n};\n\nutils.objectExtend = function(dst, src) {\n    for(var k in src) {\n        if (src.hasOwnProperty(k)) {\n            dst[k] = src[k];\n        }\n    }\n    return dst;\n};\n\nvar WPrefix = '_jp';\n\nutils.polluteGlobalNamespace = function() {\n    if (!(WPrefix in _window)) {\n        _window[WPrefix] = {};\n    }\n};\n\nutils.closeFrame = function (code, reason) {\n    return 'c'+JSON.stringify([code, reason]);\n};\n\nutils.userSetCode = function (code) {\n    return code === 1000 || (code >= 3000 && code <= 4999);\n};\n\n// See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/\n// and RFC 2988.\nutils.countRTO = function (rtt) {\n    var rto;\n    if (rtt > 100) {\n        rto = 3 * rtt; // rto > 300msec\n    } else {\n        rto = rtt + 200; // 200msec < rto <= 300msec\n    }\n    return rto;\n}\n\nutils.log = function() {\n    if (_window.console && console.log && console.log.apply) {\n        console.log.apply(console, arguments);\n    }\n};\n\nutils.bind = function(fun, that) {\n    if (fun.bind) {\n        return fun.bind(that);\n    } else {\n        return function() {\n            return fun.apply(that, arguments);\n        };\n    }\n};\n\nutils.flatUrl = function(url) {\n    return url.indexOf('?') === -1 && url.indexOf('#') === -1;\n};\n\nutils.amendUrl = function(url) {\n    var dl = _document.location;\n    if (!url) {\n        throw new Error('Wrong url for SockJS');\n    }\n    if (!utils.flatUrl(url)) {\n        throw new Error('Only basic urls are supported in SockJS');\n    }\n\n    //  '//abc' --> 'http://abc'\n    if (url.indexOf('//') === 0) {\n        url = dl.protocol + url;\n    }\n    // '/abc' --> 'http://localhost:80/abc'\n    if (url.indexOf('/') === 0) {\n        url = dl.protocol + '//' + dl.host + url;\n    }\n    // strip trailing slashes\n    url = url.replace(/[/]+$/,'');\n    return url;\n};\n\n// IE doesn't support [].indexOf.\nutils.arrIndexOf = function(arr, obj){\n    for(var i=0; i < arr.length; i++){\n        if(arr[i] === obj){\n            return i;\n        }\n    }\n    return -1;\n};\n\nutils.arrSkip = function(arr, obj) {\n    var idx = utils.arrIndexOf(arr, obj);\n    if (idx === -1) {\n        return arr.slice();\n    } else {\n        var dst = arr.slice(0, idx);\n        return dst.concat(arr.slice(idx+1));\n    }\n};\n\n// Via: https://gist.github.com/1133122/2121c601c5549155483f50be3da5305e83b8c5df\nutils.isArray = Array.isArray || function(value) {\n    return {}.toString.call(value).indexOf('Array') >= 0\n};\n\nutils.delay = function(t, fun) {\n    if(typeof t === 'function') {\n        fun = t;\n        t = 0;\n    }\n    return setTimeout(fun, t);\n};\n\n\n// Chars worth escaping, as defined by Douglas Crockford:\n//   https://github.com/douglascrockford/JSON-js/blob/47a9882cddeb1e8529e07af9736218075372b8ac/json2.js#L196\nvar json_escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    json_lookup = {\n\"\\u0000\":\"\\\\u0000\",\"\\u0001\":\"\\\\u0001\",\"\\u0002\":\"\\\\u0002\",\"\\u0003\":\"\\\\u0003\",\n\"\\u0004\":\"\\\\u0004\",\"\\u0005\":\"\\\\u0005\",\"\\u0006\":\"\\\\u0006\",\"\\u0007\":\"\\\\u0007\",\n\"\\b\":\"\\\\b\",\"\\t\":\"\\\\t\",\"\\n\":\"\\\\n\",\"\\u000b\":\"\\\\u000b\",\"\\f\":\"\\\\f\",\"\\r\":\"\\\\r\",\n\"\\u000e\":\"\\\\u000e\",\"\\u000f\":\"\\\\u000f\",\"\\u0010\":\"\\\\u0010\",\"\\u0011\":\"\\\\u0011\",\n\"\\u0012\":\"\\\\u0012\",\"\\u0013\":\"\\\\u0013\",\"\\u0014\":\"\\\\u0014\",\"\\u0015\":\"\\\\u0015\",\n\"\\u0016\":\"\\\\u0016\",\"\\u0017\":\"\\\\u0017\",\"\\u0018\":\"\\\\u0018\",\"\\u0019\":\"\\\\u0019\",\n\"\\u001a\":\"\\\\u001a\",\"\\u001b\":\"\\\\u001b\",\"\\u001c\":\"\\\\u001c\",\"\\u001d\":\"\\\\u001d\",\n\"\\u001e\":\"\\\\u001e\",\"\\u001f\":\"\\\\u001f\",\"\\\"\":\"\\\\\\\"\",\"\\\\\":\"\\\\\\\\\",\n\"\\u007f\":\"\\\\u007f\",\"\\u0080\":\"\\\\u0080\",\"\\u0081\":\"\\\\u0081\",\"\\u0082\":\"\\\\u0082\",\n\"\\u0083\":\"\\\\u0083\",\"\\u0084\":\"\\\\u0084\",\"\\u0085\":\"\\\\u0085\",\"\\u0086\":\"\\\\u0086\",\n\"\\u0087\":\"\\\\u0087\",\"\\u0088\":\"\\\\u0088\",\"\\u0089\":\"\\\\u0089\",\"\\u008a\":\"\\\\u008a\",\n\"\\u008b\":\"\\\\u008b\",\"\\u008c\":\"\\\\u008c\",\"\\u008d\":\"\\\\u008d\",\"\\u008e\":\"\\\\u008e\",\n\"\\u008f\":\"\\\\u008f\",\"\\u0090\":\"\\\\u0090\",\"\\u0091\":\"\\\\u0091\",\"\\u0092\":\"\\\\u0092\",\n\"\\u0093\":\"\\\\u0093\",\"\\u0094\":\"\\\\u0094\",\"\\u0095\":\"\\\\u0095\",\"\\u0096\":\"\\\\u0096\",\n\"\\u0097\":\"\\\\u0097\",\"\\u0098\":\"\\\\u0098\",\"\\u0099\":\"\\\\u0099\",\"\\u009a\":\"\\\\u009a\",\n\"\\u009b\":\"\\\\u009b\",\"\\u009c\":\"\\\\u009c\",\"\\u009d\":\"\\\\u009d\",\"\\u009e\":\"\\\\u009e\",\n\"\\u009f\":\"\\\\u009f\",\"\\u00ad\":\"\\\\u00ad\",\"\\u0600\":\"\\\\u0600\",\"\\u0601\":\"\\\\u0601\",\n\"\\u0602\":\"\\\\u0602\",\"\\u0603\":\"\\\\u0603\",\"\\u0604\":\"\\\\u0604\",\"\\u070f\":\"\\\\u070f\",\n\"\\u17b4\":\"\\\\u17b4\",\"\\u17b5\":\"\\\\u17b5\",\"\\u200c\":\"\\\\u200c\",\"\\u200d\":\"\\\\u200d\",\n\"\\u200e\":\"\\\\u200e\",\"\\u200f\":\"\\\\u200f\",\"\\u2028\":\"\\\\u2028\",\"\\u2029\":\"\\\\u2029\",\n\"\\u202a\":\"\\\\u202a\",\"\\u202b\":\"\\\\u202b\",\"\\u202c\":\"\\\\u202c\",\"\\u202d\":\"\\\\u202d\",\n\"\\u202e\":\"\\\\u202e\",\"\\u202f\":\"\\\\u202f\",\"\\u2060\":\"\\\\u2060\",\"\\u2061\":\"\\\\u2061\",\n\"\\u2062\":\"\\\\u2062\",\"\\u2063\":\"\\\\u2063\",\"\\u2064\":\"\\\\u2064\",\"\\u2065\":\"\\\\u2065\",\n\"\\u2066\":\"\\\\u2066\",\"\\u2067\":\"\\\\u2067\",\"\\u2068\":\"\\\\u2068\",\"\\u2069\":\"\\\\u2069\",\n\"\\u206a\":\"\\\\u206a\",\"\\u206b\":\"\\\\u206b\",\"\\u206c\":\"\\\\u206c\",\"\\u206d\":\"\\\\u206d\",\n\"\\u206e\":\"\\\\u206e\",\"\\u206f\":\"\\\\u206f\",\"\\ufeff\":\"\\\\ufeff\",\"\\ufff0\":\"\\\\ufff0\",\n\"\\ufff1\":\"\\\\ufff1\",\"\\ufff2\":\"\\\\ufff2\",\"\\ufff3\":\"\\\\ufff3\",\"\\ufff4\":\"\\\\ufff4\",\n\"\\ufff5\":\"\\\\ufff5\",\"\\ufff6\":\"\\\\ufff6\",\"\\ufff7\":\"\\\\ufff7\",\"\\ufff8\":\"\\\\ufff8\",\n\"\\ufff9\":\"\\\\ufff9\",\"\\ufffa\":\"\\\\ufffa\",\"\\ufffb\":\"\\\\ufffb\",\"\\ufffc\":\"\\\\ufffc\",\n\"\\ufffd\":\"\\\\ufffd\",\"\\ufffe\":\"\\\\ufffe\",\"\\uffff\":\"\\\\uffff\"};\n\n// Some extra characters that Chrome gets wrong, and substitutes with\n// something else on the wire.\nvar extra_escapable = /[\\x00-\\x1f\\ud800-\\udfff\\ufffe\\uffff\\u0300-\\u0333\\u033d-\\u0346\\u034a-\\u034c\\u0350-\\u0352\\u0357-\\u0358\\u035c-\\u0362\\u0374\\u037e\\u0387\\u0591-\\u05af\\u05c4\\u0610-\\u0617\\u0653-\\u0654\\u0657-\\u065b\\u065d-\\u065e\\u06df-\\u06e2\\u06eb-\\u06ec\\u0730\\u0732-\\u0733\\u0735-\\u0736\\u073a\\u073d\\u073f-\\u0741\\u0743\\u0745\\u0747\\u07eb-\\u07f1\\u0951\\u0958-\\u095f\\u09dc-\\u09dd\\u09df\\u0a33\\u0a36\\u0a59-\\u0a5b\\u0a5e\\u0b5c-\\u0b5d\\u0e38-\\u0e39\\u0f43\\u0f4d\\u0f52\\u0f57\\u0f5c\\u0f69\\u0f72-\\u0f76\\u0f78\\u0f80-\\u0f83\\u0f93\\u0f9d\\u0fa2\\u0fa7\\u0fac\\u0fb9\\u1939-\\u193a\\u1a17\\u1b6b\\u1cda-\\u1cdb\\u1dc0-\\u1dcf\\u1dfc\\u1dfe\\u1f71\\u1f73\\u1f75\\u1f77\\u1f79\\u1f7b\\u1f7d\\u1fbb\\u1fbe\\u1fc9\\u1fcb\\u1fd3\\u1fdb\\u1fe3\\u1feb\\u1fee-\\u1fef\\u1ff9\\u1ffb\\u1ffd\\u2000-\\u2001\\u20d0-\\u20d1\\u20d4-\\u20d7\\u20e7-\\u20e9\\u2126\\u212a-\\u212b\\u2329-\\u232a\\u2adc\\u302b-\\u302c\\uaab2-\\uaab3\\uf900-\\ufa0d\\ufa10\\ufa12\\ufa15-\\ufa1e\\ufa20\\ufa22\\ufa25-\\ufa26\\ufa2a-\\ufa2d\\ufa30-\\ufa6d\\ufa70-\\ufad9\\ufb1d\\ufb1f\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40-\\ufb41\\ufb43-\\ufb44\\ufb46-\\ufb4e\\ufff0-\\uffff]/g,\n    extra_lookup;\n\n// JSON Quote string. Use native implementation when possible.\nvar JSONQuote = (JSON && JSON.stringify) || function(string) {\n    json_escapable.lastIndex = 0;\n    if (json_escapable.test(string)) {\n        string = string.replace(json_escapable, function(a) {\n            return json_lookup[a];\n        });\n    }\n    return '\"' + string + '\"';\n};\n\n// This may be quite slow, so let's delay until user actually uses bad\n// characters.\nvar unroll_lookup = function(escapable) {\n    var i;\n    var unrolled = {}\n    var c = []\n    for(i=0; i<65536; i++) {\n        c.push( String.fromCharCode(i) );\n    }\n    escapable.lastIndex = 0;\n    c.join('').replace(escapable, function (a) {\n        unrolled[ a ] = '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n        return '';\n    });\n    escapable.lastIndex = 0;\n    return unrolled;\n};\n\n// Quote string, also taking care of unicode characters that browsers\n// often break. Especially, take care of unicode surrogates:\n//    http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates\nutils.quote = function(string) {\n    var quoted = JSONQuote(string);\n\n    // In most cases this should be very fast and good enough.\n    extra_escapable.lastIndex = 0;\n    if(!extra_escapable.test(quoted)) {\n        return quoted;\n    }\n\n    if(!extra_lookup) extra_lookup = unroll_lookup(extra_escapable);\n\n    return quoted.replace(extra_escapable, function(a) {\n        return extra_lookup[a];\n    });\n}\n\nvar _all_protocols = ['websocket',\n                      'xdr-streaming',\n                      'xhr-streaming',\n                      'iframe-eventsource',\n                      'iframe-htmlfile',\n                      'xdr-polling',\n                      'xhr-polling',\n                      'iframe-xhr-polling',\n                      'jsonp-polling'];\n\nutils.probeProtocols = function() {\n    var probed = {};\n    for(var i=0; i<_all_protocols.length; i++) {\n        var protocol = _all_protocols[i];\n        // User can have a typo in protocol name.\n        probed[protocol] = SockJS[protocol] &&\n                           SockJS[protocol].enabled();\n    }\n    return probed;\n};\n\nutils.detectProtocols = function(probed, protocols_whitelist, info) {\n    var pe = {},\n        protocols = [];\n    if (!protocols_whitelist) protocols_whitelist = _all_protocols;\n    for(var i=0; i<protocols_whitelist.length; i++) {\n        var protocol = protocols_whitelist[i];\n        pe[protocol] = probed[protocol];\n    }\n    var maybe_push = function(protos) {\n        var proto = protos.shift();\n        if (pe[proto]) {\n            protocols.push(proto);\n        } else {\n            if (protos.length > 0) {\n                maybe_push(protos);\n            }\n        }\n    }\n\n    // 1. Websocket\n    if (info.websocket !== false) {\n        maybe_push(['websocket']);\n    }\n\n    // 2. Streaming\n    if (pe['xhr-streaming'] && !info.null_origin) {\n        protocols.push('xhr-streaming');\n    } else {\n        if (pe['xdr-streaming'] && !info.cookie_needed && !info.null_origin) {\n            protocols.push('xdr-streaming');\n        } else {\n            maybe_push(['iframe-eventsource',\n                        'iframe-htmlfile']);\n        }\n    }\n\n    // 3. Polling\n    if (pe['xhr-polling'] && !info.null_origin) {\n        protocols.push('xhr-polling');\n    } else {\n        if (pe['xdr-polling'] && !info.cookie_needed && !info.null_origin) {\n            protocols.push('xdr-polling');\n        } else {\n            maybe_push(['iframe-xhr-polling',\n                        'jsonp-polling']);\n        }\n    }\n    return protocols;\n}\n//         [*] End of lib/utils.js\n\n\n//         [*] Including lib/dom.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\n// May be used by htmlfile jsonp and transports.\nvar MPrefix = '_sockjs_global';\nutils.createHook = function() {\n    var window_id = 'a' + utils.random_string(8);\n    if (!(MPrefix in _window)) {\n        var map = {};\n        _window[MPrefix] = function(window_id) {\n            if (!(window_id in map)) {\n                map[window_id] = {\n                    id: window_id,\n                    del: function() {delete map[window_id];}\n                };\n            }\n            return map[window_id];\n        }\n    }\n    return _window[MPrefix](window_id);\n};\n\n\n\nutils.attachMessage = function(listener) {\n    utils.attachEvent('message', listener);\n};\nutils.attachEvent = function(event, listener) {\n    if (typeof _window.addEventListener !== 'undefined') {\n        _window.addEventListener(event, listener, false);\n    } else {\n        // IE quirks.\n        // According to: http://stevesouders.com/misc/test-postmessage.php\n        // the message gets delivered only to 'document', not 'window'.\n        _document.attachEvent(\"on\" + event, listener);\n        // I get 'window' for ie8.\n        _window.attachEvent(\"on\" + event, listener);\n    }\n};\n\nutils.detachMessage = function(listener) {\n    utils.detachEvent('message', listener);\n};\nutils.detachEvent = function(event, listener) {\n    if (typeof _window.addEventListener !== 'undefined') {\n        _window.removeEventListener(event, listener, false);\n    } else {\n        _document.detachEvent(\"on\" + event, listener);\n        _window.detachEvent(\"on\" + event, listener);\n    }\n};\n\n\nvar on_unload = {};\n// Things registered after beforeunload are to be called immediately.\nvar after_unload = false;\n\nvar trigger_unload_callbacks = function() {\n    for(var ref in on_unload) {\n        on_unload[ref]();\n        delete on_unload[ref];\n    };\n};\n\nvar unload_triggered = function() {\n    if(after_unload) return;\n    after_unload = true;\n    trigger_unload_callbacks();\n};\n\n// Onbeforeunload alone is not reliable. We could use only 'unload'\n// but it's not working in opera within an iframe. Let's use both.\nutils.attachEvent('beforeunload', unload_triggered);\nutils.attachEvent('unload', unload_triggered);\n\nutils.unload_add = function(listener) {\n    var ref = utils.random_string(8);\n    on_unload[ref] = listener;\n    if (after_unload) {\n        utils.delay(trigger_unload_callbacks);\n    }\n    return ref;\n};\nutils.unload_del = function(ref) {\n    if (ref in on_unload)\n        delete on_unload[ref];\n};\n\n\nutils.createIframe = function (iframe_url, error_callback) {\n    var iframe = _document.createElement('iframe');\n    var tref, unload_ref;\n    var unattach = function() {\n        clearTimeout(tref);\n        // Explorer had problems with that.\n        try {iframe.onload = null;} catch (x) {}\n        iframe.onerror = null;\n    };\n    var cleanup = function() {\n        if (iframe) {\n            unattach();\n            // This timeout makes chrome fire onbeforeunload event\n            // within iframe. Without the timeout it goes straight to\n            // onunload.\n            setTimeout(function() {\n                if(iframe) {\n                    iframe.parentNode.removeChild(iframe);\n                }\n                iframe = null;\n            }, 0);\n            utils.unload_del(unload_ref);\n        }\n    };\n    var onerror = function(r) {\n        if (iframe) {\n            cleanup();\n            error_callback(r);\n        }\n    };\n    var post = function(msg, origin) {\n        try {\n            // When the iframe is not loaded, IE raises an exception\n            // on 'contentWindow'.\n            if (iframe && iframe.contentWindow) {\n                iframe.contentWindow.postMessage(msg, origin);\n            }\n        } catch (x) {};\n    };\n\n    iframe.src = iframe_url;\n    iframe.style.display = 'none';\n    iframe.style.position = 'absolute';\n    iframe.onerror = function(){onerror('onerror');};\n    iframe.onload = function() {\n        // `onload` is triggered before scripts on the iframe are\n        // executed. Give it few seconds to actually load stuff.\n        clearTimeout(tref);\n        tref = setTimeout(function(){onerror('onload timeout');}, 2000);\n    };\n    _document.body.appendChild(iframe);\n    tref = setTimeout(function(){onerror('timeout');}, 15000);\n    unload_ref = utils.unload_add(cleanup);\n    return {\n        post: post,\n        cleanup: cleanup,\n        loaded: unattach\n    };\n};\n\nutils.createHtmlfile = function (iframe_url, error_callback) {\n    var doc = new ActiveXObject('htmlfile');\n    var tref, unload_ref;\n    var iframe;\n    var unattach = function() {\n        clearTimeout(tref);\n    };\n    var cleanup = function() {\n        if (doc) {\n            unattach();\n            utils.unload_del(unload_ref);\n            iframe.parentNode.removeChild(iframe);\n            iframe = doc = null;\n            CollectGarbage();\n        }\n    };\n    var onerror = function(r)  {\n        if (doc) {\n            cleanup();\n            error_callback(r);\n        }\n    };\n    var post = function(msg, origin) {\n        try {\n            // When the iframe is not loaded, IE raises an exception\n            // on 'contentWindow'.\n            if (iframe && iframe.contentWindow) {\n                iframe.contentWindow.postMessage(msg, origin);\n            }\n        } catch (x) {};\n    };\n\n    doc.open();\n    doc.write('<html><s' + 'cript>' +\n              'document.domain=\"' + document.domain + '\";' +\n              '</s' + 'cript></html>');\n    doc.close();\n    doc.parentWindow[WPrefix] = _window[WPrefix];\n    var c = doc.createElement('div');\n    doc.body.appendChild(c);\n    iframe = doc.createElement('iframe');\n    c.appendChild(iframe);\n    iframe.src = iframe_url;\n    tref = setTimeout(function(){onerror('timeout');}, 15000);\n    unload_ref = utils.unload_add(cleanup);\n    return {\n        post: post,\n        cleanup: cleanup,\n        loaded: unattach\n    };\n};\n//         [*] End of lib/dom.js\n\n\n//         [*] Including lib/dom2.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar AbstractXHRObject = function(){};\nAbstractXHRObject.prototype = new EventEmitter(['chunk', 'finish']);\n\nAbstractXHRObject.prototype._start = function(method, url, payload, opts) {\n    var that = this;\n\n    try {\n        that.xhr = new XMLHttpRequest();\n    } catch(x) {};\n\n    if (!that.xhr) {\n        try {\n            that.xhr = new _window.ActiveXObject('Microsoft.XMLHTTP');\n        } catch(x) {};\n    }\n    if (_window.ActiveXObject || _window.XDomainRequest) {\n        // IE8 caches even POSTs\n        url += ((url.indexOf('?') === -1) ? '?' : '&') + 't='+(+new Date);\n    }\n\n    // Explorer tends to keep connection open, even after the\n    // tab gets closed: http://bugs.jquery.com/ticket/5280\n    that.unload_ref = utils.unload_add(function(){that._cleanup(true);});\n    try {\n        that.xhr.open(method, url, true);\n    } catch(e) {\n        // IE raises an exception on wrong port.\n        that.emit('finish', 0, '');\n        that._cleanup();\n        return;\n    };\n\n    if (!opts || !opts.no_credentials) {\n        // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :\n        // \"This never affects same-site requests.\"\n        that.xhr.withCredentials = 'true';\n    }\n    if (opts && opts.headers) {\n        for(var key in opts.headers) {\n            that.xhr.setRequestHeader(key, opts.headers[key]);\n        }\n    }\n\n    that.xhr.onreadystatechange = function() {\n        if (that.xhr) {\n            var x = that.xhr;\n            switch (x.readyState) {\n            case 3:\n                // IE doesn't like peeking into responseText or status\n                // on Microsoft.XMLHTTP and readystate=3\n                try {\n                    var status = x.status;\n                    var text = x.responseText;\n                } catch (x) {};\n                // IE does return readystate == 3 for 404 answers.\n                if (text && text.length > 0) {\n                    that.emit('chunk', status, text);\n                }\n                break;\n            case 4:\n                that.emit('finish', x.status, x.responseText);\n                that._cleanup(false);\n                break;\n            }\n        }\n    };\n    that.xhr.send(payload);\n};\n\nAbstractXHRObject.prototype._cleanup = function(abort) {\n    var that = this;\n    if (!that.xhr) return;\n    utils.unload_del(that.unload_ref);\n\n    // IE needs this field to be a function\n    that.xhr.onreadystatechange = function(){};\n\n    if (abort) {\n        try {\n            that.xhr.abort();\n        } catch(x) {};\n    }\n    that.unload_ref = that.xhr = null;\n};\n\nAbstractXHRObject.prototype.close = function() {\n    var that = this;\n    that.nuke();\n    that._cleanup(true);\n};\n\nvar XHRCorsObject = utils.XHRCorsObject = function() {\n    var that = this, args = arguments;\n    utils.delay(function(){that._start.apply(that, args);});\n};\nXHRCorsObject.prototype = new AbstractXHRObject();\n\nvar XHRLocalObject = utils.XHRLocalObject = function(method, url, payload) {\n    var that = this;\n    utils.delay(function(){\n        that._start(method, url, payload, {\n            no_credentials: true\n        });\n    });\n};\nXHRLocalObject.prototype = new AbstractXHRObject();\n\n\n\n// References:\n//   http://ajaxian.com/archives/100-line-ajax-wrapper\n//   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx\nvar XDRObject = utils.XDRObject = function(method, url, payload) {\n    var that = this;\n    utils.delay(function(){that._start(method, url, payload);});\n};\nXDRObject.prototype = new EventEmitter(['chunk', 'finish']);\nXDRObject.prototype._start = function(method, url, payload) {\n    var that = this;\n    var xdr = new XDomainRequest();\n    // IE caches even POSTs\n    url += ((url.indexOf('?') === -1) ? '?' : '&') + 't='+(+new Date);\n\n    var onerror = xdr.ontimeout = xdr.onerror = function() {\n        that.emit('finish', 0, '');\n        that._cleanup(false);\n    };\n    xdr.onprogress = function() {\n        that.emit('chunk', 200, xdr.responseText);\n    };\n    xdr.onload = function() {\n        that.emit('finish', 200, xdr.responseText);\n        that._cleanup(false);\n    };\n    that.xdr = xdr;\n    that.unload_ref = utils.unload_add(function(){that._cleanup(true);});\n    try {\n        // Fails with AccessDenied if port number is bogus\n        that.xdr.open(method, url);\n        that.xdr.send(payload);\n    } catch(x) {\n        onerror();\n    }\n};\n\nXDRObject.prototype._cleanup = function(abort) {\n    var that = this;\n    if (!that.xdr) return;\n    utils.unload_del(that.unload_ref);\n\n    that.xdr.ontimeout = that.xdr.onerror = that.xdr.onprogress =\n        that.xdr.onload = null;\n    if (abort) {\n        try {\n            that.xdr.abort();\n        } catch(x) {};\n    }\n    that.unload_ref = that.xdr = null;\n};\n\nXDRObject.prototype.close = function() {\n    var that = this;\n    that.nuke();\n    that._cleanup(true);\n};\n\n// 1. Is natively via XHR\n// 2. Is natively via XDR\n// 3. Nope, but postMessage is there so it should work via the Iframe.\n// 4. Nope, sorry.\nutils.isXHRCorsCapable = function() {\n    if (_window.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest()) {\n        return 1;\n    }\n    // XDomainRequest doesn't work if page is served from file://\n    if (_window.XDomainRequest && _document.domain) {\n        return 2;\n    }\n    if (IframeTransport.enabled()) {\n        return 3;\n    }\n    return 4;\n};\n//         [*] End of lib/dom2.js\n\n\n//         [*] Including lib/sockjs.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar SockJS = function(url, dep_protocols_whitelist, options) {\n    if (this === window) {\n        // makes `new` optional\n        return new SockJS(url, dep_protocols_whitelist, options);\n    }\n    \n    var that = this, protocols_whitelist;\n    that._options = {devel: false, debug: false, protocols_whitelist: [],\n                     info: undefined, rtt: undefined};\n    if (options) {\n        utils.objectExtend(that._options, options);\n    }\n    that._base_url = utils.amendUrl(url);\n    that._server = that._options.server || utils.random_number_string(1000);\n    if (that._options.protocols_whitelist &&\n        that._options.protocols_whitelist.length) {\n        protocols_whitelist = that._options.protocols_whitelist;\n    } else {\n        // Deprecated API\n        if (typeof dep_protocols_whitelist === 'string' &&\n            dep_protocols_whitelist.length > 0) {\n            protocols_whitelist = [dep_protocols_whitelist];\n        } else if (utils.isArray(dep_protocols_whitelist)) {\n            protocols_whitelist = dep_protocols_whitelist\n        } else {\n            protocols_whitelist = null;\n        }\n        if (protocols_whitelist) {\n            that._debug('Deprecated API: Use \"protocols_whitelist\" option ' +\n                        'instead of supplying protocol list as a second ' +\n                        'parameter to SockJS constructor.');\n        }\n    }\n    that._protocols = [];\n    that.protocol = null;\n    that.readyState = SockJS.CONNECTING;\n    that._ir = createInfoReceiver(that._base_url);\n    that._ir.onfinish = function(info, rtt) {\n        that._ir = null;\n        if (info) {\n            if (that._options.info) {\n                // Override if user supplies the option\n                info = utils.objectExtend(info, that._options.info);\n            }\n            if (that._options.rtt) {\n                rtt = that._options.rtt;\n            }\n            that._applyInfo(info, rtt, protocols_whitelist);\n            that._didClose();\n        } else {\n            that._didClose(1002, 'Can\\'t connect to server', true);\n        }\n    };\n};\n// Inheritance\nSockJS.prototype = new REventTarget();\n\nSockJS.version = \"0.3.1.7.ga67f.dirty\";\n\nSockJS.CONNECTING = 0;\nSockJS.OPEN = 1;\nSockJS.CLOSING = 2;\nSockJS.CLOSED = 3;\n\nSockJS.prototype._debug = function() {\n    if (this._options.debug)\n        utils.log.apply(utils, arguments);\n};\n\nSockJS.prototype._dispatchOpen = function() {\n    var that = this;\n    if (that.readyState === SockJS.CONNECTING) {\n        if (that._transport_tref) {\n            clearTimeout(that._transport_tref);\n            that._transport_tref = null;\n        }\n        that.readyState = SockJS.OPEN;\n        that.dispatchEvent(new SimpleEvent(\"open\"));\n    } else {\n        // The server might have been restarted, and lost track of our\n        // connection.\n        that._didClose(1006, \"Server lost session\");\n    }\n};\n\nSockJS.prototype._dispatchMessage = function(data) {\n    var that = this;\n    if (that.readyState !== SockJS.OPEN)\n            return;\n    that.dispatchEvent(new SimpleEvent(\"message\", {data: data}));\n};\n\nSockJS.prototype._dispatchHeartbeat = function(data) {\n    var that = this;\n    if (that.readyState !== SockJS.OPEN)\n        return;\n    that.dispatchEvent(new SimpleEvent('heartbeat', {}));\n};\n\nSockJS.prototype._didClose = function(code, reason, force) {\n    var that = this;\n    if (that.readyState !== SockJS.CONNECTING &&\n        that.readyState !== SockJS.OPEN &&\n        that.readyState !== SockJS.CLOSING)\n            throw new Error('INVALID_STATE_ERR');\n    if (that._ir) {\n        that._ir.nuke();\n        that._ir = null;\n    }\n\n    if (that._transport) {\n        that._transport.doCleanup();\n        that._transport = null;\n    }\n\n    var close_event = new SimpleEvent(\"close\", {\n        code: code,\n        reason: reason,\n        wasClean: utils.userSetCode(code)});\n\n    if (!utils.userSetCode(code) &&\n        that.readyState === SockJS.CONNECTING && !force) {\n        if (that._try_next_protocol(close_event)) {\n            return;\n        }\n        close_event = new SimpleEvent(\"close\", {code: 2000,\n                                                reason: \"All transports failed\",\n                                                wasClean: false,\n                                                last_event: close_event});\n    }\n    that.readyState = SockJS.CLOSED;\n\n    utils.delay(function() {\n                   that.dispatchEvent(close_event);\n                });\n};\n\nSockJS.prototype._didMessage = function(data) {\n    var that = this;\n    var type = data.slice(0, 1);\n    switch(type) {\n    case 'o':\n        that._dispatchOpen();\n        break;\n    case 'a':\n        var payload = JSON.parse(data.slice(1) || '[]');\n        for(var i=0; i < payload.length; i++){\n            that._dispatchMessage(payload[i]);\n        }\n        break;\n    case 'm':\n        var payload = JSON.parse(data.slice(1) || 'null');\n        that._dispatchMessage(payload);\n        break;\n    case 'c':\n        var payload = JSON.parse(data.slice(1) || '[]');\n        that._didClose(payload[0], payload[1]);\n        break;\n    case 'h':\n        that._dispatchHeartbeat();\n        break;\n    }\n};\n\nSockJS.prototype._try_next_protocol = function(close_event) {\n    var that = this;\n    if (that.protocol) {\n        that._debug('Closed transport:', that.protocol, ''+close_event);\n        that.protocol = null;\n    }\n    if (that._transport_tref) {\n        clearTimeout(that._transport_tref);\n        that._transport_tref = null;\n    }\n\n    while(1) {\n        var protocol = that.protocol = that._protocols.shift();\n        if (!protocol) {\n            return false;\n        }\n        // Some protocols require access to `body`, what if were in\n        // the `head`?\n        if (SockJS[protocol] &&\n            SockJS[protocol].need_body === true &&\n            (!_document.body ||\n             (typeof _document.readyState !== 'undefined'\n              && _document.readyState !== 'complete'))) {\n            that._protocols.unshift(protocol);\n            that.protocol = 'waiting-for-load';\n            utils.attachEvent('load', function(){\n                that._try_next_protocol();\n            });\n            return true;\n        }\n\n        if (!SockJS[protocol] ||\n              !SockJS[protocol].enabled(that._options)) {\n            that._debug('Skipping transport:', protocol);\n        } else {\n            var roundTrips = SockJS[protocol].roundTrips || 1;\n            var to = ((that._options.rto || 0) * roundTrips) || 5000;\n            that._transport_tref = utils.delay(to, function() {\n                if (that.readyState === SockJS.CONNECTING) {\n                    // I can't understand how it is possible to run\n                    // this timer, when the state is CLOSED, but\n                    // apparently in IE everythin is possible.\n                    that._didClose(2007, \"Transport timeouted\");\n                }\n            });\n\n            var connid = utils.random_string(8);\n            var trans_url = that._base_url + '/' + that._server + '/' + connid;\n            that._debug('Opening transport:', protocol, ' url:'+trans_url,\n                        ' RTO:'+that._options.rto);\n            that._transport = new SockJS[protocol](that, trans_url,\n                                                   that._base_url);\n            return true;\n        }\n    }\n};\n\nSockJS.prototype.close = function(code, reason) {\n    var that = this;\n    if (code && !utils.userSetCode(code))\n        throw new Error(\"INVALID_ACCESS_ERR\");\n    if(that.readyState !== SockJS.CONNECTING &&\n       that.readyState !== SockJS.OPEN) {\n        return false;\n    }\n    that.readyState = SockJS.CLOSING;\n    that._didClose(code || 1000, reason || \"Normal closure\");\n    return true;\n};\n\nSockJS.prototype.send = function(data) {\n    var that = this;\n    if (that.readyState === SockJS.CONNECTING)\n        throw new Error('INVALID_STATE_ERR');\n    if (that.readyState === SockJS.OPEN) {\n        that._transport.doSend(utils.quote('' + data));\n    }\n    return true;\n};\n\nSockJS.prototype._applyInfo = function(info, rtt, protocols_whitelist) {\n    var that = this;\n    that._options.info = info;\n    that._options.rtt = rtt;\n    that._options.rto = utils.countRTO(rtt);\n    that._options.info.null_origin = !_document.domain;\n    var probed = utils.probeProtocols();\n    that._protocols = utils.detectProtocols(probed, protocols_whitelist, info);\n};\n//         [*] End of lib/sockjs.js\n\n\n//         [*] Including lib/trans-websocket.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar WebSocketTransport = SockJS.websocket = function(ri, trans_url) {\n    var that = this;\n    var url = trans_url + '/websocket';\n    if (url.slice(0, 5) === 'https') {\n        url = 'wss' + url.slice(5);\n    } else {\n        url = 'ws' + url.slice(4);\n    }\n    that.ri = ri;\n    that.url = url;\n    var Constructor = _window.WebSocket || _window.MozWebSocket;\n\n    that.ws = new Constructor(that.url);\n    that.ws.onmessage = function(e) {\n        that.ri._didMessage(e.data);\n    };\n    // Firefox has an interesting bug. If a websocket connection is\n    // created after onbeforeunload, it stays alive even when user\n    // navigates away from the page. In such situation let's lie -\n    // let's not open the ws connection at all. See:\n    // https://github.com/sockjs/sockjs-client/issues/28\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=696085\n    that.unload_ref = utils.unload_add(function(){that.ws.close()});\n    that.ws.onclose = function() {\n        that.ri._didMessage(utils.closeFrame(1006, \"WebSocket connection broken\"));\n    };\n};\n\nWebSocketTransport.prototype.doSend = function(data) {\n    this.ws.send('[' + data + ']');\n};\n\nWebSocketTransport.prototype.doCleanup = function() {\n    var that = this;\n    var ws = that.ws;\n    if (ws) {\n        ws.onmessage = ws.onclose = null;\n        ws.close();\n        utils.unload_del(that.unload_ref);\n        that.unload_ref = that.ri = that.ws = null;\n    }\n};\n\nWebSocketTransport.enabled = function() {\n    return !!(_window.WebSocket || _window.MozWebSocket);\n};\n\n// In theory, ws should require 1 round trip. But in chrome, this is\n// not very stable over SSL. Most likely a ws connection requires a\n// separate SSL connection, in which case 2 round trips are an\n// absolute minumum.\nWebSocketTransport.roundTrips = 2;\n//         [*] End of lib/trans-websocket.js\n\n\n//         [*] Including lib/trans-sender.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar BufferedSender = function() {};\nBufferedSender.prototype.send_constructor = function(sender) {\n    var that = this;\n    that.send_buffer = [];\n    that.sender = sender;\n};\nBufferedSender.prototype.doSend = function(message) {\n    var that = this;\n    that.send_buffer.push(message);\n    if (!that.send_stop) {\n        that.send_schedule();\n    }\n};\n\n// For polling transports in a situation when in the message callback,\n// new message is being send. If the sending connection was started\n// before receiving one, it is possible to saturate the network and\n// timeout due to the lack of receiving socket. To avoid that we delay\n// sending messages by some small time, in order to let receiving\n// connection be started beforehand. This is only a halfmeasure and\n// does not fix the big problem, but it does make the tests go more\n// stable on slow networks.\nBufferedSender.prototype.send_schedule_wait = function() {\n    var that = this;\n    var tref;\n    that.send_stop = function() {\n        that.send_stop = null;\n        clearTimeout(tref);\n    };\n    tref = utils.delay(25, function() {\n        that.send_stop = null;\n        that.send_schedule();\n    });\n};\n\nBufferedSender.prototype.send_schedule = function() {\n    var that = this;\n    if (that.send_buffer.length > 0) {\n        var payload = '[' + that.send_buffer.join(',') + ']';\n        that.send_stop = that.sender(that.trans_url,\n                                     payload,\n                                     function() {\n                                         that.send_stop = null;\n                                         that.send_schedule_wait();\n                                     });\n        that.send_buffer = [];\n    }\n};\n\nBufferedSender.prototype.send_destructor = function() {\n    var that = this;\n    if (that._send_stop) {\n        that._send_stop();\n    }\n    that._send_stop = null;\n};\n\nvar jsonPGenericSender = function(url, payload, callback) {\n    var that = this;\n\n    if (!('_send_form' in that)) {\n        var form = that._send_form = _document.createElement('form');\n        var area = that._send_area = _document.createElement('textarea');\n        area.name = 'd';\n        form.style.display = 'none';\n        form.style.position = 'absolute';\n        form.method = 'POST';\n        form.enctype = 'application/x-www-form-urlencoded';\n        form.acceptCharset = \"UTF-8\";\n        form.appendChild(area);\n        _document.body.appendChild(form);\n    }\n    var form = that._send_form;\n    var area = that._send_area;\n    var id = 'a' + utils.random_string(8);\n    form.target = id;\n    form.action = url + '/jsonp_send?i=' + id;\n\n    var iframe;\n    try {\n        // ie6 dynamic iframes with target=\"\" support (thanks Chris Lambacher)\n        iframe = _document.createElement('<iframe name=\"'+ id +'\">');\n    } catch(x) {\n        iframe = _document.createElement('iframe');\n        iframe.name = id;\n    }\n    iframe.id = id;\n    form.appendChild(iframe);\n    iframe.style.display = 'none';\n\n    try {\n        area.value = payload;\n    } catch(e) {\n        utils.log('Your browser is seriously broken. Go home! ' + e.message);\n    }\n    form.submit();\n\n    var completed = function(e) {\n        if (!iframe.onerror) return;\n        iframe.onreadystatechange = iframe.onerror = iframe.onload = null;\n        // Opera mini doesn't like if we GC iframe\n        // immediately, thus this timeout.\n        utils.delay(500, function() {\n                       iframe.parentNode.removeChild(iframe);\n                       iframe = null;\n                   });\n        area.value = '';\n        callback();\n    };\n    iframe.onerror = iframe.onload = completed;\n    iframe.onreadystatechange = function(e) {\n        if (iframe.readyState == 'complete') completed();\n    };\n    return completed;\n};\n\nvar createAjaxSender = function(AjaxObject) {\n    return function(url, payload, callback) {\n        var xo = new AjaxObject('POST', url + '/xhr_send', payload);\n        xo.onfinish = function(status, text) {\n            callback(status);\n        };\n        return function(abort_reason) {\n            callback(0, abort_reason);\n        };\n    };\n};\n//         [*] End of lib/trans-sender.js\n\n\n//         [*] Including lib/trans-jsonp-receiver.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\n// Parts derived from Socket.io:\n//    https://github.com/LearnBoost/socket.io/blob/0.6.17/lib/socket.io/transports/jsonp-polling.js\n// and jQuery-JSONP:\n//    https://code.google.com/p/jquery-jsonp/source/browse/trunk/core/jquery.jsonp.js\nvar jsonPGenericReceiver = function(url, callback) {\n    var tref;\n    var script = _document.createElement('script');\n    var script2;  // Opera synchronous load trick.\n    var close_script = function(frame) {\n        if (script2) {\n            script2.parentNode.removeChild(script2);\n            script2 = null;\n        }\n        if (script) {\n            clearTimeout(tref);\n            script.parentNode.removeChild(script);\n            script.onreadystatechange = script.onerror =\n                script.onload = script.onclick = null;\n            script = null;\n            callback(frame);\n            callback = null;\n        }\n    };\n\n    // IE9 fires 'error' event after orsc or before, in random order.\n    var loaded_okay = false;\n    var error_timer = null;\n\n    script.id = 'a' + utils.random_string(8);\n    script.src = url;\n    script.type = 'text/javascript';\n    script.charset = 'UTF-8';\n    script.onerror = function(e) {\n        if (!error_timer) {\n            // Delay firing close_script.\n            error_timer = setTimeout(function() {\n                if (!loaded_okay) {\n                    close_script(utils.closeFrame(\n                        1006,\n                        \"JSONP script loaded abnormally (onerror)\"));\n                }\n            }, 1000);\n        }\n    };\n    script.onload = function(e) {\n        close_script(utils.closeFrame(1006, \"JSONP script loaded abnormally (onload)\"));\n    };\n\n    script.onreadystatechange = function(e) {\n        if (/loaded|closed/.test(script.readyState)) {\n            if (script && script.htmlFor && script.onclick) {\n                loaded_okay = true;\n                try {\n                    // In IE, actually execute the script.\n                    script.onclick();\n                } catch (x) {}\n            }\n            if (script) {\n                close_script(utils.closeFrame(1006, \"JSONP script loaded abnormally (onreadystatechange)\"));\n            }\n        }\n    };\n    // IE: event/htmlFor/onclick trick.\n    // One can't rely on proper order for onreadystatechange. In order to\n    // make sure, set a 'htmlFor' and 'event' properties, so that\n    // script code will be installed as 'onclick' handler for the\n    // script object. Later, onreadystatechange, manually execute this\n    // code. FF and Chrome doesn't work with 'event' and 'htmlFor'\n    // set. For reference see:\n    //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html\n    // Also, read on that about script ordering:\n    //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order\n    if (typeof script.async === 'undefined' && _document.attachEvent) {\n        // According to mozilla docs, in recent browsers script.async defaults\n        // to 'true', so we may use it to detect a good browser:\n        // https://developer.mozilla.org/en/HTML/Element/script\n        if (!/opera/i.test(navigator.userAgent)) {\n            // Naively assume we're in IE\n            try {\n                script.htmlFor = script.id;\n                script.event = \"onclick\";\n            } catch (x) {}\n            script.async = true;\n        } else {\n            // Opera, second sync script hack\n            script2 = _document.createElement('script');\n            script2.text = \"try{var a = document.getElementById('\"+script.id+\"'); if(a)a.onerror();}catch(x){};\";\n            script.async = script2.async = false;\n        }\n    }\n    if (typeof script.async !== 'undefined') {\n        script.async = true;\n    }\n\n    // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.\n    tref = setTimeout(function() {\n                          close_script(utils.closeFrame(1006, \"JSONP script loaded abnormally (timeout)\"));\n                      }, 35000);\n\n    var head = _document.getElementsByTagName('head')[0];\n    head.insertBefore(script, head.firstChild);\n    if (script2) {\n        head.insertBefore(script2, head.firstChild);\n    }\n    return close_script;\n};\n//         [*] End of lib/trans-jsonp-receiver.js\n\n\n//         [*] Including lib/trans-jsonp-polling.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\n// The simplest and most robust transport, using the well-know cross\n// domain hack - JSONP. This transport is quite inefficient - one\n// mssage could use up to one http request. But at least it works almost\n// everywhere.\n// Known limitations:\n//   o you will get a spinning cursor\n//   o for Konqueror a dumb timer is needed to detect errors\n\n\nvar JsonPTransport = SockJS['jsonp-polling'] = function(ri, trans_url) {\n    utils.polluteGlobalNamespace();\n    var that = this;\n    that.ri = ri;\n    that.trans_url = trans_url;\n    that.send_constructor(jsonPGenericSender);\n    that._schedule_recv();\n};\n\n// Inheritnace\nJsonPTransport.prototype = new BufferedSender();\n\nJsonPTransport.prototype._schedule_recv = function() {\n    var that = this;\n    var callback = function(data) {\n        that._recv_stop = null;\n        if (data) {\n            // no data - heartbeat;\n            if (!that._is_closing) {\n                that.ri._didMessage(data);\n            }\n        }\n        // The message can be a close message, and change is_closing state.\n        if (!that._is_closing) {\n            that._schedule_recv();\n        }\n    };\n    that._recv_stop = jsonPReceiverWrapper(that.trans_url + '/jsonp',\n                                           jsonPGenericReceiver, callback);\n};\n\nJsonPTransport.enabled = function() {\n    return true;\n};\n\nJsonPTransport.need_body = true;\n\n\nJsonPTransport.prototype.doCleanup = function() {\n    var that = this;\n    that._is_closing = true;\n    if (that._recv_stop) {\n        that._recv_stop();\n    }\n    that.ri = that._recv_stop = null;\n    that.send_destructor();\n};\n\n\n// Abstract away code that handles global namespace pollution.\nvar jsonPReceiverWrapper = function(url, constructReceiver, user_callback) {\n    var id = 'a' + utils.random_string(6);\n    var url_id = url + '?c=' + escape(WPrefix + '.' + id);\n    // Callback will be called exactly once.\n    var callback = function(frame) {\n        delete _window[WPrefix][id];\n        user_callback(frame);\n    };\n\n    var close_script = constructReceiver(url_id, callback);\n    _window[WPrefix][id] = close_script;\n    var stop = function() {\n        if (_window[WPrefix][id]) {\n            _window[WPrefix][id](utils.closeFrame(1000, \"JSONP user aborted read\"));\n        }\n    };\n    return stop;\n};\n//         [*] End of lib/trans-jsonp-polling.js\n\n\n//         [*] Including lib/trans-xhr.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar AjaxBasedTransport = function() {};\nAjaxBasedTransport.prototype = new BufferedSender();\n\nAjaxBasedTransport.prototype.run = function(ri, trans_url,\n                                            url_suffix, Receiver, AjaxObject) {\n    var that = this;\n    that.ri = ri;\n    that.trans_url = trans_url;\n    that.send_constructor(createAjaxSender(AjaxObject));\n    that.poll = new Polling(ri, Receiver,\n                            trans_url + url_suffix, AjaxObject);\n};\n\nAjaxBasedTransport.prototype.doCleanup = function() {\n    var that = this;\n    if (that.poll) {\n        that.poll.abort();\n        that.poll = null;\n    }\n};\n\n// xhr-streaming\nvar XhrStreamingTransport = SockJS['xhr-streaming'] = function(ri, trans_url) {\n    this.run(ri, trans_url, '/xhr_streaming', XhrReceiver, utils.XHRCorsObject);\n};\n\nXhrStreamingTransport.prototype = new AjaxBasedTransport();\n\nXhrStreamingTransport.enabled = function() {\n    // Support for CORS Ajax aka Ajax2? Opera 12 claims CORS but\n    // doesn't do streaming.\n    return (_window.XMLHttpRequest &&\n            'withCredentials' in new XMLHttpRequest() &&\n            (!/opera/i.test(navigator.userAgent)));\n};\nXhrStreamingTransport.roundTrips = 2; // preflight, ajax\n\n// Safari gets confused when a streaming ajax request is started\n// before onload. This causes the load indicator to spin indefinetely.\nXhrStreamingTransport.need_body = true;\n\n\n// According to:\n//   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests\n//   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/\n\n\n// xdr-streaming\nvar XdrStreamingTransport = SockJS['xdr-streaming'] = function(ri, trans_url) {\n    this.run(ri, trans_url, '/xhr_streaming', XhrReceiver, utils.XDRObject);\n};\n\nXdrStreamingTransport.prototype = new AjaxBasedTransport();\n\nXdrStreamingTransport.enabled = function() {\n    return !!_window.XDomainRequest;\n};\nXdrStreamingTransport.roundTrips = 2; // preflight, ajax\n\n\n\n// xhr-polling\nvar XhrPollingTransport = SockJS['xhr-polling'] = function(ri, trans_url) {\n    this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XHRCorsObject);\n};\n\nXhrPollingTransport.prototype = new AjaxBasedTransport();\n\nXhrPollingTransport.enabled = XhrStreamingTransport.enabled;\nXhrPollingTransport.roundTrips = 2; // preflight, ajax\n\n\n// xdr-polling\nvar XdrPollingTransport = SockJS['xdr-polling'] = function(ri, trans_url) {\n    this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XDRObject);\n};\n\nXdrPollingTransport.prototype = new AjaxBasedTransport();\n\nXdrPollingTransport.enabled = XdrStreamingTransport.enabled;\nXdrPollingTransport.roundTrips = 2; // preflight, ajax\n//         [*] End of lib/trans-xhr.js\n\n\n//         [*] Including lib/trans-iframe.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\n// Few cool transports do work only for same-origin. In order to make\n// them working cross-domain we shall use iframe, served form the\n// remote domain. New browsers, have capabilities to communicate with\n// cross domain iframe, using postMessage(). In IE it was implemented\n// from IE 8+, but of course, IE got some details wrong:\n//    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx\n//    http://stevesouders.com/misc/test-postmessage.php\n\nvar IframeTransport = function() {};\n\nIframeTransport.prototype.i_constructor = function(ri, trans_url, base_url) {\n    var that = this;\n    that.ri = ri;\n    that.origin = utils.getOrigin(base_url);\n    that.base_url = base_url;\n    that.trans_url = trans_url;\n\n    var iframe_url = base_url + '/iframe.html';\n    if (that.ri._options.devel) {\n        iframe_url += '?t=' + (+new Date);\n    }\n    that.window_id = utils.random_string(8);\n    iframe_url += '#' + that.window_id;\n\n    that.iframeObj = utils.createIframe(iframe_url, function(r) {\n                                            that.ri._didClose(1006, \"Unable to load an iframe (\" + r + \")\");\n                                        });\n\n    that.onmessage_cb = utils.bind(that.onmessage, that);\n    utils.attachMessage(that.onmessage_cb);\n};\n\nIframeTransport.prototype.doCleanup = function() {\n    var that = this;\n    if (that.iframeObj) {\n        utils.detachMessage(that.onmessage_cb);\n        try {\n            // When the iframe is not loaded, IE raises an exception\n            // on 'contentWindow'.\n            if (that.iframeObj.iframe.contentWindow) {\n                that.postMessage('c');\n            }\n        } catch (x) {}\n        that.iframeObj.cleanup();\n        that.iframeObj = null;\n        that.onmessage_cb = that.iframeObj = null;\n    }\n};\n\nIframeTransport.prototype.onmessage = function(e) {\n    var that = this;\n    if (e.origin !== that.origin) return;\n    var window_id = e.data.slice(0, 8);\n    var type = e.data.slice(8, 9);\n    var data = e.data.slice(9);\n\n    if (window_id !== that.window_id) return;\n\n    switch(type) {\n    case 's':\n        that.iframeObj.loaded();\n        that.postMessage('s', JSON.stringify([SockJS.version, that.protocol, that.trans_url, that.base_url]));\n        break;\n    case 't':\n        that.ri._didMessage(data);\n        break;\n    }\n};\n\nIframeTransport.prototype.postMessage = function(type, data) {\n    var that = this;\n    that.iframeObj.post(that.window_id + type + (data || ''), that.origin);\n};\n\nIframeTransport.prototype.doSend = function (message) {\n    this.postMessage('m', message);\n};\n\nIframeTransport.enabled = function() {\n    // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with\n    // huge delay, or not at all.\n    var konqueror = navigator && navigator.userAgent && navigator.userAgent.indexOf('Konqueror') !== -1;\n    return ((typeof _window.postMessage === 'function' ||\n            typeof _window.postMessage === 'object') && (!konqueror));\n};\n//         [*] End of lib/trans-iframe.js\n\n\n//         [*] Including lib/trans-iframe-within.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar curr_window_id;\n\nvar postMessage = function (type, data) {\n    if(parent !== _window) {\n        parent.postMessage(curr_window_id + type + (data || ''), '*');\n    } else {\n        utils.log(\"Can't postMessage, no parent window.\", type, data);\n    }\n};\n\nvar FacadeJS = function() {};\nFacadeJS.prototype._didClose = function (code, reason) {\n    postMessage('t', utils.closeFrame(code, reason));\n};\nFacadeJS.prototype._didMessage = function (frame) {\n    postMessage('t', frame);\n};\nFacadeJS.prototype._doSend = function (data) {\n    this._transport.doSend(data);\n};\nFacadeJS.prototype._doCleanup = function () {\n    this._transport.doCleanup();\n};\n\nutils.parent_origin = undefined;\n\nSockJS.bootstrap_iframe = function() {\n    var facade;\n    curr_window_id = _document.location.hash.slice(1);\n    var onMessage = function(e) {\n        if(e.source !== parent) return;\n        if(typeof utils.parent_origin === 'undefined')\n            utils.parent_origin = e.origin;\n        if (e.origin !== utils.parent_origin) return;\n\n        var window_id = e.data.slice(0, 8);\n        var type = e.data.slice(8, 9);\n        var data = e.data.slice(9);\n        if (window_id !== curr_window_id) return;\n        switch(type) {\n        case 's':\n            var p = JSON.parse(data);\n            var version = p[0];\n            var protocol = p[1];\n            var trans_url = p[2];\n            var base_url = p[3];\n            if (version !== SockJS.version) {\n                utils.log(\"Incompatibile SockJS! Main site uses:\" +\n                          \" \\\"\" + version + \"\\\", the iframe:\" +\n                          \" \\\"\" + SockJS.version + \"\\\".\");\n            }\n            if (!utils.flatUrl(trans_url) || !utils.flatUrl(base_url)) {\n                utils.log(\"Only basic urls are supported in SockJS\");\n                return;\n            }\n\n            if (!utils.isSameOriginUrl(trans_url) ||\n                !utils.isSameOriginUrl(base_url)) {\n                utils.log(\"Can't connect to different domain from within an \" +\n                          \"iframe. (\" + JSON.stringify([_window.location.href, trans_url, base_url]) +\n                          \")\");\n                return;\n            }\n            facade = new FacadeJS();\n            facade._transport = new FacadeJS[protocol](facade, trans_url, base_url);\n            break;\n        case 'm':\n            facade._doSend(data);\n            break;\n        case 'c':\n            if (facade)\n                facade._doCleanup();\n            facade = null;\n            break;\n        }\n    };\n\n    // alert('test ticker');\n    // facade = new FacadeJS();\n    // facade._transport = new FacadeJS['w-iframe-xhr-polling'](facade, 'http://host.com:9999/ticker/12/basd');\n\n    utils.attachMessage(onMessage);\n\n    // Start\n    postMessage('s');\n};\n//         [*] End of lib/trans-iframe-within.js\n\n\n//         [*] Including lib/info.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar InfoReceiver = function(base_url, AjaxObject) {\n    var that = this;\n    utils.delay(function(){that.doXhr(base_url, AjaxObject);});\n};\n\nInfoReceiver.prototype = new EventEmitter(['finish']);\n\nInfoReceiver.prototype.doXhr = function(base_url, AjaxObject) {\n    var that = this;\n    var t0 = (new Date()).getTime();\n    var xo = new AjaxObject('GET', base_url + '/info');\n\n    var tref = utils.delay(8000,\n                           function(){xo.ontimeout();});\n\n    xo.onfinish = function(status, text) {\n        clearTimeout(tref);\n        tref = null;\n        if (status === 200) {\n            var rtt = (new Date()).getTime() - t0;\n            var info = JSON.parse(text);\n            if (typeof info !== 'object') info = {};\n            that.emit('finish', info, rtt);\n        } else {\n            that.emit('finish');\n        }\n    };\n    xo.ontimeout = function() {\n        xo.close();\n        that.emit('finish');\n    };\n};\n\nvar InfoReceiverIframe = function(base_url) {\n    var that = this;\n    var go = function() {\n        var ifr = new IframeTransport();\n        ifr.protocol = 'w-iframe-info-receiver';\n        var fun = function(r) {\n            if (typeof r === 'string' && r.substr(0,1) === 'm') {\n                var d = JSON.parse(r.substr(1));\n                var info = d[0], rtt = d[1];\n                that.emit('finish', info, rtt);\n            } else {\n                that.emit('finish');\n            }\n            ifr.doCleanup();\n            ifr = null;\n        };\n        var mock_ri = {\n            _options: {},\n            _didClose: fun,\n            _didMessage: fun\n        };\n        ifr.i_constructor(mock_ri, base_url, base_url);\n    }\n    if(!_document.body) {\n        utils.attachEvent('load', go);\n    } else {\n        go();\n    }\n};\nInfoReceiverIframe.prototype = new EventEmitter(['finish']);\n\n\nvar InfoReceiverFake = function() {\n    // It may not be possible to do cross domain AJAX to get the info\n    // data, for example for IE7. But we want to run JSONP, so let's\n    // fake the response, with rtt=2s (rto=6s).\n    var that = this;\n    utils.delay(function() {\n        that.emit('finish', {}, 2000);\n    });\n};\nInfoReceiverFake.prototype = new EventEmitter(['finish']);\n\nvar createInfoReceiver = function(base_url) {\n    if (utils.isSameOriginUrl(base_url)) {\n        // If, for some reason, we have SockJS locally - there's no\n        // need to start up the complex machinery. Just use ajax.\n        return new InfoReceiver(base_url, utils.XHRLocalObject);\n    }\n    switch (utils.isXHRCorsCapable()) {\n    case 1:\n        return new InfoReceiver(base_url, utils.XHRCorsObject);\n    case 2:\n        return new InfoReceiver(base_url, utils.XDRObject);\n    case 3:\n        // Opera\n        return new InfoReceiverIframe(base_url);\n    default:\n        // IE 7\n        return new InfoReceiverFake();\n    };\n};\n\n\nvar WInfoReceiverIframe = FacadeJS['w-iframe-info-receiver'] = function(ri, _trans_url, base_url) {\n    var ir = new InfoReceiver(base_url, utils.XHRLocalObject);\n    ir.onfinish = function(info, rtt) {\n        ri._didMessage('m'+JSON.stringify([info, rtt]));\n        ri._didClose();\n    }\n};\nWInfoReceiverIframe.prototype.doCleanup = function() {};\n//         [*] End of lib/info.js\n\n\n//         [*] Including lib/trans-iframe-eventsource.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar EventSourceIframeTransport = SockJS['iframe-eventsource'] = function () {\n    var that = this;\n    that.protocol = 'w-iframe-eventsource';\n    that.i_constructor.apply(that, arguments);\n};\n\nEventSourceIframeTransport.prototype = new IframeTransport();\n\nEventSourceIframeTransport.enabled = function () {\n    return ('EventSource' in _window) && IframeTransport.enabled();\n};\n\nEventSourceIframeTransport.need_body = true;\nEventSourceIframeTransport.roundTrips = 3; // html, javascript, eventsource\n\n\n// w-iframe-eventsource\nvar EventSourceTransport = FacadeJS['w-iframe-eventsource'] = function(ri, trans_url) {\n    this.run(ri, trans_url, '/eventsource', EventSourceReceiver, utils.XHRLocalObject);\n}\nEventSourceTransport.prototype = new AjaxBasedTransport();\n//         [*] End of lib/trans-iframe-eventsource.js\n\n\n//         [*] Including lib/trans-iframe-xhr-polling.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar XhrPollingIframeTransport = SockJS['iframe-xhr-polling'] = function () {\n    var that = this;\n    that.protocol = 'w-iframe-xhr-polling';\n    that.i_constructor.apply(that, arguments);\n};\n\nXhrPollingIframeTransport.prototype = new IframeTransport();\n\nXhrPollingIframeTransport.enabled = function () {\n    return _window.XMLHttpRequest && IframeTransport.enabled();\n};\n\nXhrPollingIframeTransport.need_body = true;\nXhrPollingIframeTransport.roundTrips = 3; // html, javascript, xhr\n\n\n// w-iframe-xhr-polling\nvar XhrPollingITransport = FacadeJS['w-iframe-xhr-polling'] = function(ri, trans_url) {\n    this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XHRLocalObject);\n};\n\nXhrPollingITransport.prototype = new AjaxBasedTransport();\n//         [*] End of lib/trans-iframe-xhr-polling.js\n\n\n//         [*] Including lib/trans-iframe-htmlfile.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\n// This transport generally works in any browser, but will cause a\n// spinning cursor to appear in any browser other than IE.\n// We may test this transport in all browsers - why not, but in\n// production it should be only run in IE.\n\nvar HtmlFileIframeTransport = SockJS['iframe-htmlfile'] = function () {\n    var that = this;\n    that.protocol = 'w-iframe-htmlfile';\n    that.i_constructor.apply(that, arguments);\n};\n\n// Inheritance.\nHtmlFileIframeTransport.prototype = new IframeTransport();\n\nHtmlFileIframeTransport.enabled = function() {\n    return IframeTransport.enabled();\n};\n\nHtmlFileIframeTransport.need_body = true;\nHtmlFileIframeTransport.roundTrips = 3; // html, javascript, htmlfile\n\n\n// w-iframe-htmlfile\nvar HtmlFileTransport = FacadeJS['w-iframe-htmlfile'] = function(ri, trans_url) {\n    this.run(ri, trans_url, '/htmlfile', HtmlfileReceiver, utils.XHRLocalObject);\n};\nHtmlFileTransport.prototype = new AjaxBasedTransport();\n//         [*] End of lib/trans-iframe-htmlfile.js\n\n\n//         [*] Including lib/trans-polling.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar Polling = function(ri, Receiver, recv_url, AjaxObject) {\n    var that = this;\n    that.ri = ri;\n    that.Receiver = Receiver;\n    that.recv_url = recv_url;\n    that.AjaxObject = AjaxObject;\n    that._scheduleRecv();\n};\n\nPolling.prototype._scheduleRecv = function() {\n    var that = this;\n    var poll = that.poll = new that.Receiver(that.recv_url, that.AjaxObject);\n    var msg_counter = 0;\n    poll.onmessage = function(e) {\n        msg_counter += 1;\n        that.ri._didMessage(e.data);\n    };\n    poll.onclose = function(e) {\n        that.poll = poll = poll.onmessage = poll.onclose = null;\n        if (!that.poll_is_closing) {\n            if (e.reason === 'permanent') {\n                that.ri._didClose(1006, 'Polling error (' + e.reason + ')');\n            } else {\n                that._scheduleRecv();\n            }\n        }\n    };\n};\n\nPolling.prototype.abort = function() {\n    var that = this;\n    that.poll_is_closing = true;\n    if (that.poll) {\n        that.poll.abort();\n    }\n};\n//         [*] End of lib/trans-polling.js\n\n\n//         [*] Including lib/trans-receiver-eventsource.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar EventSourceReceiver = function(url) {\n    var that = this;\n    var es = new EventSource(url);\n    es.onmessage = function(e) {\n        that.dispatchEvent(new SimpleEvent('message',\n                                           {'data': unescape(e.data)}));\n    };\n    that.es_close = es.onerror = function(e, abort_reason) {\n        // ES on reconnection has readyState = 0 or 1.\n        // on network error it's CLOSED = 2\n        var reason = abort_reason ? 'user' :\n            (es.readyState !== 2 ? 'network' : 'permanent');\n        that.es_close = es.onmessage = es.onerror = null;\n        // EventSource reconnects automatically.\n        es.close();\n        es = null;\n        // Safari and chrome < 15 crash if we close window before\n        // waiting for ES cleanup. See:\n        //   https://code.google.com/p/chromium/issues/detail?id=89155\n        utils.delay(200, function() {\n                        that.dispatchEvent(new SimpleEvent('close', {reason: reason}));\n                    });\n    };\n};\n\nEventSourceReceiver.prototype = new REventTarget();\n\nEventSourceReceiver.prototype.abort = function() {\n    var that = this;\n    if (that.es_close) {\n        that.es_close({}, true);\n    }\n};\n//         [*] End of lib/trans-receiver-eventsource.js\n\n\n//         [*] Including lib/trans-receiver-htmlfile.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar _is_ie_htmlfile_capable;\nvar isIeHtmlfileCapable = function() {\n    if (_is_ie_htmlfile_capable === undefined) {\n        if ('ActiveXObject' in _window) {\n            try {\n                _is_ie_htmlfile_capable = !!new ActiveXObject('htmlfile');\n            } catch (x) {}\n        } else {\n            _is_ie_htmlfile_capable = false;\n        }\n    }\n    return _is_ie_htmlfile_capable;\n};\n\n\nvar HtmlfileReceiver = function(url) {\n    var that = this;\n    utils.polluteGlobalNamespace();\n\n    that.id = 'a' + utils.random_string(6, 26);\n    url += ((url.indexOf('?') === -1) ? '?' : '&') +\n        'c=' + escape(WPrefix + '.' + that.id);\n\n    var constructor = isIeHtmlfileCapable() ?\n        utils.createHtmlfile : utils.createIframe;\n\n    var iframeObj;\n    _window[WPrefix][that.id] = {\n        start: function () {\n            iframeObj.loaded();\n        },\n        message: function (data) {\n            that.dispatchEvent(new SimpleEvent('message', {'data': data}));\n        },\n        stop: function () {\n            that.iframe_close({}, 'network');\n        }\n    };\n    that.iframe_close = function(e, abort_reason) {\n        iframeObj.cleanup();\n        that.iframe_close = iframeObj = null;\n        delete _window[WPrefix][that.id];\n        that.dispatchEvent(new SimpleEvent('close', {reason: abort_reason}));\n    };\n    iframeObj = constructor(url, function(e) {\n                                that.iframe_close({}, 'permanent');\n                            });\n};\n\nHtmlfileReceiver.prototype = new REventTarget();\n\nHtmlfileReceiver.prototype.abort = function() {\n    var that = this;\n    if (that.iframe_close) {\n        that.iframe_close({}, 'user');\n    }\n};\n//         [*] End of lib/trans-receiver-htmlfile.js\n\n\n//         [*] Including lib/trans-receiver-xhr.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar XhrReceiver = function(url, AjaxObject) {\n    var that = this;\n    var buf_pos = 0;\n\n    that.xo = new AjaxObject('POST', url, null);\n    that.xo.onchunk = function(status, text) {\n        if (status !== 200) return;\n        while (1) {\n            var buf = text.slice(buf_pos);\n            var p = buf.indexOf('\\n');\n            if (p === -1) break;\n            buf_pos += p+1;\n            var msg = buf.slice(0, p);\n            that.dispatchEvent(new SimpleEvent('message', {data: msg}));\n        }\n    };\n    that.xo.onfinish = function(status, text) {\n        that.xo.onchunk(status, text);\n        that.xo = null;\n        var reason = status === 200 ? 'network' : 'permanent';\n        that.dispatchEvent(new SimpleEvent('close', {reason: reason}));\n    }\n};\n\nXhrReceiver.prototype = new REventTarget();\n\nXhrReceiver.prototype.abort = function() {\n    var that = this;\n    if (that.xo) {\n        that.xo.close();\n        that.dispatchEvent(new SimpleEvent('close', {reason: 'user'}));\n        that.xo = null;\n    }\n};\n//         [*] End of lib/trans-receiver-xhr.js\n\n\n//         [*] Including lib/test-hooks.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\n// For testing\nSockJS.getUtils = function(){\n    return utils;\n};\n\nSockJS.getIframeTransport = function(){\n    return IframeTransport;\n};\n//         [*] End of lib/test-hooks.js\n\n                  return SockJS;\n          })();\nif ('_sockjs_onload' in window) setTimeout(_sockjs_onload, 1);\n\n// AMD compliance\nif (typeof define === 'function' && define.amd) {\n    define('sockjs', [], function(){return SockJS;});\n}\n\nif (typeof module === 'object' && module && module.exports) {\n    module.exports = SockJS;\n}\n//     [*] End of lib/index.js\n\n// [*] End of lib/all.js\n\n\n//@ sourceURL=/node_modules/live-reload/node_modules/reconnect/node_modules/shoe/node_modules/sockjs-client/sockjs.js"
));

require.define("/node_modules/live-reload/node_modules/reconnect/inject.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var EventEmitter = require('events').EventEmitter\nvar backoff = require('backoff')\n\nmodule.exports =\nfunction (createConnection) {\n  return function (opts, onConnect) {\n    onConnect = 'function' == typeof opts ? opts : onConnect\n    opts = opts || {initialDelay: 1e3, maxDelay: 30e3}\n    if(!onConnect)\n      onConnect = opts.onConnect\n\n    var emitter = new EventEmitter()\n    emitter.connected = false\n    emitter.reconnect = true\n\n    if(onConnect)\n      emitter.on('connect', onConnect)\n\n    var backoffMethod = (backoff[opts.type] || backoff.fibonacci) (opts)\n\n    backoffMethod.on('backoff', function (n, d) {\n      emitter.emit('backoff', n, d)\n    })\n\n    var args\n    function attempt (n, delay) {\n      if(!emitter.reconnect) return\n\n      emitter.emit('reconnect', n, delay)\n      var con = createConnection.apply(null, args)\n      emitter._connection = con\n      function onDisconnect () {\n\n        emitter.connected = false\n        con.removeListener('error', onDisconnect)\n        con.removeListener('close', onDisconnect)\n        con.removeListener('end'  , onDisconnect)\n\n        //emit disconnect before checking reconnect, so user has a chance to decide not to.\n        emitter.emit('disconnect', con)\n\n        if(!emitter.reconnect) return\n        backoffMethod.backoff()\n      }\n\n      con.on('connect', function () {\n        backoffMethod.reset()\n        emitter.connected = true\n        emitter.emit('connect', con)\n      }).on('error', onDisconnect)\n        .on('close', onDisconnect)\n        .on('end'  , onDisconnect)\n    }\n\n    emitter.connect =\n    emitter.listen = function () {\n      this.reconnect = true\n      if(emitter.connected) return\n      backoffMethod.reset()\n      backoffMethod.on('ready', attempt)\n      args = [].slice.call(arguments)\n      attempt(0, 0)\n      return emitter\n    }\n\n    emitter.disconnect = function () {\n      this.reconnect = false\n      if(!emitter.connected) return emitter\n      \n      else if(emitter._connection)\n        emitter._connection.destroy()\n      return emitter\n    }\n\n    return emitter\n  }\n\n}\n\n//@ sourceURL=/node_modules/live-reload/node_modules/reconnect/inject.js"
));

require.define("/node_modules/live-reload/node_modules/reconnect/node_modules/backoff/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/live-reload/node_modules/reconnect/node_modules/backoff/package.json"
));

require.define("/node_modules/live-reload/node_modules/reconnect/node_modules/backoff/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*\n * Copyright (c) 2012 Mathieu Turcotte\n * Licensed under the MIT license.\n */\n\nvar Backoff = require('./lib/backoff'),\n    FibonacciBackoffStrategy = require('./lib/strategy/fibonacci'),\n    ExponentialBackoffStrategy = require('./lib/strategy/exponential');\n\nmodule.exports.Backoff = Backoff;\nmodule.exports.FibonacciStrategy = FibonacciBackoffStrategy;\nmodule.exports.ExponentialStrategy = ExponentialBackoffStrategy;\n\n/**\n * Constructs a Fibonacci backoff.\n * @param options Fibonacci backoff strategy arguments.\n * @see FibonacciBackoffStrategy\n */\nmodule.exports.fibonacci = function(options) {\n    return new Backoff(new FibonacciBackoffStrategy(options));\n};\n\n/**\n * Constructs an exponential backoff.\n * @param options Exponential strategy arguments.\n * @see ExponentialBackoffStrategy\n */\nmodule.exports.exponential = function(options) {\n    return new Backoff(new ExponentialBackoffStrategy(options));\n};\n\n\n//@ sourceURL=/node_modules/live-reload/node_modules/reconnect/node_modules/backoff/index.js"
));

require.define("/node_modules/live-reload/node_modules/reconnect/node_modules/backoff/lib/backoff.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*\n * Copyright (c) 2012 Mathieu Turcotte\n * Licensed under the MIT license.\n */\n\nvar events = require('events'),\n    util = require('util');\n\n/**\n * Backoff driver.\n * @param backoffStrategy Backoff delay generator/strategy.\n * @constructor\n */\nfunction Backoff(backoffStrategy) {\n    events.EventEmitter.call(this);\n\n    this.backoffStrategy_ = backoffStrategy;\n    this.backoffNumber_ = 0;\n    this.backoffDelay_ = 0;\n    this.timeoutID_ = -1;\n\n    this.handlers = {\n        backoff: this.onBackoff_.bind(this)\n    };\n}\nutil.inherits(Backoff, events.EventEmitter);\n\n/**\n * Starts a backoff operation.\n */\nBackoff.prototype.backoff = function() {\n    if (this.timeoutID_ !== -1) {\n        throw new Error('Backoff in progress.');\n    }\n\n    this.backoffDelay_ = this.backoffStrategy_.next();\n    this.timeoutID_ = setTimeout(this.handlers.backoff, this.backoffDelay_);\n    this.emit('backoff', this.backoffNumber_, this.backoffDelay_);\n};\n\n/**\n * Backoff completion handler.\n * @private\n */\nBackoff.prototype.onBackoff_ = function() {\n    this.timeoutID_ = -1;\n    this.emit('ready', this.backoffNumber_++, this.backoffDelay_);\n};\n\n/**\n * Stops any backoff operation and resets the backoff\n * delay to its inital value.\n */\nBackoff.prototype.reset = function() {\n    this.backoffNumber_ = 0;\n    this.backoffStrategy_.reset();\n    clearTimeout(this.timeoutID_);\n    this.timeoutID_ = -1;\n};\n\nmodule.exports = Backoff;\n\n\n//@ sourceURL=/node_modules/live-reload/node_modules/reconnect/node_modules/backoff/lib/backoff.js"
));

require.define("/node_modules/live-reload/node_modules/reconnect/node_modules/backoff/lib/strategy/fibonacci.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*\n * Copyright (c) 2012 Mathieu Turcotte\n * Licensed under the MIT license.\n */\n\nvar util = require('util');\n\nvar BackoffStrategy = require('./strategy');\n\n/**\n * Fibonacci backoff strategy.\n * @extends BackoffStrategy\n */\nfunction FibonacciBackoffStrategy(options) {\n    BackoffStrategy.call(this, options);\n    this.backoffDelay_ = 0;\n    this.nextBackoffDelay_ = this.getInitialDelay();\n}\nutil.inherits(FibonacciBackoffStrategy, BackoffStrategy);\n\n/** @inheritDoc */\nFibonacciBackoffStrategy.prototype.next_ = function() {\n    var backoffDelay = Math.min(this.nextBackoffDelay_, this.getMaxDelay());\n    this.nextBackoffDelay_ += this.backoffDelay_;\n    this.backoffDelay_ = backoffDelay;\n    return backoffDelay;\n};\n\n/** @inheritDoc */\nFibonacciBackoffStrategy.prototype.reset_ = function() {\n    this.nextBackoffDelay_ = this.getInitialDelay();\n    this.backoffDelay_ = 0;\n};\n\nmodule.exports = FibonacciBackoffStrategy;\n\n\n//@ sourceURL=/node_modules/live-reload/node_modules/reconnect/node_modules/backoff/lib/strategy/fibonacci.js"
));

require.define("/node_modules/live-reload/node_modules/reconnect/node_modules/backoff/lib/strategy/strategy.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*\n * Copyright (c) 2012 Mathieu Turcotte\n * Licensed under the MIT license.\n */\n\nvar events = require('events'),\n    util = require('util');\n\nfunction isDef(value) {\n    return value !== undefined && value !== null;\n}\n\n/**\n * Abstract class defining the skeleton for all backoff strategies.\n * @param options Backoff strategy options.\n * @param options.randomisationFactor The randomisation factor, must be between\n * 0 and 1.\n * @param options.initialDelay The backoff initial delay, in milliseconds.\n * @param options.maxDelay The backoff maximal delay, in milliseconds.\n * @constructor\n */\nfunction BackoffStrategy(options) {\n    options = options || {};\n\n    if (isDef(options.initialDelay) && options.initialDelay < 1) {\n        throw new Error('The initial timeout must be greater than 0.');\n    } else if (isDef(options.maxDelay) && options.maxDelay < 1) {\n        throw new Error('The maximal timeout must be greater than 0.');\n    }\n\n    this.initialDelay_ = options.initialDelay || 100;\n    this.maxDelay_ = options.maxDelay || 10000;\n\n    if (this.maxDelay_ <= this.initialDelay_) {\n        throw new Error('The maximal backoff delay must be ' +\n                        'greater than the initial backoff delay.');\n    }\n\n    if (isDef(options.randomisationFactor) &&\n        (options.randomisationFactor < 0 || options.randomisationFactor > 1)) {\n        throw new Error('The randomisation factor must be between 0 and 1.');\n    }\n\n    this.randomisationFactor_ = options.randomisationFactor || 0;\n}\n\n/**\n * Retrieves the maximal backoff delay.\n * @return The maximal backoff delay.\n */\nBackoffStrategy.prototype.getMaxDelay = function() {\n    return this.maxDelay_;\n};\n\n/**\n * Retrieves the initial backoff delay.\n * @return The initial backoff delay.\n */\nBackoffStrategy.prototype.getInitialDelay = function() {\n    return this.initialDelay_;\n};\n\n/**\n * Template method that computes the next backoff delay.\n * @return The backoff delay, in milliseconds.\n */\nBackoffStrategy.prototype.next = function() {\n    var backoffDelay = this.next_();\n    var randomisationMultiple = 1 + Math.random() * this.randomisationFactor_;\n    var randomizedDelay = Math.round(backoffDelay * randomisationMultiple);\n    return randomizedDelay;\n};\n\n/**\n * Computes the next backoff delay.\n * @return The backoff delay, in milliseconds.\n */\nBackoffStrategy.prototype.next_ = function() {\n    throw new Error('BackoffStrategy.next_() unimplemented.');\n};\n\n/**\n * Template method that resets the backoff delay to its initial value.\n */\nBackoffStrategy.prototype.reset = function() {\n    this.reset_();\n};\n\n/**\n * Resets the backoff delay to its initial value.\n */\nBackoffStrategy.prototype.reset_ = function() {\n    throw new Error('BackoffStrategy.reset_() unimplemented.');\n};\n\nmodule.exports = BackoffStrategy;\n\n\n//@ sourceURL=/node_modules/live-reload/node_modules/reconnect/node_modules/backoff/lib/strategy/strategy.js"
));

require.define("/node_modules/live-reload/node_modules/reconnect/node_modules/backoff/lib/strategy/exponential.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*\n * Copyright (c) 2012 Mathieu Turcotte\n * Licensed under the MIT license.\n */\n\nvar util = require('util');\n\nvar BackoffStrategy = require('./strategy');\n\n/**\n * Exponential backoff strategy.\n * @extends BackoffStrategy\n */\nfunction ExponentialBackoffStrategy(options) {\n    BackoffStrategy.call(this, options);\n    this.backoffDelay_ = 0;\n    this.nextBackoffDelay_ = this.getInitialDelay();\n}\nutil.inherits(ExponentialBackoffStrategy, BackoffStrategy);\n\n/** @inheritDoc */\nExponentialBackoffStrategy.prototype.next_ = function() {\n    this.backoffDelay_ = Math.min(this.nextBackoffDelay_, this.getMaxDelay());\n    this.nextBackoffDelay_ = this.backoffDelay_ * 2;\n    return this.backoffDelay_;\n};\n\n/** @inheritDoc */\nExponentialBackoffStrategy.prototype.reset_ = function() {\n    this.backoffDelay_ = 0;\n    this.nextBackoffDelay_ = this.getInitialDelay();\n};\n\nmodule.exports = ExponentialBackoffStrategy;\n\n\n//@ sourceURL=/node_modules/live-reload/node_modules/reconnect/node_modules/backoff/lib/strategy/exponential.js"
));

require.define("/node_modules/insert/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index\"}\n//@ sourceURL=/node_modules/insert/package.json"
));

require.define("/node_modules/insert/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var slice = Array.prototype.slice\n    , toArray = slice.call.bind(slice)\n\nmodule.exports = {\n    prepend: prepend\n    , append: append\n    , after: after\n    , before: before\n    , remove: remove\n    , replace: replace\n    , mutation: mutation\n}\n\nfunction prepend(parent) {\n    var node = mutation(toArray(arguments, 1))\n    parent.insertBefore(node, parent.firstChild)\n}\n\nfunction append(parent) {\n    var node = mutation(toArray(arguments, 1))\n    parent.appendChild(node)\n}\n\nfunction before(sibling) {\n    var node = mutation(toArray(arguments, 1))\n        , parent = sibling.parentNode\n\n    parent.insertBefore(node, sibling)\n}\n\nfunction after(sibling) {\n    var node = mutation(toArray(arguments, 1))\n        , parent = sibling.parentNode\n        , child = sibling.nextSibling\n\n    parent.insertBefore(node, child)\n}\n\nfunction replace(target) {\n    var node = mutation(toArray(arguments, 1))\n        , parent = target.parentNode\n\n    parent.replaceChild(node, target)\n}\n\nfunction remove() {\n    var list = toArray(arguments)\n    list.forEach(removeFromParent)\n}\n\nfunction removeFromParent(elem) {\n    elem.parentNode.removeChild(elem)\n}\n\nfunction mutation(list) {\n    list = list.map(replaceStringWithTextNode)\n\n    if (list.length === 1) {\n        return list[0]\n    }\n\n    var frag = document.createDocumentFragment()\n    list.forEach(appendToFragment, frag)\n    return frag\n}\n\nfunction replaceStringWithTextNode(string) {\n    if (typeof string === \"string\") {\n        return document.createTextNode(string)\n    }\n\n    return string\n}\n\nfunction appendToFragment(elem) {\n    this.appendChild(elem)\n}\n//@ sourceURL=/node_modules/insert/index.js"
));

require.define("/reflex/flow.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var state = require(\"./state\")\nvar patch = require(\"diffpatcher/patch\")\nvar channel = require(\"reducers/channel\")\nvar reductions = require(\"reducers/reductions\")\n\nmodule.exports = flow\n\nfunction flow(initial) {\n    var stream = channel()\n    var orig = state(initial)\n    var states = reductions(stream, patch, orig)\n\n    return {\n        output: states\n        , input: stream\n        , initial: orig\n    }\n}\n\n//@ sourceURL=/reflex/flow.js"
));

require.define("/reflex/state.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/* vim:set ts=2 sw=2 sts=2 expandtab */\n/*jshint asi: true undef: true es5: true node: true devel: true\n         forin: true latedef: false globalstrict: true*/\n/*global parent:true */\n\n\"use strict\";\n\nvar diff = require(\"diffpatcher/diff\")\nvar patch = require(\"diffpatcher/patch\")\nvar rebase = require(\"diffpatcher/rebase\")\nvar channel = require(\"reducers/channel\")\nvar timestamp = require(\"monotonic-timestamp\")\n\nvar make = Object.create || (function() {\n    function Type() {}\n    return function make(prototype) {\n        Type.prototype = prototype\n        return new Type()\n    }\n})()\n\n// Generated unique name is used to store `delta` on the state object\n// which is object containing changes from previous state to current.\nvar delta = \"delta@\" + module.id\nvar id = \"uuid@\" + module.id\nvar parent = \"parent@\" + module.id\n\n// State is a type used for representing application states. Primarily\n// reason to have a type is to have an ability implement polymorphic\n// methods for it.\nfunction State() {}\n\n// Returns diff that has being applied to a previous state to get to a\n// current one.\ndiff.define(State, function diff(from, to) {\n    // If state does not contains delta property then it's initial,\n    // so diff to get to the current state should be a diff itself.\n    if (to[parent] === from[id]) {\n        return to[delta]\n    }\n\n    return diff.calculate(from, to)\n})\n\n// Patches given `state` with a given `diff` creating a new state that is\n// returned back.\npatch.define(State, function patch(state, id, value) {\n    var diff = id\n    if (arguments.length === 3) {\n        diff = {}\n        diff[id] = value\n    }\n\n    var value = new State()\n    // Store `diff` is stored so that it can be retrieved without calculations.\n    value[delta] = diff\n    value[parent] = state[id]\n\n    return rebase(make(value), state, diff)\n})\n\n\nfunction state() {\n    /**\n    Creates an object representing a state snapshot.\n    **/\n    var value = new State()\n    value[id] = timestamp()\n    value[parent] = null\n    return make(value)\n}\nstate.type = State\nstate.delta = delta\n\nmodule.exports = state\n\n//@ sourceURL=/reflex/state.js"
));

require.define("/node_modules/diffpatcher/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"./diffpatcher.js\"}\n//@ sourceURL=/node_modules/diffpatcher/package.json"
));

require.define("/node_modules/diffpatcher/diff.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/* vim:set ts=2 sw=2 sts=2 expandtab */\n/*jshint asi: true undef: true es5: true node: true browser: true devel: true\n         eqnull: true forin: true latedef: false globalstrict: true*/\n\n\"use strict\";\n\nvar method = require(\"method\")\n\n// Method is designed to work with data structures representing application\n// state. Calling it with a state should return object representing `delta`\n// that has being applied to a previous state to get to a current state.\n//\n// Example\n//\n// diff(state) // => { \"item-id-1\": { title: \"some title\" } \"item-id-2\": null }\nvar diff = method()\n\n// diff between `null` / `undefined` to any hash is a hash itself.\ndiff.define(null, function(from, to) { return to })\ndiff.define(undefined, function(from, to) { return to })\ndiff.define(Object, function(from, to) {\n  return calculate(from, to || {}) || {}\n})\n\nfunction calculate(from, to) {\n  var diff = {}\n  var changes = 0\n  Object.keys(from).forEach(function(key) {\n    changes = changes + 1\n    if (!(key in to) && from[key] != null) diff[key] = null\n    else changes = changes - 1\n  })\n  Object.keys(to).forEach(function(key) {\n    changes = changes + 1\n    var previous = from[key]\n    var current = to[key]\n    if (previous === current) return (changes = changes - 1)\n    if (typeof(current) !== \"object\") return diff[key] = current\n    if (typeof(previous) !== \"object\") return diff[key] = current\n    var delta = calculate(previous, current)\n    if (delta) diff[key] = delta\n    else changes = changes - 1\n  })\n  return changes ? diff : null\n}\n\ndiff.calculate = calculate\n\nmodule.exports = diff\n\n//@ sourceURL=/node_modules/diffpatcher/diff.js"
));

require.define("/node_modules/diffpatcher/node_modules/method/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"./core.js\"}\n//@ sourceURL=/node_modules/diffpatcher/node_modules/method/package.json"
));

require.define("/node_modules/diffpatcher/node_modules/method/core.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/* vim:set ts=2 sw=2 sts=2 expandtab */\n/*jshint asi: true undef: true es5: true node: true browser: true devel: true\n         forin: true latedef: false globalstrict: true */\n'use strict';\n\n// Shortcuts for ES5 reflection functions.\nvar make = Object.create || (function() {\n  var Type = function Type() {}\n  return function make(prototype) {\n    Type.prototype = prototype\n    return new Type()\n  }\n})\nvar defineProperty = Object.defineProperty || function(object, name, property) {\n  object[name] = property.value\n  return object\n}\nvar typefy = Object.prototype.toString\n\nfunction Method(base) {\n  /**\n  Private Method is a callable private name that dispatches on the first\n  arguments same named Method: Method(...rest) => rest[0][Method](...rest)\n  Default implementation may be passed in as an argument.\n  **/\n\n  // Create an internal unique name if default implementation is passed,\n  // use it's name as a name hint.\n  var name = (base && base.name || \"\") + Math.random().toString(32).substr(2)\n\n  function dispatch() {\n    // Method dispatches on type of the first argument.\n    var target = arguments[0]\n    var builtin = null\n    // If first argument is `null` or `undefined` use associated property\n    // maps for implementation lookups, otherwise attempt to use implementation\n    // for built-in falling back for implementation on the first argument.\n    // Finally use default implementation if no other one is found.\n    var method = target === null ? Null[name] :\n                 target === undefined ? Undefined[name] :\n                 target[name] ||\n                 ((builtin = Builtins[typefy.call(target)]) && builtin[name]) ||\n                 Builtins.Object[name] ||\n                 Default[name]\n\n    // If implementation not found there's not much we can do about it,\n    // throw error with a descriptive message.\n    if (!method) throw Error('Type does not implements method')\n\n    // If implementation is found delegate to it.\n    return method.apply(method, arguments)\n  }\n\n  // Define default implementation.\n  Default[name] = base\n\n  // Define `Method.toString` returning private name, this hack will enable\n  // Method definition like follows:\n  // var foo = Method()\n  // object[foo] = function() { /***/ }\n  dispatch.toString = function toString() { return name }\n\n  // Copy utility Methods for convenient API.\n  dispatch.implement = implementMethod\n  dispatch.define = defineMethod\n\n  return dispatch\n}\n\n// Define objects where Methods implementations for `null`, `undefined` and\n// defaults will be stored.\nvar Default = {}\nvar Null = make(Default)\nvar Undefined = make(Default)\n// Implementation for built-in types are stored in the hash, this avoids\n// mutations on built-ins and allows cross frame extensions. Primitive types\n// are predefined so that `Object` extensions won't be inherited.\nvar Builtins = {\n  Object: make(Default),\n  Number: make(Default),\n  String: make(Default),\n  Boolean: make(Default)\n}\n// Define aliases for predefined built-in maps to a forms that values will\n// be serialized on dispatch.\nBuiltins[typefy.call(Object.prototype)] = Builtins.Object\nBuiltins[typefy.call(Number.prototype)] = Builtins.Number\nBuiltins[typefy.call(String.prototype)] = Builtins.String\n\n\n\nvar implement = Method(\nfunction implement(method, object, lambda) {\n  /**\n  Implements `Method` for the given `object` with a provided `implementation`.\n  Calling `Method` with `object` as a first argument will dispatch on provided\n  implementation.\n  **/\n  var target = object === null ? Null :\n               object === undefined ? Undefined :\n               object\n\n  return defineProperty(target, method.toString(), {\n    enumerable: false,\n    configurable: false,\n    writable: false,\n    value: lambda\n  })\n})\n\nvar define = Method(function define(method, Type, lambda) {\n  /**\n  Defines `Method` for the given `Type` with a provided `implementation`.\n  Calling `Method` with a first argument of this `Type` will dispatch on\n  provided `implementation`. If `Type` is a `Method` default implementation\n  is defined. If `Type` is a `null` or `undefined` `Method` is implemented\n  for that value type.\n  **/\n  if (!lambda) return implement(method, Default, Type)\n  if (!Type) return implement(method, Type, lambda)\n  var type = typefy.call(Type.prototype)\n  return type !== \"[object Object]\" ? implement(method,\n      Builtins[type] || (Builtins[type] = make(Builtins.Object)), lambda) :\n    // This should be `Type === Object` but since it will be `false` for\n    // `Object` from different JS context / compartment / frame we assume that\n    // if it's name is `Object` it is Object.\n    Type.name === \"Object\" ? implement(method, Builtins.Object, lambda) :\n    implement(method, Type.prototype, lambda)\n})\n\nvar defineMethod = function defineMethod(Type, lambda) {\n  return define(this, Type, lambda)\n}\nvar implementMethod = function implementMethod(object, lambda) {\n  return implement(this, object, lambda)\n}\n\n\n// Define exports on `Method` as it's only thing we export.\nMethod.implement = implement\nMethod.define = define\nMethod.Method = Method\nMethod.Null = Null\nMethod.Undefined = Undefined\nMethod.Default = Default\nMethod.Builtins = Builtins\n\nmodule.exports = Method\n\n//@ sourceURL=/node_modules/diffpatcher/node_modules/method/core.js"
));

require.define("/node_modules/diffpatcher/patch.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/* vim:set ts=2 sw=2 sts=2 expandtab */\n/*jshint asi: true undef: true es5: true node: true browser: true devel: true\n         forin: true latedef: false globalstrict: true*/\n\n\"use strict\";\n\nvar method = require(\"method\")\nvar rebase = require(\"./rebase\")\n\n// Method is designed to work with data structures representing application\n// state. Calling it with a state and delta should return object representing\n// new state, with changes in `delta` being applied to previous.\n//\n// ## Example\n//\n// patch(state, {\n//   \"item-id-1\": { completed: false }, // update\n//   \"item-id-2\": null                  // delete\n// })\nvar patch = method()\npatch.define(Object, function patch(hash, delta) {\n  return rebase({}, hash, delta)\n})\n\nmodule.exports = patch\n\n//@ sourceURL=/node_modules/diffpatcher/patch.js"
));

require.define("/node_modules/diffpatcher/rebase.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/* vim:set ts=2 sw=2 sts=2 expandtab */\n/*jshint asi: true undef: true es5: true node: true browser: true devel: true\n         eqnull: true forin: true latedef: false globalstrict: true*/\n\n\"use strict\";\n\nfunction rebase(result, parent, delta) {\n  Object.keys(parent).forEach(function(key) {\n    // If `parent[key]` is `null` it means attribute was deleted in previous\n    // update. We skip such properties as there is no use in keeping them\n    // around. If `delta[key]` is `null` we skip these properties too as\n    // the have being deleted.\n    if (!(parent[key] == null || (key in delta && delta[key] == null)))\n      result[key] = parent[key]\n  }, result)\n  Object.keys(delta).forEach(function(key) {\n    if (key in parent) {\n      var current = delta[key]\n      var previous = parent[key]\n      if (current === previous) current = current\n      // If `delta[key]` is `null` it's delete so we just skip property.\n      else if (current == null) current = current\n      // If value is of primitive type (function or regexps should not\n      // even be here) we just update in place.\n      else if (typeof(current) !== \"object\") result[key] = current\n      // If previous value associated with this key was primitive\n      // and it's mapped to non primitive\n      else if (typeof(previous) !== \"object\") result[key] = current\n      else result[key] = rebase({}, previous, current)\n    } else {\n      result[key] = delta[key]\n    }\n  })\n  return result\n}\n\nmodule.exports = rebase\n\n//@ sourceURL=/node_modules/diffpatcher/rebase.js"
));

require.define("/node_modules/reducers/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/reducers/package.json"
));

require.define("/node_modules/reducers/channel.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/* vim:set ts=2 sw=2 sts=2 expandtab */\n/*jshint asi: true undef: true es5: true node: true browser: true devel: true\n         forin: true latedef: false globalstrict: true */\n\n'use strict';\n\nvar hub = require('./hub')\nvar signal = require('./signal')\n\nfunction channel() {\n  /**\n  Return a channel -- a sequence of events over time that may be reduced by\n  one or more consumer functions.\n\n  Channels are `signals` that have been transformed by `hub`, allowing them\n  to be reduced more than once.\n  **/\n  return hub(signal())\n}\n\nmodule.exports = channel\n\n//@ sourceURL=/node_modules/reducers/channel.js"
));

require.define("/node_modules/reducers/hub.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/* vim:set ts=2 sw=2 sts=2 expandtab */\n/*jshint asi: true undef: true es5: true node: true browser: true devel: true\n         forin: true latedef: false globalstrict: true */\n'use strict';\n\nvar accumulate = require(\"./accumulate\")\nvar convert = require(\"./convert\")\nvar accumulated = require(\"./accumulated\")\nvar end = require(\"./end\")\n\nvar input = \"input@\" + module.id\nvar consumers = \"consumers@\" + module.id\n\nfunction open(hub) {\n  var source = hub[input]\n  var hubConsumers = hub[consumers]\n  hub[input] = null         // mark hub as open\n  accumulate(source, function distribute(value) {\n    var activeConsumers = hubConsumers.slice(0)\n    var count = activeConsumers.length, index = 0\n    while (index < count) {\n      var consumer = activeConsumers[index++]\n      var state = consumer.next(value, consumer.state)\n      if (state && state.is === accumulated) {\n        var position = hubConsumers.indexOf(consumer)\n        if (position >= 0) hubConsumers.splice(position, 1)\n        consumer.next(end(), consumer.state)\n      } else {\n        consumer.state = state\n      }\n    }\n\n    if (value && value.is === end) {\n      hubConsumers.splice(0)\n      hub[input] = source\n    }\n    if (!hubConsumers.length) {\n      hub[input] = source       // mark hub as not open.\n      return accumulated()      // will notify source consumption is complete.\n    }\n  })\n}\n\nfunction isHub(value) {\n  return !value || (input in value && consumers in value)\n}\n\nfunction isOpen(hub) {\n  return hub[input] === null\n}\n\nfunction hub(source) {\n  /**\n  Take a reducible `source`, such as a `signal` and return a reducible that can\n  be consumed by many reducers.\n  **/\n\n  // If source is already a hub avoid just return.\n  if (isHub(source)) return source\n  var value = convert(source, hub.accumulate)\n  value[input] = source\n  value[consumers] = []\n  return value\n}\nhub.isHub = isHub\nhub.isOpen = isOpen\nhub.accumulate = function accumulate(hub, next, initial) {\n  hub[consumers].push({ next: next, state: initial })\n  if (!isOpen(hub)) open(hub)\n}\nmodule.exports = hub\n\n//@ sourceURL=/node_modules/reducers/hub.js"
));

require.define("/node_modules/reducers/accumulate.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*jshint asi: true undef: true es5: true node: true browser: true devel: true\n         forin: true latedef: false globalstrict: true */\n\n'use strict';\n\nvar Method = require(\"method\")\nvar end = require(\"./end\")\nvar accumulated = require(\"./accumulated\")\nvar Eventual = require(\"eventual/type\")\nvar when = require(\"eventual/when\")\nvar error = require(\"./error\")\n\nvar accumulate = Method()\n\n// Implementation of accumulate for the empty sequences, that immediately\n// signals end of sequence.\naccumulate.empty = function accumulateEmpty(empty, next, start) {\n  next(end(), start)\n}\n// Implementation of accumulate for the singular values which are treated\n// as sequences with single element. Yields the given value and signals\n// the end of sequence.\naccumulate.singular = function accumulateSingular(value, next, start) {\n  next(end(), next(value, start))\n}\n// Implementation accumulate for the array (and alike) values, such that it\n// will call accumulator function `next` each time with next item and\n// accumulated state until it's exhausted or `next` returns marked value\n// indicating that it's done accumulating. Either way signals end to\n// an accumulator.\naccumulate.indexed = function accumulateIndexed(indexed, next, initial) {\n  var state = initial, index = 0, count = indexed.length\n  while (index < count) {\n    state = next(indexed[index++], state)\n    if (state && state.is === accumulated) break\n  }\n  next(end(), state)\n}\n\n// Both `undefined` and `null` implement accumulate for empty sequences.\naccumulate.define(void(0), accumulate.empty)\naccumulate.define(null, accumulate.empty)\n\n// Array and arguments implement accumulate for indexed sequences.\naccumulate.define(Array, accumulate.indexed)\naccumulate.define((function() { return arguments })(), accumulate.indexed)\n\n// All other built-in data structures are treated as single value sequences\n// by default. Of course individual types may choose to override that.\naccumulate.define(accumulate.singular)\n\n// All eventual values are treated as a single value of sequences, of\n// the value they realize to.\naccumulate.define(Eventual, function(eventual, next, initial) {\n  function onfail(failure) { next(error(failure)) }\n  return when(eventual, function delivered(value) {\n    return when(next(value, initial), function(result) {\n      next(end(), result)\n    }, onfail)\n  }, onfail)\n})\n\nmodule.exports = accumulate\n\n//@ sourceURL=/node_modules/reducers/accumulate.js"
));

require.define("/node_modules/reducers/node_modules/method/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"./core.js\"}\n//@ sourceURL=/node_modules/reducers/node_modules/method/package.json"
));

require.define("/node_modules/reducers/node_modules/method/core.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/* vim:set ts=2 sw=2 sts=2 expandtab */\n/*jshint asi: true undef: true es5: true node: true browser: true devel: true\n         forin: true latedef: false globalstrict: true */\n'use strict';\n\n// Shortcuts for ES5 reflection functions.\nvar make = Object.create || (function() {\n  var Type = function Type() {}\n  return function make(prototype) {\n    Type.prototype = prototype\n    return new Type()\n  }\n})\nvar defineProperty = Object.defineProperty || function(object, name, property) {\n  object[name] = property.value\n  return object\n}\nvar typefy = Object.prototype.toString\n\nfunction Method(base) {\n  /**\n  Private Method is a callable private name that dispatches on the first\n  arguments same named Method: Method(...rest) => rest[0][Method](...rest)\n  Default implementation may be passed in as an argument.\n  **/\n\n  // Create an internal unique name if default implementation is passed,\n  // use it's name as a name hint.\n  var name = (base && base.name || \"\") + Math.random().toString(32).substr(2)\n\n  function dispatch() {\n    // Method dispatches on type of the first argument.\n    var target = arguments[0]\n    var builtin = null\n    // If first argument is `null` or `undefined` use associated property\n    // maps for implementation lookups, otherwise attempt to use implementation\n    // for built-in falling back for implementation on the first argument.\n    // Finally use default implementation if no other one is found.\n    var method = target === null ? Null[name] :\n                 target === undefined ? Undefined[name] :\n                 target[name] ||\n                 ((builtin = Builtins[typefy.call(target)]) && builtin[name]) ||\n                 Builtins.Object[name] ||\n                 Default[name]\n\n    // If implementation not found there's not much we can do about it,\n    // throw error with a descriptive message.\n    if (!method) throw Error('Type does not implements method')\n\n    // If implementation is found delegate to it.\n    return method.apply(method, arguments)\n  }\n\n  // Define default implementation.\n  Default[name] = base\n\n  // Define `Method.toString` returning private name, this hack will enable\n  // Method definition like follows:\n  // var foo = Method()\n  // object[foo] = function() { /***/ }\n  dispatch.toString = function toString() { return name }\n\n  // Copy utility Methods for convenient API.\n  dispatch.implement = implementMethod\n  dispatch.define = defineMethod\n\n  return dispatch\n}\n\n// Define objects where Methods implementations for `null`, `undefined` and\n// defaults will be stored.\nvar Default = {}\nvar Null = make(Default)\nvar Undefined = make(Default)\n// Implementation for built-in types are stored in the hash, this avoids\n// mutations on built-ins and allows cross frame extensions. Primitive types\n// are predefined so that `Object` extensions won't be inherited.\nvar Builtins = {\n  Object: make(Default),\n  Number: make(Default),\n  String: make(Default),\n  Boolean: make(Default)\n}\n// Define aliases for predefined built-in maps to a forms that values will\n// be serialized on dispatch.\nBuiltins[typefy.call(Object.prototype)] = Builtins.Object\nBuiltins[typefy.call(Number.prototype)] = Builtins.Number\nBuiltins[typefy.call(String.prototype)] = Builtins.String\n\n\n\nvar implement = Method(\nfunction implement(method, object, lambda) {\n  /**\n  Implements `Method` for the given `object` with a provided `implementation`.\n  Calling `Method` with `object` as a first argument will dispatch on provided\n  implementation.\n  **/\n  var target = object === null ? Null :\n               object === undefined ? Undefined :\n               object\n\n  return defineProperty(target, method.toString(), {\n    enumerable: false,\n    configurable: false,\n    writable: false,\n    value: lambda\n  })\n})\n\nvar define = Method(function define(method, Type, lambda) {\n  /**\n  Defines `Method` for the given `Type` with a provided `implementation`.\n  Calling `Method` with a first argument of this `Type` will dispatch on\n  provided `implementation`. If `Type` is a `Method` default implementation\n  is defined. If `Type` is a `null` or `undefined` `Method` is implemented\n  for that value type.\n  **/\n  if (!lambda) return implement(method, Default, Type)\n  if (!Type) return implement(method, Type, lambda)\n  var type = typefy.call(Type.prototype)\n  return type !== \"[object Object]\" ? implement(method,\n      Builtins[type] || (Builtins[type] = make(Builtins.Object)), lambda) :\n    // This should be `Type === Object` but since it will be `false` for\n    // `Object` from different JS context / compartment / frame we assume that\n    // if it's name is `Object` it is Object.\n    Type.name === \"Object\" ? implement(method, Builtins.Object, lambda) :\n    implement(method, Type.prototype, lambda)\n})\n\nvar defineMethod = function defineMethod(Type, lambda) {\n  return define(this, Type, lambda)\n}\nvar implementMethod = function implementMethod(object, lambda) {\n  return implement(this, object, lambda)\n}\n\n\n// Define exports on `Method` as it's only thing we export.\nMethod.implement = implement\nMethod.define = define\nMethod.Method = Method\nMethod.Null = Null\nMethod.Undefined = Undefined\nMethod.Default = Default\nMethod.Builtins = Builtins\n\nmodule.exports = Method\n\n//@ sourceURL=/node_modules/reducers/node_modules/method/core.js"
));

require.define("/node_modules/reducers/end.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*jshint asi: true undef: true es5: true node: true browser: true devel: true\n         forin: true latedef: false globalstrict: true */\n\n\"use strict\";\n\nvar Box = require(\"./box\")\n\n// Exported function can be used for boxing values. This boxing is used by\n// `accumulate` function to message end of the sequence.\nmodule.exports = Box(\"End of the sequence\")\n\n//@ sourceURL=/node_modules/reducers/end.js"
));

require.define("/node_modules/reducers/box.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/* vim:set ts=2 sw=2 sts=2 expandtab */\n/*jshint asi: true undef: true es5: true node: true browser: true devel: true\n         forin: true latedef: false globalstrict: true */\n\n\"use strict\";\n\nmodule.exports = function Box(description) {\n  /**\n  Create a \"boxed\" value.\n  Boxed values may be used as flags to signify a mode or value.\n  This is similar to the way some languages use magic constants to trigger\n  a specific behavior or mode.\n\n  Boxed values may have a description that explains how they are to be used.\n  \n  Returns a box object.\n  **/\n  description = description || \"Boxed value\"\n  return function box(value) {\n    return {\n      isBoxed: true,\n      is: box,\n      value: value,\n      description: description\n    }\n  }\n}\n\n//@ sourceURL=/node_modules/reducers/box.js"
));

require.define("/node_modules/reducers/accumulated.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*jshint asi: true undef: true es5: true node: true browser: true devel: true\n         forin: true latedef: false globalstrict: true */\n\n\"use strict\";\n\nvar Box = require(\"./box\")\n\n// Exported function can be used for boxing values. This boxing indicates\n// that consumer of sequence has finished consuming it, there for new values\n// should not be no longer pushed.\nvar accumulated = Box(\"Indicator that source has being accumulateed\")\n\nmodule.exports = accumulated\n\n//@ sourceURL=/node_modules/reducers/accumulated.js"
));

require.define("/node_modules/reducers/node_modules/eventual/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/reducers/node_modules/eventual/package.json"
));

require.define("/node_modules/reducers/node_modules/eventual/type.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*jshint asi: true undef: true es5: true node: true devel: true\n         globalstrict: true forin: true latedef: false supernew: true */\n/*global define: true */\n\n\"use strict\";\n\nvar watchers = require(\"watchables/watchers\")\nvar watch = require(\"watchables/watch\")\nvar await = require(\"pending/await\")\nvar isPending = require(\"pending/is\")\nvar deliver = require(\"pending/deliver\")\nvar when = require(\"./when\")\n\n// Internal utility function returns true if given value is of error type,\n// otherwise returns false.\nvar isError = (function() {\n  var stringy = Object.prototype.toString\n  var error = stringy.call(Error.prototype)\n  return function isError(value) {\n    return stringy.call(value) === error\n  }\n})()\n\n// Internal utility, identity function. Returns whatever is given to it.\nfunction identity(value) { return value }\n\n// Internal utility, decorator function that wraps given function into\n// try / catch and returns thrown exception in case when exception is\n// thrown.\nfunction attempt(f) {\n  return function effort(value) {\n    try { return f(value) }\n    catch (error) { return error }\n  }\n}\n\n\n// Define property names used by an `Eventual` type. Names are prefixed via\n// `module.id` to avoid name conflicts.\nvar observers = \"observers@\" + module.id\nvar result = \"value@\" + module.id\nvar pending = \"pending@\" + module.id\n\n\nfunction Eventual() {\n  /**\n  Data type representing eventual value, that can be observed and delivered.\n  Type implements `watchable`, `pending` and `eventual` abstractions, where\n  first two are defined in an external libraries.\n  **/\n  this[observers] = []\n  this[result] = this\n  this[pending] = true\n}\n// Expose property names via type static properties so that it's easier\n// to refer to them while debugging.\nEventual.observers = observers\nEventual.result = result\nEventual.pending = pending\n\nwatchers.define(Eventual, function(value) {\n  return value[observers]\n})\n// Eventual values considered to be pending until the are deliver by calling\n// `deliver`. Internal `pending` property is used to identify weather value\n// is being watched or not.\nisPending.define(Eventual, function(value) {\n  return value[pending]\n})\n// Eventual type implements await function of pending abstraction, to enable\n// observation of value delivery.\nawait.define(Eventual, function(value, observer) {\n  if (isPending(value)) watch(value, observer)\n  else observer(value[result])\n})\n\n// Eventual implements `deliver` function of pending abstraction, to enable\n// fulfillment of eventual values. Eventual value can be delivered only once,\n// which will transition it from pending state to non-pending state. All\n// further deliveries are ignored. It's also guaranteed that all the registered\n// observers will be invoked in FIFO order.\ndeliver.define(Eventual, function(value, data) {\n  // Ignore delivery if value is no longer pending, or if it's in a process of\n  // delivery (in this case eventual[result] is set to value other than\n  // eventual itself). Also ignore if data deliver is value itself.\n  if (value !== data && isPending(value) && value[result] === value) {\n    var count = 0\n    var index = 0\n    var delivering = true\n    var observers = void(0)\n    // Set eventual value result to passed data value that also marks value\n    // as delivery in progress. This way all the `deliver` calls is side\n    // effect to this will be ignored. Note: value should still remain pending\n    // so that new observers could be registered instead of being called\n    // immediately, otherwise it breaks FIFO order.\n    value[result] = data\n    while (delivering) {\n      // If current batch of observers is exhausted, splice a new batch\n      // and continue delivery. New batch is created only if new observers\n      // are registered in side effect to this call of deliver.\n      if (index === count) {\n        observers = watchers(value).splice(0)\n        count = observers.length\n        index = 0\n        // If new observers have not being registered mark value as no longer\n        // pending and finish delivering.\n        if (count === index) {\n          value[pending] = false\n          delivering = false\n        }\n      }\n      // Register await handlers on given result, is it may be eventual /\n      // pending itself. Delivering eventual will cause delivery of the\n      // delivered eventual's delivery value, whenever that would be.\n      else {\n        await(data, observers[index])\n        index = index + 1\n      }\n    }\n  }\n})\n\n// Eventual implements `when` polymorphic function that is part of it's own\n// abstraction. It takes `value` `onFulfill` & `onError` handlers. In return\n// when returns eventual value, that is delivered return value of the handler\n// that is invoked depending on the given values delivery. If deliver value\n// is of error type error handler is invoked. If value is delivered with other\n// non-pending value that is not of error type `onFulfill` handlers is invoked\n// with it. If pending value is delivered then it's value will be delivered\n// it's result whenever that would be. This will cause both value and error\n// propagation.\nwhen.define(Eventual, function(value, onRealize, onError) {\n  // Create eventual value for a return value.\n  var delivered = false\n  var eventual = void(0)\n  var result = void(0)\n  // Wrap handlers into attempt decorator function, so that in case of\n  // exception thrown error is returned causing error propagation. If handler\n  // is missing identity function is used instead to propagate value / error.\n  var realize = onRealize ? attempt(onRealize) : identity\n  var error = onError ? attempt(onError) : identity\n  // Wait for pending value to be delivered.\n  await(value, function onDeliver(data) {\n    // Once value is delivered invoke appropriate handler, and deliver it\n    // to a resulting eventual value.\n    result = isError(data) ? error(data)\n                           : realize(data)\n\n    // If outer function is already returned and has created eventual\n    // for it's result deliver it. Otherwise (if await called observer\n    // in same synchronously) mark result delivered.\n    if (eventual) deliver(eventual, result)\n    else delivered = true\n  })\n\n  // If result is delivered already return it, otherwise create eventual\n  // value for the result and return that.\n  return delivered ? result : (eventual = new Eventual())\n})\n\nmodule.exports = Eventual\n\n//@ sourceURL=/node_modules/reducers/node_modules/eventual/type.js"
));

require.define("/node_modules/reducers/node_modules/eventual/node_modules/watchables/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/reducers/node_modules/eventual/node_modules/watchables/package.json"
));

require.define("/node_modules/reducers/node_modules/eventual/node_modules/watchables/watchers.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*jshint asi: true undef: true es5: true node: true devel: true\n         globalstrict: true forin: true latedef: false supernew: true */\n/*global define: true */\n\n\"use strict\";\n\nvar Method = require('method')\n\n// Method is supposed to return array of watchers for the given\n// value.\nmodule.exports = Method()\n\n//@ sourceURL=/node_modules/reducers/node_modules/eventual/node_modules/watchables/watchers.js"
));

require.define("/node_modules/reducers/node_modules/eventual/node_modules/watchables/watch.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*jshint asi: true undef: true es5: true node: true devel: true\n         globalstrict: true forin: true latedef: false supernew: true */\n/*global define: true */\n\n\"use strict\";\n\nvar Method = require('method')\nvar watchers = require('./watchers')\n\nmodule.exports = Method(function(value, watcher) {\n  // Registers a `value` `watcher`, unless it's already registered.\n  var registered = watchers(value)\n  if (registered && registered.indexOf(watcher) < 0)\n    registered.push(watcher)\n  return value\n})\n\n//@ sourceURL=/node_modules/reducers/node_modules/eventual/node_modules/watchables/watch.js"
));

require.define("/node_modules/reducers/node_modules/pending/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/reducers/node_modules/pending/package.json"
));

require.define("/node_modules/reducers/node_modules/pending/await.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*jshint asi: true undef: true es5: true node: true devel: true\n         globalstrict: true forin: true latedef: false supernew: true */\n/*global define: true */\n\n\"use strict\";\n\nvar Method = require('method')\n\n// Set's up a callback to be called once pending\n// value is realized. All object by default are realized.\nmodule.exports = Method(function(value, callback) {\n  callback(value)\n})\n\n//@ sourceURL=/node_modules/reducers/node_modules/pending/await.js"
));

require.define("/node_modules/reducers/node_modules/pending/is.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*jshint asi: true undef: true es5: true node: true devel: true\n         globalstrict: true forin: true latedef: false supernew: true */\n/*global define: true */\n\n\"use strict\";\n\nvar Method = require('method')\n\n// Returns `true` if given `value` is pending, otherwise returns\n// `false`. All types will return false unless type specific\n// implementation is provided to do it otherwise.\nmodule.exports = Method(function() {\n  return false\n})\n\n//@ sourceURL=/node_modules/reducers/node_modules/pending/is.js"
));

require.define("/node_modules/reducers/node_modules/pending/deliver.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*jshint asi: true undef: true es5: true node: true devel: true\n         globalstrict: true forin: true latedef: false supernew: true */\n/*global define: true */\n\n\"use strict\";\n\nvar Method = require('method')\n// Method delivers pending value.\nmodule.exports = Method()\n\n//@ sourceURL=/node_modules/reducers/node_modules/pending/deliver.js"
));

require.define("/node_modules/reducers/node_modules/eventual/when.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*jshint asi: true undef: true es5: true node: true devel: true\n         globalstrict: true forin: true latedef: false supernew: true */\n/*global define: true */\n\n\"use strict\";\n\nvar Method = require(\"method\")\nvar when = Method(function(value, onRealize) {\n  return typeof(onRealize) === \"function\" ? onRealize(value) : value\n})\nwhen.define(Error, function(error, onRealize, onError) {\n  return typeof(onError) === \"function\" ? onError(error) : error\n})\n\nmodule.exports = when\n\n//@ sourceURL=/node_modules/reducers/node_modules/eventual/when.js"
));

require.define("/node_modules/reducers/error.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*jshint asi: true undef: true es5: true node: true browser: true devel: true\n         forin: true latedef: false globalstrict: true */\n\n\"use strict\";\n\nvar Box = require(\"./box\")\n\n// Exported function can be used for boxing values. This boxing can be used\n// to identify errors.\nexports.error = Box(\"Error in the sequence\")\n\n//@ sourceURL=/node_modules/reducers/error.js"
));

require.define("/node_modules/reducers/convert.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*jshint asi: true undef: true es5: true node: true browser: true devel: true\n         forin: true latedef: false globalstrict: true */\n\n\"use strict\";\n\nvar accumulate = require(\"./accumulate\")\nvar make = Object.create || (function() {\n  function Type() {}\n  return function make(prototype) {\n    Type.prototype = prototype\n    return new Type()\n  }\n})()\n\n\nfunction convert(source, method) {\n  /**\n  Function takes `source` sequence and returns new `sequence` such\n  that calling `accumulate` on it will delegate to given `method`.\n  This is to make sequence conversions lazy.\n\n  // Code will produce sequence that is just like `source` but with\n  // each element being incremented.\n  function increment(source) {\n    return convert(source, function(sequence, f, start) {\n      return accumulate(source, function(value, result) {\n        return f(value + 1, result)\n      }, start)\n    })\n  }\n  into(increment([ 1, 2, 3 ])) => [ 2, 3, 4 ]\n  **/\n  return accumulate.implement(make(source), method)\n}\n\nmodule.exports = convert\n\n//@ sourceURL=/node_modules/reducers/convert.js"
));

require.define("/node_modules/reducers/signal.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/* vim:set ts=2 sw=2 sts=2 expandtab */\n/*jshint asi: true undef: true es5: true node: true devel: true\n         forin: true latedef: false globalstrict: true */\n\n'use strict';\n\nvar Method = require(\"method\")\nvar accumulate = require(\"./accumulate\")\nvar end = require(\"./end\")\nvar accumulated = require(\"./accumulated\")\nvar emit = require(\"./emit\")\nvar close = require(\"./close\")\n\nvar accumulator = \"accumulator@\" + module.id\nvar state = \"state@\" + module.id\nvar closed = \"closed@\" + module.id\n\n// Define a `Signal` data-type. A signal is a sequence of \"events over time\".\n// \n// Signals are a building block for creating Reactive event-driven programs.\n// \n// If you're familiar with libraries like Node EventEmitter, you might have\n// an easy time thinking of Signal as a single event channel. The key difference\n// is that signal represents events-over-time as a reducible value. This means\n// the events-over-time can be transformed, filtered forked and joined just like\n// an array.\nfunction Signal() {}\n\n// Signals can be either open or closed. An open signal may `emit` new values.\n// A signal that is not open may not emit.\n// \n// Define helper that allow you to test the state of a signal.\nfunction isClosed(signal) {\n  return !!signal[closed]\n}\nfunction isOpen(signal) {\n  return !!signal[accumulator]\n}\n\n// Implement accumulate protocol on signals, making them reducible.\naccumulate.define(Signal, function(signal, next, initial) {\n  // Signals may only be reduced by one consumer function.\n  // Other data types built on top of signal may allow for more consumers.\n  if (isOpen(signal)) throw Error('Signal is being consumed')\n  if (isClosed(signal)) return next(end(), initial)\n  signal[accumulator] = next\n  signal[state] = initial\n  return signal\n})\n\nemit.define(Signal, function(signal, value) {\n  /**\n  Emit a new value for signal.\n  Throws an exception if the signal is not open for emitting.\n  **/\n  if (isClosed(signal)) throw Error('Signal is already closed')\n  if (!isOpen(signal)) throw Error('Signal is not open')\n  var result = signal[accumulator](value, signal[state])\n  if (result && result.is === accumulated) {\n    close(signal)\n  } else {\n    signal[state] = result\n  }\n  return signal\n})\n\nclose.define(Signal, function(signal, value) {\n  /**\n  Close a signal, preventing new values from being emitted.\n  Throws an exception if the signal is already closed.\n  **/\n  if (isClosed(signal)) throw Error('Signal is already closed')\n  if (value !== undefined) emit(signal, value)\n  var result = signal[state]\n  var next = signal[accumulator]\n  signal[closed] = true\n  signal[accumulator] = null\n  signal[state] = null\n  next(end(), result)\n\n  return signal\n})\n\n// Define a factory function for the `Signal` constructor.\n// Assign other signal functions to the factory function object and export\n// the result.\nfunction signal() { return new Signal() }\nsignal.type = Signal\nsignal.isOpen = isOpen\nsignal.isClosed = isClosed\nsignal.emit = emit\nsignal.close = close\n\nmodule.exports = signal\n\n\n//@ sourceURL=/node_modules/reducers/signal.js"
));

require.define("/node_modules/reducers/emit.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*jshint asi: true undef: true es5: true node: true browser: true devel: true\n         forin: true latedef: false globalstrict: true */\n\n\"use strict\";\n\nvar Method = require(\"method\")\n\nvar emit = Method()\n\nmodule.exports = emit\n\n//@ sourceURL=/node_modules/reducers/emit.js"
));

require.define("/node_modules/reducers/close.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*jshint asi: true undef: true es5: true node: true devel: true\n         forin: true latedef: false globalstrict: true */\n\n\"use strict\";\n\nvar Method = require(\"method\")\n\n\nvar close = Method()\nmodule.exports = close\n\n//@ sourceURL=/node_modules/reducers/close.js"
));

require.define("/node_modules/monotonic-timestamp/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/monotonic-timestamp/package.json"
));

require.define("/node_modules/monotonic-timestamp/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var _last = 0\nvar _count = 1\n\nmodule.exports = \nfunction () {\n  var t = Date.now()\n  var _t = t\n  if(_last == t) {\n    _t += ((_count++)/1000) \n  } \n  else _count = 1 \n\n  _last = t\n\n  return _t\n}\n\n\n//@ sourceURL=/node_modules/monotonic-timestamp/index.js"
));

require.define("/node_modules/reducers/reductions.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*jshint asi: true undef: true es5: true node: true browser: true devel: true\n         forin: true latedef: false globalstrict: true */\n\n'use strict';\n\nvar convert = require(\"./convert\")\nvar accumulate = require(\"./accumulate\")\n\nfunction reductions(source, f, initial) {\n  /**\n  Returns `reducible` collection of the intermediate values of the reduction\n  (as per reduce) of `source` by `f`, starting with `initial` value.\n\n  ## Example\n\n  var numbers = reductions([1, 1, 1, 1], function(accumulated, value) {\n    return accumulated + value\n  }, 0)\n  print(numbers) // => <stream 1 2 3 4 />\n  **/\n  return convert(source, function(self, next, result) {\n    var state = initial\n    accumulate(source, function(value, result) {\n      state = value && value.isBoxed ? next(value, result) : f(state, value)\n      return next(state, result)\n    }, result)\n  })\n}\n\nmodule.exports = reductions\n\n//@ sourceURL=/node_modules/reducers/reductions.js"
));

require.define("/lib/pipe.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var reduce = require(\"reducers/reduce\")\nvar emit = require(\"reducers/emit\")\n\nmodule.exports = pipe\n\nfunction pipe(input, output) {\n    reduce(input, function(_, x) {\n        emit(output, x)\n    })\n}\n\n//@ sourceURL=/lib/pipe.js"
));

require.define("/node_modules/reducers/reduce.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*jshint asi: true undef: true es5: true node: true browser: true devel: true\n         forin: true latedef: false globalstrict: true */\n\n'use strict';\n\nvar accumulate = require(\"./accumulate\")\nvar deliver = require(\"pending/deliver\")\nvar defer = require(\"eventual/defer\")\nvar when = require(\"eventual/when\")\nvar end = require(\"./end\")\nvar error = require(\"./error\")\n\nfunction reduce(source, f, state) {\n  var promise = defer()\n  accumulate(source, function(value) {\n    if (value && value.isBoxed) {\n      if (value.is === end) deliver(promise, state)\n      if (value.is === error) deliver(promise, value.value)\n      return value\n    } else {\n      state = f(state, value)\n      return state\n    }\n  }, state)\n  return when(promise)\n}\n\nmodule.exports = reduce\n\n//@ sourceURL=/node_modules/reducers/reduce.js"
));

require.define("/node_modules/reducers/node_modules/eventual/defer.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*jshint asi: true undef: true es5: true node: true devel: true\n         globalstrict: true forin: true latedef: false supernew: true */\n/*global define: true */\n\n\"use strict\";\n\nvar Eventual = require(\"./type\")\nmodule.exports = function defer() { return new Eventual() }\n\n\n//@ sourceURL=/node_modules/reducers/node_modules/eventual/defer.js"
));

require.define("/lib/forEach.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var reduce = require(\"reducers/reduce\")\n\nmodule.exports = forEach\n\nfunction forEach(reducible, callback) {\n    return reduce(reducible, invoke, null)\n\n    function invoke(acc, value) {\n        return callback(value)\n    }\n}\n\n//@ sourceURL=/lib/forEach.js"
));

require.define("/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index\"}\n//@ sourceURL=/package.json"
));

require.define("/persist.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var emit = require(\"reducers/emit\")\n    , store = require(\"local-store\")(\"reflex-todo\")\n    , extend = require(\"xtend\")\n\n    , forEach = require(\"./lib/forEach\")\n    , initial = require(\"./initial\")\n\nmodule.exports = persist\n\nfunction persist(state) {\n    forEach(state.output, saveState)\n\n    var initialState = store.get(\"state\")\n\n    if (initialState) {\n        emit(state.input, initialState)\n    }\n\n    // Initial manipulations for debugging purposes\n    // initial(state.input)\n}\n\nfunction saveState(current) {\n    var clone = extend({}, current)\n\n    ;delete clone.operation\n    // console.log(\"current\", current)\n    store.set(\"state\", clone)\n}\n\n//@ sourceURL=/persist.js"
));

require.define("/node_modules/local-store/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index\"}\n//@ sourceURL=/node_modules/local-store/package.json"
));

require.define("/node_modules/local-store/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var LocalStorage = typeof window !== \"undefined\" && window.localStorage\n    , prefixes = {}\n    , store\n\nif (LocalStorage) {\n    store = createLocalStore\n} else {\n    store = createMemoryStore\n}\n\nstore.createMemoryStore = createMemoryStore\nstore.createLocalStore = createLocalStore\n\nmodule.exports = store\n\nfunction createLocalStore(prefix) {\n    prefix = prefix || \"\"\n\n    return {\n        set: storeSet\n        , get: storeGet\n        , delete: storeDelete\n    }\n\n    function storeSet(key, value) {\n        LocalStorage.setItem(prefix + \".\" + key, JSON.stringify(value))\n    }\n\n    function storeGet(key) {\n        var str = LocalStorage.getItem(prefix + \".\" + key)\n        if (str === null) {\n            return null\n        }\n        return JSON.parse(str)\n    }\n\n    function storeDelete(key) {\n        return LocalStorage.removeItem(prefix + \".\" + key)\n    }\n}\n\nfunction createMemoryStore(prefix) {\n    var store = {}\n    if (prefix) {\n        store = prefixes[prefix]\n\n        if (!store) {\n            store = prefixes[prefix] = {}\n        }\n    }\n\n    return {\n        set: storeSet\n        , get: storeGet\n        , delete: storeDelete\n    }\n\n    function storeSet(key, value) {\n        store[key] = value\n    }\n\n    function storeGet(key) {\n        if (!(key in store)) {\n            return null\n        }\n\n        return store[key]\n    }\n\n    function storeDelete(key) {\n        return delete store[key]\n    }\n}\n//@ sourceURL=/node_modules/local-store/index.js"
));

require.define("/node_modules/xtend/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index\"}\n//@ sourceURL=/node_modules/xtend/package.json"
));

require.define("/node_modules/xtend/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = extend\n\nfunction extend(target) {\n    for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i],\n            keys = Object.keys(source)\n\n        for (var j = 0; j < keys.length; j++) {\n            var name = keys[j]\n            target[name] = source[name]\n        }\n    }\n\n    return target\n}\n//@ sourceURL=/node_modules/xtend/index.js"
));

require.define("/initial.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var emit = require(\"reducers/emit\")\n\nmodule.exports = initial\n\nfunction initial(state) {\n    emit(state, {\n        \"todo:1\": {\n            completed: false\n            , title: \"foo\"\n        }\n    })\n\n    setTimeout(function () {\n        emit(state, {\n            \"todo:1\": {\n                completed: true\n                , title: \"bar\"\n            }\n        })\n    }, 1000)\n\n    setTimeout(function () {\n        emit(state, {\n            \"todo:1\": null\n        })\n    }, 2000)\n}\n\n//@ sourceURL=/initial.js"
));

require.define("/todo/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var channel = require(\"reducers/channel\")\n    , buffer = require(\"reducers/buffer\")\n    , flatten = require(\"reducers/flatten\")\n    , insert = require(\"insert\")\n    , prepend = insert.prepend\n    , append = insert.append\n\n    , html = require(\"../lib/html\")\n    , forEach = require(\"../lib/forEach\")\n    , entity = require(\"../reflex/entity\")\n    , todoListHtml = require(\"./html/todoList\")\n    , writers = require(\"./writers\")\n    , readers = require(\"./readers\")\n    , entities = require(\"./entities\")\n    , fork = require(\"./forks\")\n    , operations = require(\"./operations\")\n\nmodule.exports = todoList\n\nfunction todoList(state) {\n    var component = html(todoListHtml)\n        , forks = fork(state)\n        , stream = flatten([\n            children(forks, component)\n            , operations(state)\n        ])\n\n    stream.view = component.root\n\n    return stream\n}\n\nfunction children(forks, component) {\n    var todosComponents = entities.todo(forks.todoChanges)\n        , itemsLeft = writers.itemsLeft(forks.counters)\n        , completedCount = entities.completedCount(forks.counters)\n        , allCompleted = entities.allCompleted(forks.counters)\n        , newTodos = readers.input(component)\n\n    forEach(todosComponents.views, function (view) {\n        append(component.list, view.root)\n    })\n\n    forEach(itemsLeft, function (view) {\n        prepend(component.footer, view.root)\n    })\n\n    forEach(completedCount.views, function (view) {\n        append(component.footer, view.root)\n    })\n\n    forEach(allCompleted.views, function (view) {\n        prepend(component.main, view.root)\n    })\n\n    return flatten([newTodos, completedCount\n        , allCompleted, todosComponents])\n}\n\n//@ sourceURL=/todo/index.js"
));

require.define("/node_modules/reducers/buffer.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/* vim:set ts=2 sw=2 sts=2 expandtab */\n/*jshint asi: true undef: true es5: true node: true browser: true devel: true\n         forin: true latedef: false globalstrict: true */\n\n\"use strict\";\n\nvar convert = require(\"./convert\")\nvar accumulate = require(\"./accumulate\")\n\nvar queued = \"queued@\" + module.id\nvar input = \"input@\" + module.id\nvar forward = \"forward@\" + module.id\nvar state = \"state@\" + module.id\n\nfunction drain(buffer, next, result) {\n  var values = buffer[queued]\n  while (values.length) result = next(values.shift(), result)\n  buffer[queued] = null\n  return result\n}\n\nfunction isDrained(buffer) {\n  return buffer[queued] === null\n}\n\nfunction buffer(source) {\n  /**\n  Buffer a reducible, saving items from reducible in-memory until a consumer\n  reduces the buffer.\n\n  Reducibles are not required to expose a data container for the sequence they\n  represent, meaning items in the reducible may not be represented in-memory\n  at all. This is great for representing potentially infinite data structures\n  like \"mouse clicks over time\", or \"data streamed from server\". However,\n  sometimes it's important to reduce all items in the reducible, even if the\n  item was emitted at a point in the past. This is where buffer comes in handy.\n  It stores a backlog of previously emitted items in-memory until you're\n  ready to consume.\n  **/\n  var self = convert(source, buffer.accumulate)\n  self[state] = null\n  self[input] = source\n  self[queued] = []\n  self[forward] = function(value) {\n    self[queued].push(value)\n  }\n  accumulate(source, function(value) {\n    self[state] = self[forward](value, self[state])\n  })\n  return self\n}\nbuffer.accumulate = function(buffer, next, initial) {\n  // If buffer has already been drained accumulate from the original source.\n  if (isDrained(buffer)) return accumulate(buffer[input], next, initial)\n  // Otherwise, drain the buffer, passing items to the accumulating function.\n  buffer[state] = drain(buffer, next, initial)\n  // Overshadow forward function, insuring that\n  // future values are not buffered, and are instead passed directly to the\n  // accumulation function.\n  buffer[forward] = next\n  return buffer\n}\n\nmodule.exports = buffer\n\n//@ sourceURL=/node_modules/reducers/buffer.js"
));

require.define("/node_modules/reducers/flatten.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*jshint asi: true undef: true es5: true node: true browser: true devel: true\n         forin: true latedef: false globalstrict: true */\n\n'use strict';\n\nvar reduce = require(\"./reduce\")\nvar reducible = require(\"./reducible\")\n\nfunction flatten(source) {\n  /**\n  Flattens given sequence of sequences to a sequence with items of\n  all nested sequences. Note that items in the resulting sequence\n  are ordered by the time rather then index, in other words if\n  item from the second sub-sequence is deliver earlier then the item\n  from first sub-sequence it will in appear earlier in the resulting\n  sequence too. If you need to keep order by index you should enforce\n  sequential ordering by wrapping `source` into `sequential` before\n  passing it to flatten.\n\n  print(flatten([ [1, 2], [ 3, 4 ] ]))  // => <stream 1 2 3 4 />\n  **/\n  return reducible(source, function(_, next, initial) {\n    return reduce(source, function(result, nested) {\n      return reduce(nested, function(result, value) {\n        return next(result, value)\n      }, result)\n    }, initial)\n  })\n}\n\nmodule.exports = flatten\n\n//@ sourceURL=/node_modules/reducers/flatten.js"
));

require.define("/node_modules/reducers/reducible.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*jshint asi: true undef: true es5: true node: true browser: true devel: true\n         forin: true latedef: false globalstrict: true */\n\n'use strict';\n\nvar convert = require(\"./convert\")\nvar when = require(\"eventual/when\")\nvar end = require(\"./end\")\nvar error = require(\"./error\")\n\nfunction reducible(source, f) {\n  return convert(source, function(source, next, initial) {\n    var result = f(source, function forward(result, value) {\n      return next(value, result)\n    }, initial)\n    when(result, function(value) {\n      next(end(), value)\n    }, function(e) {\n      next(error(e))\n    })\n  })\n}\n\nmodule.exports = reducible\n\n//@ sourceURL=/node_modules/reducers/reducible.js"
));

require.define("/lib/html.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var unpack = require(\"unpack-element\")\n    , Element = require(\"fragment\").Element\n\nmodule.exports = html\n\nfunction html(src) {\n    return unpack(Element(src))\n}\n\n//@ sourceURL=/lib/html.js"
));

require.define("/node_modules/unpack-element/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index\"}\n//@ sourceURL=/node_modules/unpack-element/package.json"
));

require.define("/node_modules/unpack-element/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var walk = require(\"dom-walk\")\n\nmodule.exports = unpack\n\nfunction unpack(elem) {\n    var struct = {}\n    walk([elem], function (node) {\n        if (node.id) {\n            var id = node.id\n            node.removeAttribute(\"id\")\n            struct[id] = node\n        }\n    })\n    if (!struct.root) {\n        struct.root = elem\n    }\n    return struct\n}\n//@ sourceURL=/node_modules/unpack-element/index.js"
));

require.define("/node_modules/unpack-element/node_modules/dom-walk/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index\"}\n//@ sourceURL=/node_modules/unpack-element/node_modules/dom-walk/package.json"
));

require.define("/node_modules/unpack-element/node_modules/dom-walk/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var slice = Array.prototype.slice\n\nmodule.exports = iterativelyWalk\n\nfunction iterativelyWalk(nodes, cb) {\n    nodes = slice.call(nodes)\n\n    while(nodes.length) {\n        var node = nodes.shift(),\n            ret = cb(node)\n\n        if (ret) {\n            return ret\n        }\n\n        if (node.childNodes.length) {\n            nodes = slice.call(node.childNodes).concat(nodes)\n        }\n    }\n}\n//@ sourceURL=/node_modules/unpack-element/node_modules/dom-walk/index.js"
));

require.define("/node_modules/fragment/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/fragment/package.json"
));

require.define("/node_modules/fragment/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"Fragment.Element = Element\n\nmodule.exports = Fragment\n\nfunction Fragment(html, elementName) {\n    var el = document.createElement(elementName || \"div\")\n        , fragment = document.createDocumentFragment()\n\n    el.innerHTML = html\n\n    while (el.hasChildNodes()) {\n        fragment.appendChild(el.firstChild)\n    }\n\n    return fragment\n}\n\nfunction Element(html, elementName) {\n    var el = document.createElement(elementName || \"div\")\n\n    el.innerHTML = html\n\n    var child = el.firstChild\n    el.removeChild(child)\n\n    return child\n}\n//@ sourceURL=/node_modules/fragment/index.js"
));

require.define("/reflex/entity.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var channel = require(\"reducers/channel\")\nvar buffer = require(\"reducers/buffer\")\nvar emit = require(\"reducers/emit\")\nvar forEach = require(\"../lib/forEach\")\nvar pipe = require(\"../lib/pipe\")\n\nmodule.exports = entity\n\nfunction entity(read, write) {\n    return function make(input, options) {\n        // Create / hook an instance using options passed\n        var instances = write(input, options)\n        var stream = buffer(channel())\n\n        forEach(instances, function(instance) {\n            pipe(read(instance), stream)\n        })\n\n        stream.views = instances\n        return stream\n    }\n}\n\n//@ sourceURL=/reflex/entity.js"
));

require.define("/todo/html/todoList.html",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = '<section class=\"todoapp\">\\n    <header class=\"header\">\\n        <h1>todos</h1>\\n        <input id=\"input\"\\n            class=\"new-todo\"\\n            placeholder=\"What needs to be done?\"\\n            autofocus\\n        />\\n    </header>\\n    <!-- This section should be hidden by default and shown when there are todos -->\\n    <section class=\"main\" id=\"main\">\\n        <ul id=\"list\" class=\"todo-list\">\\n            <!-- These are here just to show the structure of the list items -->\\n            <!-- List items should get the class `editing` when editing and `completed` when marked as completed -->\\n            <!--\\n            <li class=\"completed\">\\n                <div class=\"view\">\\n                    <input class=\"toggle\" type=\"checkbox\" checked>\\n                    <label>Create a TodoMVC template</label>\\n                    <button class=\"destroy\"></button>\\n                </div>\\n                <input class=\"edit\" value=\"Create a TodoMVC template\">\\n            </li>\\n            <li>\\n                <div class=\"view\">\\n                    <input class=\"toggle\" type=\"checkbox\">\\n                    <label>Rule the web</label>\\n                    <button class=\"destroy\"></button>\\n                </div>\\n                <input class=\"edit\" value=\"Rule the web\">\\n            </li>\\n            -->\\n        </ul>\\n    </section>\\n    <!-- This footer should hidden by default and shown when there are todos -->\\n    <footer id=\"footer\" class=\"footer\">\\n        <!-- This should be `0 items left` by default -->\\n\\n        <!-- Remove this if you dont implement routing -->\\n        <ul id=\"filters\" class=\"filters\">\\n            <li>\\n                <a data-id=\"all\" class=\"selected\" href=\"#/\">All</a>\\n            </li>\\n            <li>\\n                <a data-id=\"active\" href=\"#/active\">Active</a>\\n            </li>\\n            <li>\\n                <a data-id=\"completed\" href=\"#/completed\">Completed</a>\\n            </li>\\n        </ul>\\n    </footer>\\n</section>\\n'\n//@ sourceURL=/todo/html/todoList.html"
));

require.define("/todo/writers.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var remove = require(\"insert\").remove\n\n    , html = require(\"../lib/html\")\n    , writer = require(\"../reflex/writer\")\n    , forEach = require(\"../lib/forEach\")\n    , itemsLeftHtml = require(\"./html/itemsLeft\")\n\nmodule.exports = {\n    itemsLeft: writer(function swap(component, counter) {\n            var text = component.countText\n                , count = counter.remaining\n\n            if (count === 1) {\n                text.textContent = \"item left\"\n            } else {\n                text.textContent = \"items left\"\n            }\n\n            component.count.textContent = count\n        }, function open(options, value) {\n            return html(itemsLeftHtml)\n        }, function close(component) {\n            remove(component.root)\n        })\n}\n\n\n\n//@ sourceURL=/todo/writers.js"
));

require.define("/reflex/writer.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/* vim:set ts=2 sw=2 sts=2 expandtab */\n/*jshint asi: true undef: true es5: true node: true browser: true devel: true\n         forin: true latedef: false globalstrict: true*/\n\n\"use strict\";\n\nvar reduce = require(\"reducers/reduce\")\nvar buffer = require(\"reducers/buffer\")\nvar channel = require(\"reducers/channel\")\nvar emit = require(\"reducers/emit\")\nvar isSummary = require(\"./summaries\").isSummary\n\nmodule.exports = writer\n\nfunction writer(swap, open, close) {\n    var hash = {}\n\n    return function write(input, options) {\n        var stream = buffer(channel())\n        var output\n\n        // var output = open(options)\n        reduce(input, function(_, update) {\n            if (isSummary(update)) {\n                return handleSummary(update)\n            }\n\n            if (!output && open) {\n                output = open(options)\n                emit(stream, output)\n            }\n\n            if (update === null) {\n                close(output, options)\n            } else {\n                swap(output, update)\n            }\n        })\n\n        return stream\n\n        function handleSummary(update) {\n            var id = update.name\n            var value = update.value\n            var type = update.type\n            var oldValue = update.oldValue\n            var current = hash[id]\n            var res\n\n            if (type === \"new\") {\n                var output = hash[id] = open(options, value)\n\n                res = swap(output, value)\n\n                emit(stream, output)\n            } else if (type === \"updated\") {\n                res = swap(current, value, oldValue)\n            } else if (type === \"deleted\") {\n                close(current, options)\n                ;delete hash[id]\n            }\n\n            if (res) {\n                hash[id] = res\n            }\n        }\n    }\n}\n\n//@ sourceURL=/reflex/writer.js"
));

require.define("/reflex/summaries.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var expand = require(\"reducers/expand\")\nvar delta = require(\"./state\").delta\n\nsummaries.type = Summary\nsummaries.isSummary = isSummary\n\nmodule.exports = summaries\n\nfunction Summary() {}\n\nfunction summaries(stream, initial) {\n    var previous = initial || {}\n\n    return expand(stream, createSummary)\n\n    function createSummary(current) {\n        var diff = current[delta]\n\n        var list = Object.keys(diff)\n            .map(function (id) {\n                var value = diff[id]\n                var summary = new Summary()\n                var oldValue = previous[id]\n\n                if (!oldValue) {\n                    summary.type = \"new\"\n                } else if (value === null) {\n                    summary.type = \"deleted\"\n                    summary.oldValue = oldValue\n                } else {\n                    summary.type = \"updated\"\n                    summary.oldValue = oldValue\n                }\n\n                summary.name = id\n                summary.value = value\n\n                return summary\n            })\n\n        previous = current\n\n        return list\n    }\n}\n\nfunction isSummary(summary) {\n    return summary instanceof Summary\n}\n\n//@ sourceURL=/reflex/summaries.js"
));

require.define("/node_modules/reducers/expand.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*jshint asi: true undef: true es5: true node: true browser: true devel: true\n         forin: true latedef: false globalstrict: true */\n\n'use strict';\n\nvar flatten = require(\"./flatten\")\nvar map = require(\"./map\")\n\nfunction expand(source, f) {\n  /**\n  Takes `source` sequence maps each item via `f` to a new sequence\n  and then flattens them down into single form sequence. Note that\n  returned sequence will have items ordered by time and not by index,\n  if you wish opposite you need to force sequential order by wrapping\n  `source` into `sequential` before passing it.\n\n  ## Example\n\n  var sequence = expand([ 1, 2, 3 ], function(x) {\n    return [ x, x * x ]\n  })\n  print(sequence)   // => <stream 1 1 2 4 3 9 />\n\n  **/\n  return flatten(map(source, f))\n}\n\nmodule.exports = expand\n\n\n//@ sourceURL=/node_modules/reducers/expand.js"
));

require.define("/node_modules/reducers/map.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*jshint asi: true undef: true es5: true node: true browser: true devel: true\n         forin: true latedef: false globalstrict: true */\n\n'use strict';\n\nvar transform = require(\"./transform\")\n\nfunction map(source, f) {\n  /**\n  Returns transformed version of given `source` where each item of it\n  is mapped using `f`.\n\n  ## Example\n\n  var data = [{ name: \"foo\" }, { name: \"bar\" }]\n  var names = map(data, function(value) { return value.name })\n  print(names) // => <stream \"foo\" \"bar\" />\n  **/\n  return transform(source, function(next, value, accumulated) {\n    return next(f(value), accumulated)\n  })\n}\n\nmodule.exports = map\n\n\n//@ sourceURL=/node_modules/reducers/map.js"
));

require.define("/node_modules/reducers/transform.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*jshint asi: true undef: true es5: true node: true browser: true devel: true\n         forin: true latedef: false globalstrict: true */\n\n\"use strict\";\n\nvar convert = require(\"./convert\")\nvar accumulate = require(\"./accumulate\")\n\nfunction transform(source, f) {\n  /**\n  Function takes `source` sequence and an `f` function, which is used to\n  intercept each non-boxed item of the sequence. It is invoked with `next`\n  continuation function, sequence `value` being yielded and accumulated\n  `result`. `f` is supposed to call `next` with a intercepted `value` and\n  `result`.\n\n  This enables writing transformation functions that don't deal with\n  back-channel in form of boxed values. In other words transformation\n  functions like `filter` and `map` just intercept values but they don't\n  change size of sequence or handle errors there for they want to bypass\n  back-channel by using transform`.\n\n  For examples of use see `map`, `filter` etc... Some functions that want\n  to change size of sequence should use `transformer` instead, for examples\n  of those see `take`, `takeWhile`.\n  **/\n  return convert(source, function(self, next, initial) {\n    accumulate(source, function(value, result) {\n      return value && value.isBoxed ? next(value, result)\n                                    : f(next, value, result)\n    }, initial)\n  })\n}\n\nmodule.exports = transform\n\n//@ sourceURL=/node_modules/reducers/transform.js"
));

require.define("/todo/html/itemsLeft.html",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = '<span class=\"todo-count\">\\n    <strong id=\"count\">0</strong>\\n    <span id=\"countText\">items left</span>\\n</span>\\n'\n//@ sourceURL=/todo/html/itemsLeft.html"
));

require.define("/todo/readers.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*global open:true */\n\nvar open = require(\"dom-reduce/event\")\n    , filter = require(\"reducers/filter\")\n    , map = require(\"reducers/map\")\n\n    , factory = require(\"../reflex/factory\")\n    , equal = require(\"../lib/equal\")\n    , method = require(\"../lib/method\")\n\n    , ENTER = 13\n\nmodule.exports = {\n    input: function read(component) {\n        var events = open(component.input, \"keypress\")\n            , enters = filter(events, equal(\"keyCode\", ENTER))\n            , values = filter(map(enters, getFieldValue), Boolean)\n            , trimmed = map(values, method(\"trim\"))\n            , todos = map(trimmed\n                , factory(\"todo\", function (title) {\n                    return {\n                        title: title\n                        , completed: false\n                    }\n                }))\n\n        return todos\n    }\n    , filters: function read(component) {\n        var filters = component.filters\n    }\n}\n\nfunction getFieldValue(event) {\n    var input = event.target\n        , value = input.value\n\n    input.value = \"\"\n\n    return value\n}\n\n//@ sourceURL=/todo/readers.js"
));

require.define("/node_modules/dom-reduce/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/dom-reduce/package.json"
));

require.define("/node_modules/dom-reduce/event.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/* vim:set ts=2 sw=2 sts=2 expandtab */\n/*jshint asi: true undef: true es5: true node: true browser: true devel: true\n         forin: true latedef: false globalstrict: true */\n\n\"use strict\";\n\nvar channel = require(\"reducers/channel\")\nvar emit = require(\"reducers/emit\")\nvar convert = require(\"reducers/convert\")\nvar accumulated = require(\"reducers/accumulated\")\nvar end = require(\"reducers/end\")\n\nfunction open(target, type, options) {\n  /**\n  Capture events on a DOM element, converting them to a reducible channel.\n  Returns a reducible channel.\n\n  ## Example\n\n      var allClicks = open(document.documentElement, 'click')\n      var clicksOnMyTarget = filter(allClicks, function (click) {\n        return click.target === myTarget\n      })\n  **/\n  var capture = options && options.capture || false\n  return convert({}, function(self, next, state) {\n    function handler(event) {\n      state = next(event, state)\n      //  When channel is marked as accumulated, remove event listener.\n      if (state && state.is === accumulated) {\n        if (target.removeEventListener)\n          target.removeEventListener(type, handler, capture)\n        else\n          target.detachEvent(type, handler, capture)\n        next(end(), state.value)\n      }\n    }\n    if (target.addEventListener) target.addEventListener(type, handler, capture)\n    else target.attachEvent(\"on\" + type, handler)\n  })\n}\n\nmodule.exports = open\n\n//@ sourceURL=/node_modules/dom-reduce/event.js"
));

require.define("/node_modules/reducers/filter.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*jshint asi: true undef: true es5: true node: true browser: true devel: true\n         forin: true latedef: false globalstrict: true */\n\n'use strict';\n\nvar transform = require(\"./transform\")\n\nfunction filter(source, predicate) {\n  /**\n  Composes filtered version of given `source`, such that only items contained\n  will be once on which `f(item)` was `true`.\n\n  ## Example\n\n  var digits = filter([ 10, 23, 2, 7, 17 ], function(value) {\n    return value >= 0 && value <= 9\n  })\n  print(digits) // => <stream 2 7 />\n  **/\n  return transform(source, function(next, value, accumulated) {\n    return predicate(value) ? next(value, accumulated) : accumulated\n  })\n}\n\nmodule.exports = filter\n\n//@ sourceURL=/node_modules/reducers/filter.js"
));

require.define("/reflex/factory.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var uuid = require(\"node-uuid\")\n    , extend = require(\"xtend\")\n\nmodule.exports = factory\n\n/*\n    factory(component, function (completed) {\n        return { completed: completed }\n    }) -> {\n        id: {\n            id: #component.id\n            , completed: completed\n        }\n    }\n\n    factory(function (value) {\n        return { value: value }\n    }) -> {\n        id: {\n            id: :uuid()\n            , value: value\n        }\n    }\n\n    factory(prefix, function (value) {\n        return { value: value }\n    }) -> {\n        id: {\n            id: prefix:uuid()\n            , value: value\n        }\n    }\n\n    factory(prefix, { completed: true })\n        -> {\n            id: {\n                id: prefix:uuid()\n                , value: value\n            }\n        }\n\n    factory(function (component) {\n        return component.id\n    }) -> {\n            id: null\n        }\n\n    factory({ completed: false })\n        -> {\n            [first argument].id: {\n                completed: false\n            }\n        }\n*/\nfunction factory(component, creator) {\n    var prefix = \"\"\n        , orig\n\n    if (typeof component === \"string\") {\n        prefix = component\n        component = null\n    } else if (arguments.length === 1) {\n        creator = component\n        component = null\n    }\n\n    if (typeof creator !== \"function\") {\n        orig = creator\n        creator = wrap\n    }\n\n    return create\n\n    function create(first) {\n        var result = creator.apply(this, arguments)\n            , id\n            , changes = {}\n\n        if (component) {\n            id = component.id\n        } else if (typeof result === \"string\") {\n            id = result\n            result = null\n        } else if (result && result.id) {\n            id = result.id\n        } else if (prefix) {\n            id = prefix + \":\" + uuid()\n        } else if (first.id) {\n            id = first.id\n        } else {\n            id = uuid()\n        }\n\n        console.log(\"id\", id, first, result, component)\n\n        if (result) {\n            result.id = id\n        }\n\n        changes[id] = result\n\n        return changes\n    }\n\n    function wrap() {\n        return orig !== null ? extend({}, orig) : orig\n    }\n}\n\n//@ sourceURL=/reflex/factory.js"
));

require.define("/node_modules/node-uuid/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"./uuid.js\"}\n//@ sourceURL=/node_modules/node-uuid/package.json"
));

require.define("/node_modules/node-uuid/uuid.js",Function(['require','module','exports','__dirname','__filename','process','global'],"//     uuid.js\n//\n//     (c) 2010-2012 Robert Kieffer\n//     MIT License\n//     https://github.com/broofa/node-uuid\n(function() {\n  var _global = this;\n\n  // Unique ID creation requires a high quality random # generator.  We feature\n  // detect to determine the best RNG source, normalizing to a function that\n  // returns 128-bits of randomness, since that's what's usually required\n  var _rng;\n\n  // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html\n  //\n  // Moderately fast, high quality\n  if (typeof(require) == 'function') {\n    try {\n      var _rb = require('crypto').randomBytes;\n      _rng = _rb && function() {return _rb(16);};\n    } catch(e) {}\n  }\n\n  if (!_rng && _global.crypto && crypto.getRandomValues) {\n    // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto\n    //\n    // Moderately fast, high quality\n    var _rnds8 = new Uint8Array(16);\n    _rng = function whatwgRNG() {\n      crypto.getRandomValues(_rnds8);\n      return _rnds8;\n    };\n  }\n\n  if (!_rng) {\n    // Math.random()-based (RNG)\n    //\n    // If all else fails, use Math.random().  It's fast, but is of unspecified\n    // quality.\n    var  _rnds = new Array(16);\n    _rng = function() {\n      for (var i = 0, r; i < 16; i++) {\n        if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n        _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n      }\n\n      return _rnds;\n    };\n  }\n\n  // Buffer class to use\n  var BufferClass = typeof(Buffer) == 'function' ? Buffer : Array;\n\n  // Maps for number <-> hex string conversion\n  var _byteToHex = [];\n  var _hexToByte = {};\n  for (var i = 0; i < 256; i++) {\n    _byteToHex[i] = (i + 0x100).toString(16).substr(1);\n    _hexToByte[_byteToHex[i]] = i;\n  }\n\n  // **`parse()` - Parse a UUID into it's component bytes**\n  function parse(s, buf, offset) {\n    var i = (buf && offset) || 0, ii = 0;\n\n    buf = buf || [];\n    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {\n      if (ii < 16) { // Don't overflow!\n        buf[i + ii++] = _hexToByte[oct];\n      }\n    });\n\n    // Zero out remaining bytes if string was short\n    while (ii < 16) {\n      buf[i + ii++] = 0;\n    }\n\n    return buf;\n  }\n\n  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**\n  function unparse(buf, offset) {\n    var i = offset || 0, bth = _byteToHex;\n    return  bth[buf[i++]] + bth[buf[i++]] +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] +\n            bth[buf[i++]] + bth[buf[i++]] +\n            bth[buf[i++]] + bth[buf[i++]];\n  }\n\n  // **`v1()` - Generate time-based UUID**\n  //\n  // Inspired by https://github.com/LiosK/UUID.js\n  // and http://docs.python.org/library/uuid.html\n\n  // random #'s we need to init node and clockseq\n  var _seedBytes = _rng();\n\n  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n  var _nodeId = [\n    _seedBytes[0] | 0x01,\n    _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]\n  ];\n\n  // Per 4.2.2, randomize (14 bit) clockseq\n  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;\n\n  // Previous uuid creation time\n  var _lastMSecs = 0, _lastNSecs = 0;\n\n  // See https://github.com/broofa/node-uuid for API details\n  function v1(options, buf, offset) {\n    var i = buf && offset || 0;\n    var b = buf || [];\n\n    options = options || {};\n\n    var clockseq = options.clockseq != null ? options.clockseq : _clockseq;\n\n    // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n    var msecs = options.msecs != null ? options.msecs : new Date().getTime();\n\n    // Per 4.2.1.2, use count of uuid's generated during the current clock\n    // cycle to simulate higher resolution clock\n    var nsecs = options.nsecs != null ? options.nsecs : _lastNSecs + 1;\n\n    // Time since last uuid creation (in msecs)\n    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n    // Per 4.2.1.2, Bump clockseq on clock regression\n    if (dt < 0 && options.clockseq == null) {\n      clockseq = clockseq + 1 & 0x3fff;\n    }\n\n    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n    // time interval\n    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {\n      nsecs = 0;\n    }\n\n    // Per 4.2.1.2 Throw error if too many uuids are requested\n    if (nsecs >= 10000) {\n      throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n    }\n\n    _lastMSecs = msecs;\n    _lastNSecs = nsecs;\n    _clockseq = clockseq;\n\n    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n    msecs += 12219292800000;\n\n    // `time_low`\n    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n    b[i++] = tl >>> 24 & 0xff;\n    b[i++] = tl >>> 16 & 0xff;\n    b[i++] = tl >>> 8 & 0xff;\n    b[i++] = tl & 0xff;\n\n    // `time_mid`\n    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n    b[i++] = tmh >>> 8 & 0xff;\n    b[i++] = tmh & 0xff;\n\n    // `time_high_and_version`\n    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n    b[i++] = tmh >>> 16 & 0xff;\n\n    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n    b[i++] = clockseq >>> 8 | 0x80;\n\n    // `clock_seq_low`\n    b[i++] = clockseq & 0xff;\n\n    // `node`\n    var node = options.node || _nodeId;\n    for (var n = 0; n < 6; n++) {\n      b[i + n] = node[n];\n    }\n\n    return buf ? buf : unparse(b);\n  }\n\n  // **`v4()` - Generate random UUID**\n\n  // See https://github.com/broofa/node-uuid for API details\n  function v4(options, buf, offset) {\n    // Deprecated - 'format' argument, as supported in v1.2\n    var i = buf && offset || 0;\n\n    if (typeof(options) == 'string') {\n      buf = options == 'binary' ? new BufferClass(16) : null;\n      options = null;\n    }\n    options = options || {};\n\n    var rnds = options.random || (options.rng || _rng)();\n\n    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n    // Copy bytes to buffer, if provided\n    if (buf) {\n      for (var ii = 0; ii < 16; ii++) {\n        buf[i + ii] = rnds[ii];\n      }\n    }\n\n    return buf || unparse(rnds);\n  }\n\n  // Export public API\n  var uuid = v4;\n  uuid.v1 = v1;\n  uuid.v4 = v4;\n  uuid.parse = parse;\n  uuid.unparse = unparse;\n  uuid.BufferClass = BufferClass;\n\n  if (_global.define && define.amd) {\n    // Publish as AMD module\n    define(function() {return uuid;});\n  } else if (typeof(module) != 'undefined' && module.exports) {\n    // Publish as node.js module\n    module.exports = uuid;\n  } else {\n    // Publish as global (in browsers)\n    var _previousRoot = _global.uuid;\n\n    // **`noConflict()` - (browser only) to reset global 'uuid' var**\n    uuid.noConflict = function() {\n      _global.uuid = _previousRoot;\n      return uuid;\n    };\n\n    _global.uuid = uuid;\n  }\n}());\n\n//@ sourceURL=/node_modules/node-uuid/uuid.js"
));

require.define("crypto",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = require(\"crypto-browserify\")\n//@ sourceURL=crypto"
));

require.define("/node_modules/crypto-browserify/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/crypto-browserify/package.json"
));

require.define("/node_modules/crypto-browserify/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var sha = require('./sha')\nvar rng = require('./rng')\n\nvar algorithms = {\n  sha1: {\n    hex: sha.hex_sha1,\n    binary: sha.b64_sha1,\n    ascii: sha.str_sha1\n  }\n}\n\nfunction error () {\n  var m = [].slice.call(arguments).join(' ')\n  throw new Error([\n    m,\n    'we accept pull requests',\n    'http://github.com/dominictarr/crypto-browserify'\n    ].join('\\n'))\n}\n\nexports.createHash = function (alg) {\n  alg = alg || 'sha1'\n  if(!algorithms[alg])\n    error('algorithm:', alg, 'is not yet supported')\n  var s = ''\n  var _alg = algorithms[alg]\n  return {\n    update: function (data) {\n      s += data\n      return this\n    },\n    digest: function (enc) {\n      enc = enc || 'binary'\n      var fn\n      if(!(fn = _alg[enc]))\n        error('encoding:', enc , 'is not yet supported for algorithm', alg)\n      var r = fn(s)\n      s = null //not meant to use the hash after you've called digest.\n      return r\n    }\n  }\n}\n\nexports.randomBytes = function(size, callback) {\n  if (callback && callback.call) {\n    try {\n      callback.call(this, undefined, rng(size));\n    } catch (err) { callback(err); }\n  } else {\n    return rng(size);\n  }\n}\n\n// the least I can do is make error messages for the rest of the node.js/crypto api.\n;['createCredentials'\n, 'createHmac'\n, 'createCypher'\n, 'createCypheriv'\n, 'createDecipher'\n, 'createDecipheriv'\n, 'createSign'\n, 'createVerify'\n, 'createDeffieHellman'\n, 'pbkdf2'].forEach(function (name) {\n  exports[name] = function () {\n    error('sorry,', name, 'is not implemented yet')\n  }\n})\n\n//@ sourceURL=/node_modules/crypto-browserify/index.js"
));

require.define("/node_modules/crypto-browserify/sha.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined\n * in FIPS PUB 180-1\n * Version 2.1a Copyright Paul Johnston 2000 - 2002.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for details.\n */\n\nexports.hex_sha1 = hex_sha1;\nexports.b64_sha1 = b64_sha1;\nexports.str_sha1 = str_sha1;\nexports.hex_hmac_sha1 = hex_hmac_sha1;\nexports.b64_hmac_sha1 = b64_hmac_sha1;\nexports.str_hmac_sha1 = str_hmac_sha1;\n\n/*\n * Configurable variables. You may need to tweak these to be compatible with\n * the server-side, but the defaults work in most cases.\n */\nvar hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */\nvar b64pad  = \"\"; /* base-64 pad character. \"=\" for strict RFC compliance   */\nvar chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */\n\n/*\n * These are the functions you'll usually want to call\n * They take string arguments and return either hex or base-64 encoded strings\n */\nfunction hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));}\nfunction b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));}\nfunction str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));}\nfunction hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));}\nfunction b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));}\nfunction str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}\n\n/*\n * Perform a simple self-test to see if the VM is working\n */\nfunction sha1_vm_test()\n{\n  return hex_sha1(\"abc\") == \"a9993e364706816aba3e25717850c26c9cd0d89d\";\n}\n\n/*\n * Calculate the SHA-1 of an array of big-endian words, and a bit length\n */\nfunction core_sha1(x, len)\n{\n  /* append padding */\n  x[len >> 5] |= 0x80 << (24 - len % 32);\n  x[((len + 64 >> 9) << 4) + 15] = len;\n\n  var w = Array(80);\n  var a =  1732584193;\n  var b = -271733879;\n  var c = -1732584194;\n  var d =  271733878;\n  var e = -1009589776;\n\n  for(var i = 0; i < x.length; i += 16)\n  {\n    var olda = a;\n    var oldb = b;\n    var oldc = c;\n    var oldd = d;\n    var olde = e;\n\n    for(var j = 0; j < 80; j++)\n    {\n      if(j < 16) w[j] = x[i + j];\n      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);\n      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),\n                       safe_add(safe_add(e, w[j]), sha1_kt(j)));\n      e = d;\n      d = c;\n      c = rol(b, 30);\n      b = a;\n      a = t;\n    }\n\n    a = safe_add(a, olda);\n    b = safe_add(b, oldb);\n    c = safe_add(c, oldc);\n    d = safe_add(d, oldd);\n    e = safe_add(e, olde);\n  }\n  return Array(a, b, c, d, e);\n\n}\n\n/*\n * Perform the appropriate triplet combination function for the current\n * iteration\n */\nfunction sha1_ft(t, b, c, d)\n{\n  if(t < 20) return (b & c) | ((~b) & d);\n  if(t < 40) return b ^ c ^ d;\n  if(t < 60) return (b & c) | (b & d) | (c & d);\n  return b ^ c ^ d;\n}\n\n/*\n * Determine the appropriate additive constant for the current iteration\n */\nfunction sha1_kt(t)\n{\n  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :\n         (t < 60) ? -1894007588 : -899497514;\n}\n\n/*\n * Calculate the HMAC-SHA1 of a key and some data\n */\nfunction core_hmac_sha1(key, data)\n{\n  var bkey = str2binb(key);\n  if(bkey.length > 16) bkey = core_sha1(bkey, key.length * chrsz);\n\n  var ipad = Array(16), opad = Array(16);\n  for(var i = 0; i < 16; i++)\n  {\n    ipad[i] = bkey[i] ^ 0x36363636;\n    opad[i] = bkey[i] ^ 0x5C5C5C5C;\n  }\n\n  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);\n  return core_sha1(opad.concat(hash), 512 + 160);\n}\n\n/*\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n * to work around bugs in some JS interpreters.\n */\nfunction safe_add(x, y)\n{\n  var lsw = (x & 0xFFFF) + (y & 0xFFFF);\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return (msw << 16) | (lsw & 0xFFFF);\n}\n\n/*\n * Bitwise rotate a 32-bit number to the left.\n */\nfunction rol(num, cnt)\n{\n  return (num << cnt) | (num >>> (32 - cnt));\n}\n\n/*\n * Convert an 8-bit or 16-bit string to an array of big-endian words\n * In 8-bit function, characters >255 have their hi-byte silently ignored.\n */\nfunction str2binb(str)\n{\n  var bin = Array();\n  var mask = (1 << chrsz) - 1;\n  for(var i = 0; i < str.length * chrsz; i += chrsz)\n    bin[i>>5] |= (str.charCodeAt(i / chrsz) & mask) << (32 - chrsz - i%32);\n  return bin;\n}\n\n/*\n * Convert an array of big-endian words to a string\n */\nfunction binb2str(bin)\n{\n  var str = \"\";\n  var mask = (1 << chrsz) - 1;\n  for(var i = 0; i < bin.length * 32; i += chrsz)\n    str += String.fromCharCode((bin[i>>5] >>> (32 - chrsz - i%32)) & mask);\n  return str;\n}\n\n/*\n * Convert an array of big-endian words to a hex string.\n */\nfunction binb2hex(binarray)\n{\n  var hex_tab = hexcase ? \"0123456789ABCDEF\" : \"0123456789abcdef\";\n  var str = \"\";\n  for(var i = 0; i < binarray.length * 4; i++)\n  {\n    str += hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8+4)) & 0xF) +\n           hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8  )) & 0xF);\n  }\n  return str;\n}\n\n/*\n * Convert an array of big-endian words to a base-64 string\n */\nfunction binb2b64(binarray)\n{\n  var tab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n  var str = \"\";\n  for(var i = 0; i < binarray.length * 4; i += 3)\n  {\n    var triplet = (((binarray[i   >> 2] >> 8 * (3 -  i   %4)) & 0xFF) << 16)\n                | (((binarray[i+1 >> 2] >> 8 * (3 - (i+1)%4)) & 0xFF) << 8 )\n                |  ((binarray[i+2 >> 2] >> 8 * (3 - (i+2)%4)) & 0xFF);\n    for(var j = 0; j < 4; j++)\n    {\n      if(i * 8 + j * 6 > binarray.length * 32) str += b64pad;\n      else str += tab.charAt((triplet >> 6*(3-j)) & 0x3F);\n    }\n  }\n  return str;\n}\n\n\n//@ sourceURL=/node_modules/crypto-browserify/sha.js"
));

require.define("/node_modules/crypto-browserify/rng.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Original code adapted from Robert Kieffer.\n// details at https://github.com/broofa/node-uuid\n(function() {\n  var _global = this;\n\n  var mathRNG, whatwgRNG;\n\n  // NOTE: Math.random() does not guarantee \"cryptographic quality\"\n  mathRNG = function(size) {\n    var bytes = new Array(size);\n    var r;\n\n    for (var i = 0, r; i < size; i++) {\n      if ((i & 0x03) == 0) r = Math.random() * 0x100000000;\n      bytes[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return bytes;\n  }\n\n  // currently only available in webkit-based browsers.\n  if (_global.crypto && crypto.getRandomValues) {\n    var _rnds = new Uint32Array(4);\n    whatwgRNG = function(size) {\n      var bytes = new Array(size);\n      crypto.getRandomValues(_rnds);\n\n      for (var c = 0 ; c < size; c++) {\n        bytes[c] = _rnds[c >> 2] >>> ((c & 0x03) * 8) & 0xff;\n      }\n      return bytes;\n    }\n  }\n\n  module.exports = whatwgRNG || mathRNG;\n\n}())\n//@ sourceURL=/node_modules/crypto-browserify/rng.js"
));

require.define("/lib/equal.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var dotty = require(\"dotty\")\n\nmodule.exports = equal\n\nfunction equal(prop, value) {\n    return function (item) {\n        if (typeof prop === \"string\" || Array.isArray(prop)) {\n            return dotty.get(item, prop) === value\n        } else {\n            return item === value\n        }\n    }\n}\n\n//@ sourceURL=/lib/equal.js"
));

require.define("/node_modules/dotty/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"lib/index.js\"}\n//@ sourceURL=/node_modules/dotty/package.json"
));

require.define("/node_modules/dotty/lib/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"//\n// Dotty makes it easy to programmatically access arbitrarily nested objects and\n// their properties.\n//\n\n//\n// `object` is an object, `path` is the path to the property you want to check\n// for existence of.\n//\n// `path` can be provided as either a `\"string.separated.with.dots\"` or as\n// `[\"an\", \"array\"]`.\n//\n// Returns `true` if the path can be completely resolved, `false` otherwise.\n//\n\nvar exists = module.exports.exists = function exists(object, path) {\n  if (typeof path === \"string\") {\n    path = path.split(\".\");\n  }\n\n  if (!(path instanceof Array) || path.length === 0) {\n    return false;\n  }\n\n  path = path.slice();\n\n  var key = path.shift();\n\n  if (typeof object !== \"object\" || object === null) {\n    return false;\n  }\n\n  if (path.length === 0) {\n    return Object.hasOwnProperty.apply(object, [key]);\n  } else {\n    return exists(object[key], path);\n  }\n};\n\n//\n// These arguments are the same as those for `exists`.\n//\n// The return value, however, is the property you're trying to access, or\n// `undefined` if it can't be found. This means you won't be able to tell\n// the difference between an unresolved path and an undefined property, so you \n// should not use `get` to check for the existence of a property. Use `exists`\n// instead.\n//\n\nvar get = module.exports.get = function get(object, path) {\n  if (typeof path === \"string\") {\n    path = path.split(\".\");\n  }\n\n  if (!(path instanceof Array) || path.length === 0) {\n    return;\n  }\n\n  path = path.slice();\n\n  var key = path.shift();\n\n  if (typeof object !== \"object\" || object === null) {\n    return;\n  }\n\n  if (path.length === 0) {\n    return object[key];\n  }\n\n  if (path.length) {\n    return get(object[key], path);\n  }\n};\n\n//\n// Arguments are similar to `exists` and `get`, with the exception that path\n// components are regexes with some special cases. If a path component is `\"*\"`\n// on its own, it'll be converted to `/.*/`.\n//\n// The return value is an array of values where the key path matches the\n// specified criterion. If none match, an empty array will be returned.\n//\n\nvar search = module.exports.search = function search(object, path) {\n  if (typeof path === \"string\") {\n    path = path.split(\".\");\n  }\n\n  if (!(path instanceof Array) || path.length === 0) {\n    return;\n  }\n\n  path = path.slice();\n\n  var key = path.shift();\n\n  if (typeof object !== \"object\" || object === null) {\n    return;\n  }\n\n  if (key === \"*\") {\n    key = \".*\";\n  }\n\n  if (typeof key === \"string\") {\n    key = new RegExp(key);\n  }\n\n  if (path.length === 0) {\n    return Object.keys(object).filter(key.test.bind(key)).map(function(k) { return object[k]; });\n  } else {\n    return Array.prototype.concat.apply([], Object.keys(object).filter(key.test.bind(key)).map(function(k) { return search(object[k], path); }));\n  }\n};\n\n//\n// The first two arguments for `put` are the same as `exists` and `get`.\n//\n// The third argument is a value to `put` at the `path` of the `object`.\n// Objects in the middle will be created if they don't exist, or added to if\n// they do. If a value is encountered in the middle of the path that is *not*\n// an object, it will not be overwritten.\n//\n// The return value is `true` in the case that the value was `put`\n// successfully, or `false` otherwise.\n//\n\nvar put = module.exports.put = function put(object, path, value) {\n  if (typeof path === \"string\") {\n    path = path.split(\".\");\n  }\n\n  if (!(path instanceof Array) || path.length === 0) {\n    return false;\n  }\n  \n  path = path.slice();\n\n  var key = path.shift();\n\n  if (typeof object !== \"object\" || object === null) {\n    return false;\n  }\n\n  if (path.length === 0) {\n    object[key] = value;\n  } else {\n    if (typeof object[key] === \"undefined\") {\n      object[key] = {};\n    }\n\n    if (typeof object[key] !== \"object\" || object[key] === null) {\n      return false;\n    }\n\n    return put(object[key], path, value);\n  }\n};\n\n//@ sourceURL=/node_modules/dotty/lib/index.js"
));

require.define("/lib/method.js",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = method\n\nfunction method(name) {\n    return function (item) {\n        return item[name]()\n    }\n}\n\n//@ sourceURL=/lib/method.js"
));

require.define("/todo/entities.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*global open:true */\n\nvar events = require(\"dom-reduce/event\")\n    , map = require(\"reducers/map\")\n    , flatten = require(\"reducers/flatten\")\n    , filter = require(\"reducers/filter\")\n    , ClassList = require(\"class-list\")\n    , remove = require(\"insert\").remove\n    , prop = require(\"prop\")\n    , not = require(\"not\")\n\n    , method = require(\"../lib/method\")\n    , html = require(\"../lib/html\")\n    , forEach = require(\"../lib/forEach\")\n    , equal = require(\"../lib/equal\")\n    , writer = require(\"../reflex/writer\")\n    , entity = require(\"../reflex/entity\")\n    , factory = require(\"../reflex/factory\")\n    , completedCountHtml = require(\"./html/completedCount\")\n    , allCompletedHtml = require(\"./html/allCompleted\")\n    , todoHtml = require(\"./html/todo\")\n    , todoItem = require(\"./item\")\n\n    , ENTER = 13\n\nmodule.exports = {\n    completedCount: entity(\n        function read(component) {\n            var clicks = events(component.clear, \"click\")\n\n            return map(clicks, factory({\n                id: \"operation\"\n                , value: \"clearCompleted\"\n            }))\n        }\n        , writer(function swap(component, counter) {\n            component.completedCount.textContent = counter.completed\n        }, function open(options, value) {\n            return html(completedCountHtml)\n        }))\n    , allCompleted: entity(\n        function read(component) {\n            var clicks = events(component.all, \"click\")\n\n            return map(clicks, factory({\n                id: \"operation\"\n                , value: \"allCompleted\"\n            }))\n        }\n        , writer(function swap(component, counter) {\n            var all = component.all\n                , remaining = counter.remaining\n                , completed = counter.completed\n\n            if (remaining === 0 && completed > 0) {\n                all.checked = true\n            } else {\n                all.checked = false\n            }\n        }, function open(options, value) {\n            return html(allCompletedHtml)\n        }))\n    , todo: todoItem\n}\n\n//@ sourceURL=/todo/entities.js"
));

require.define("/node_modules/class-list/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index\"}\n//@ sourceURL=/node_modules/class-list/package.json"
));

require.define("/node_modules/class-list/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// contains, add, remove, toggle\n\nmodule.exports = ClassList\n\nfunction ClassList(elem) {\n    var cl = elem.classList\n\n    if (cl) {\n        return cl\n    }\n\n    var classList = {\n        add: add\n        , remove: remove\n        , contains: contains\n        , toggle: toggle\n        , toString: $toString\n        , length: 0\n        , item: item\n    }\n\n    return classList\n\n    function add(token) {\n        var list = getTokens()\n        if (list.indexOf(token) > -1) {\n            return\n        }\n        list.push(token)\n        setTokens(list)\n    }\n\n    function remove(token) {\n        var list = getTokens()\n            , index = list.indexOf(token)\n\n        if (index === -1) {\n            return\n        }\n\n        list.splice(index, 1)\n        setTokens(list)\n    }\n\n    function contains(token) {\n        return getTokens().indexOf(token) > -1\n    }\n\n    function toggle(token) {\n        if (contains(token)) {\n            remove(token)\n            return false\n        } else {\n            add(token)\n            return true\n        }\n    }\n\n    function $toString() {\n        return elem.className\n    }\n\n    function item(index) {\n        var tokens = getTokens()\n        return tokens[index] || null\n    }\n\n    function getTokens() {\n        var className = elem.className\n\n        return className.split(\" \").filter(isTruthy)\n    }\n\n    function setTokens(list) {\n        var length = list.length\n\n        elem.className = list.join(\" \")\n        classList.length = length\n\n        for (var i = 0; i < list.length; i++) {\n            classList[i] = list[i]\n        }\n\n        delete list[length]\n    }\n}\n\nfunction isTruthy(value) {\n    return !!value\n}\n//@ sourceURL=/node_modules/class-list/index.js"
));

require.define("/node_modules/prop/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/prop/package.json"
));

require.define("/node_modules/prop/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var dotty = require(\"dotty\").get\n\n// prop\n//\n// functional routine to get a property from an object\n//\n// var obj = {foo: 'bar'}\n// var result = prop('foo')(obj)\n//\nmodule.exports = function(name) {\n  return function(object) {\n    return dotty(object, name)\n  }\n}\n\n\n//@ sourceURL=/node_modules/prop/index.js"
));

require.define("/node_modules/not/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index\"}\n//@ sourceURL=/node_modules/not/package.json"
));

require.define("/node_modules/not/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = not\n\nfunction not(f) {\n    return negation\n\n    function negation() {\n        return !f.apply(this, arguments)\n    }\n}\n\n//@ sourceURL=/node_modules/not/index.js"
));

require.define("/todo/html/completedCount.html",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = '<button id=\"clear\" class=\"clear-completed\">\\n    Clear completed\\n    (<span id=\"completedCount\">0</span>)\\n</button>\\n'\n//@ sourceURL=/todo/html/completedCount.html"
));

require.define("/todo/html/allCompleted.html",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = '<div>\\n    <input id=\"all\" name=\"toggle-all\" class=\"toggle-all\" type=\"checkbox\">\\n    <label for=\"toggle-all\">Mark all as complete</label>\\n</div>\\n'\n//@ sourceURL=/todo/html/allCompleted.html"
));

require.define("/todo/html/todo.html",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = '<li>\\n    <div class=\"view\">\\n        <input id=\"toggle\" class=\"toggle\" type=\"checkbox\">\\n        <label id=\"text\"></label>\\n        <button id=\"destroy\" class=\"destroy\"></button>\\n    </div>\\n    <input id=\"input\" class=\"edit\">\\n</li>\\n'\n//@ sourceURL=/todo/html/todo.html"
));

require.define("/todo/item.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var events = require(\"dom-reduce/event\")\n    , map = require(\"reducers/map\")\n    , filter = require(\"reducers/filter\")\n    , flatten = require(\"reducers/flatten\")\n    , prop = require(\"prop\")\n    , ClassList = require(\"class-list\")\n    , not = require(\"not\")\n    , remove = require(\"insert\").remove\n\n    , factory = require(\"../reflex/factory\")\n    , entity = require(\"../reflex/entity\")\n    , writer = require(\"../reflex/writer\")\n    , equal = require(\"../lib/equal\")\n    , method = require(\"../lib/method\")\n    , forEach = require(\"../lib/forEach\")\n    , html = require(\"../lib/html\")\n    , todoHtml = require(\"./html/todo\")\n\n    , ENTER = 13\n\nmodule.exports = entity(\n    function read(component) {\n        var changesEvents = events(component.toggle, \"change\")\n            , checks = map(changesEvents, prop(\"target.checked\"))\n            , completions = map(checks\n                , factory(component, function (completed) {\n                    return {\n                        completed: completed\n                    }\n                }))\n\n        var destroyEvents = events(component.destroy, \"click\")\n            , destructions = map(destroyEvents\n                , factory(component, null))\n\n        var input = component.input\n            , root = component.root\n            , blurEvents = events(input, \"blur\")\n            , keyEvents = events(input, \"keypress\")\n\n        forEach(filter(keyEvents, equal(\"keyCode\", ENTER))\n            , function (event) {\n                event.target.blur()\n            })\n\n        var values = map(blurEvents, prop(\"target.value\"))\n            , trimmed = map(values, method(\"trim\"))\n\n        forEach(trimmed, function () {\n            ClassList(root).remove(\"editing\")\n        })\n\n        var deletions = map(\n            filter(values, not(Boolean))\n            , factory(component, null))\n\n        var changes = map(\n            filter(values, Boolean)\n            , factory(component, function (text) {\n                return {\n                    title: text\n                }\n            }))\n\n        return flatten([ destructions, completions\n            , changes, deletions ])\n    }\n    , writer(function swap(component, value) {\n        if (\"title\" in value) {\n            component.text.textContent = value.title\n            component.input.value = value.title\n        }\n\n        if (\"completed\" in value) {\n            var completed = value.completed\n\n            component.toggle.checked = value.completed\n\n            if (completed) {\n                ClassList(component.root).add(\"completed\")\n            } else {\n                ClassList(component.root).remove(\"completed\")\n            }\n        }\n    }, function open(options, value) {\n        var component = html(todoHtml)\n            , input = component.input\n            , root = component.root\n\n        component.id = value.id\n\n        forEach(events(component.text, \"dblclick\")\n            , function (event) {\n                ClassList(root).add(\"editing\")\n                input.focus()\n            })\n\n        return component\n    }, function close(component) {\n        remove(component.root)\n    }))\n\n//@ sourceURL=/todo/item.js"
));

require.define("/todo/forks.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var filter = require(\"reducers/filter\")\n    , reductions = require(\"reducers/reductions\")\n    , not = require(\"not\")\n\n    , summaries = require(\"../reflex/summaries\")\n\nfork.todos = todos\n\nmodule.exports = fork\n\nfunction fork(state) {\n    var output = state.output\n        , changes = summaries(output)\n        , todoChanges = filter(changes, function (change) {\n            return isTodo(change.name)\n        })\n        , counters = reductions(output, intoCounters, {})\n\n    return {\n        todoChanges: todoChanges\n        , counters: counters\n    }\n}\n\nfunction todos(current) {\n    return Object.keys(current)\n        .filter(isTodo)\n        .map(function (name) {\n            return current[name]\n        })\n        .filter(Boolean)\n}\n\nfunction isTodo(str) {\n    return str.substr(0, 5) === \"todo:\"\n}\n\nfunction intoCounters(_, current) {\n    var values = Object.keys(current)\n        .filter(isTodo)\n        .map(function (key) {\n            return current[key]\n        })\n        .filter(toBoolean)\n\n    return {\n        completed: values.filter(isCompleted).length\n        , remaining: values.filter(not(isCompleted)).length\n    }\n}\n\nfunction toBoolean(value) {\n    return !!value\n}\n\nfunction isCompleted(item) {\n    return item && item.completed\n}\n\n//@ sourceURL=/todo/forks.js"
));

require.define("/todo/operations.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var filter = require(\"reducers/filter\")\n    , map = require(\"reducers/map\")\n    , expand = require(\"reducers/expand\")\n    , not = require(\"not\")\n    , flatten = require(\"reducers/flatten\")\n\n    , delta = require(\"../reflex/state\").delta\n    , equal = require(\"../lib/equal\")\n    , forEach = require(\"../lib/forEach\")\n    , todos = require(\"./forks\").todos\n    , factory = require(\"../reflex/factory\")\n    , attribute = require(\"../lib/attribute\")\n\nmodule.exports = operations\n\nfunction operations(state) {\n    var clears = filter(state.output\n        , equal([delta, \"operation\", \"value\"], \"clearCompleted\"))\n\n    forEach(clears, function (v) {\n        console.log(\"clear\", v)\n    })\n\n    var removals = expand(clears, function (current) {\n        console.log(\"current clear\", todos(current))\n\n        return todos(current)\n            .filter(attribute(\"completed\"))\n            .map(factory(null))\n    })\n\n    var allCompleted = filter(state.output\n        , equal([delta, \"operation\", \"value\"], \"allCompleted\"))\n\n\n    forEach(allCompleted, function (v) {\n        console.log(\"all completed\", v)\n    })\n\n    var updates = expand(allCompleted, function (current) {\n        var items = todos(current)\n\n        console.log(\"current all\", items, current)\n\n        if (items.every(attribute(\"completed\"))) {\n            return items.map(factory({\n                completed: false\n            }))\n        }\n\n        return items\n            .filter(not(attribute(\"completed\")))\n            .map(factory({ completed: true }))\n    })\n\n    return flatten([ updates, removals ])\n}\n\n//@ sourceURL=/todo/operations.js"
));

require.define("/lib/attribute.js",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = attribute\n\nfunction attribute(name) {\n    return function (item) {\n        return item[name]\n    }\n}\n\n//@ sourceURL=/lib/attribute.js"
));

require.define("/node_modules/browserify-server/lib/other.js",Function(['require','module','exports','__dirname','__filename','process','global'],"require('/home/raynos/Documents/reflex-todo/node_modules/browserify-server/lib/dummy.js')\n//@ sourceURL=/node_modules/browserify-server/lib/other.js"
));
require("/node_modules/browserify-server/lib/other.js");

require.define("/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var livereload = require(\"live-reload\")(8081)\n    , prepend = require(\"insert\").prepend\n\n    , flow = require(\"./reflex/flow\")\n    , pipe = require(\"./lib/pipe\")\n    , forEach = require(\"./lib/forEach\")\n    , persist = require(\"./persist\")\n    , TodoList = require(\"./todo\")\n\n    , body = document.body\n    , state = window.state = flow({ summary: \"initial\" })\n    , todoList = TodoList(state)\n\npipe(todoList, state.input)\n\nprepend(document.body, todoList.view)\n\npersist(state)\n\nwindow.require = require\n\n//@ sourceURL=/index.js"
));
require("/index.js");
})();
